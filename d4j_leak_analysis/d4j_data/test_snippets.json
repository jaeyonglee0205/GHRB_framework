{"Math_89": ["    public void testAddNonComparable(){\n        try {\n            f.addValue(new Object()); // This was previously OK\n            fail(\"Expected IllegalArgumentException\");\n        } catch (IllegalArgumentException expected) {\n        }\n        f.clear();\n        f.addValue(1);\n        try {\n            f.addValue(new Object());\n            fail(\"Expected IllegalArgumentException\");\n        } catch (IllegalArgumentException expected) {\n        }\n    }\n"], "Math_42": ["    @Test\n    public void testMath713NegativeVariable() {\n        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {1.0, 1.0}, 0.0d);\n        ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n        constraints.add(new LinearConstraint(new double[] {1, 0}, Relationship.EQ, 1));\n\n        double epsilon = 1e-6;\n        SimplexSolver solver = new SimplexSolver();\n        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);\n\n        Assert.assertTrue(Precision.compareTo(solution.getPoint()[0], 0.0d, epsilon) >= 0);\n        Assert.assertTrue(Precision.compareTo(solution.getPoint()[1], 0.0d, epsilon) >= 0);\n    }\n"], "Math_102": ["    public void testChiSquare() throws Exception {\n \n        // Target values computed using R version 1.8.1 \n        // Some assembly required ;-)  \n        //      Use sum((obs - exp)^2/exp) for the chi-square statistic and\n        //      1 - pchisq(sum((obs - exp)^2/exp), length(obs) - 1) for the p-value\n        \n        long[] observed = {10, 9, 11};\n        double[] expected = {10, 10, 10};\n        assertEquals(\"chi-square statistic\", 0.2,  testStatistic.chiSquare(expected, observed), 10E-12);\n        assertEquals(\"chi-square p-value\", 0.904837418036, testStatistic.chiSquareTest(expected, observed), 1E-10);\n        \n        long[] observed1 = { 500, 623, 72, 70, 31 };\n        double[] expected1 = { 485, 541, 82, 61, 37 };\n        assertEquals( \"chi-square test statistic\", 9.023307936427388, testStatistic.chiSquare(expected1, observed1), 1E-10);\n        assertEquals(\"chi-square p-value\", 0.06051952647453607, testStatistic.chiSquareTest(expected1, observed1), 1E-9);\n        assertTrue(\"chi-square test reject\", testStatistic.chiSquareTest(expected1, observed1, 0.08));\n        assertTrue(\"chi-square test accept\", !testStatistic.chiSquareTest(expected1, observed1, 0.05));\n\n        try {\n            testStatistic.chiSquareTest(expected1, observed1, 95);\n            fail(\"alpha out of range, IllegalArgumentException expected\");\n        } catch (IllegalArgumentException ex) {\n            // expected\n        }  \n        \n        long[] tooShortObs = { 0 };\n        double[] tooShortEx = { 1 };\n        try {\n            testStatistic.chiSquare(tooShortEx, tooShortObs);\n            fail(\"arguments too short, IllegalArgumentException expected\");\n        } catch (IllegalArgumentException ex) {\n            // expected\n        }\n\n        // unmatched arrays\n        long[] unMatchedObs = { 0, 1, 2, 3 };\n        double[] unMatchedEx = { 1, 1, 2 };\n        try {\n            testStatistic.chiSquare(unMatchedEx, unMatchedObs);\n            fail(\"arrays have different lengths, IllegalArgumentException expected\");\n        } catch (IllegalArgumentException ex) {\n            // expected\n        }\n        \n        // 0 expected count\n        expected[0] = 0;\n        try {\n            testStatistic.chiSquareTest(expected, observed, .01);\n            fail(\"bad expected count, IllegalArgumentException expected\");\n        } catch (IllegalArgumentException ex) {\n            // expected\n        } \n        \n        // negative observed count\n        expected[0] = 1;\n        observed[0] = -1;\n        try {\n            testStatistic.chiSquareTest(expected, observed, .01);\n            fail(\"bad expected count, IllegalArgumentException expected\");\n        } catch (IllegalArgumentException ex) {\n            // expected\n        } \n        \n    }\n", "    public void testChiSquareIndependence() throws Exception {\n        \n        // Target values computed using R version 1.8.1 \n        \n        long[][] counts = { {40, 22, 43}, {91, 21, 28}, {60, 10, 22}};\n        assertEquals( \"chi-square test statistic\", 22.709027688, testStatistic.chiSquare(counts), 1E-9);\n        assertEquals(\"chi-square p-value\", 0.000144751460134, testStatistic.chiSquareTest(counts), 1E-9);\n        assertTrue(\"chi-square test reject\", testStatistic.chiSquareTest(counts, 0.0002));\n        assertTrue(\"chi-square test accept\", !testStatistic.chiSquareTest(counts, 0.0001));    \n        \n        long[][] counts2 = {{10, 15}, {30, 40}, {60, 90} };\n        assertEquals( \"chi-square test statistic\", 0.168965517241, testStatistic.chiSquare(counts2), 1E-9);\n        assertEquals(\"chi-square p-value\",0.918987499852, testStatistic.chiSquareTest(counts2), 1E-9);\n        assertTrue(\"chi-square test accept\", !testStatistic.chiSquareTest(counts2, 0.1)); \n        \n        // ragged input array\n        long[][] counts3 = { {40, 22, 43}, {91, 21, 28}, {60, 10}};\n        try {\n            testStatistic.chiSquare(counts3);\n            fail(\"Expecting IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            // expected\n        }\n        \n        // insufficient data\n        long[][] counts4 = {{40, 22, 43}};\n        try {\n            testStatistic.chiSquare(counts4);\n            fail(\"Expecting IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            // expected\n        } \n        long[][] counts5 = {{40}, {40}, {30}, {10}};\n        try {\n            testStatistic.chiSquare(counts5);\n            fail(\"Expecting IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            // expected\n        } \n        \n        // negative counts\n        long[][] counts6 = {{10, -2}, {30, 40}, {60, 90} };\n        try {\n            testStatistic.chiSquare(counts6);\n            fail(\"Expecting IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            // expected\n        } \n        \n        // bad alpha\n        try {\n            testStatistic.chiSquareTest(counts, 0);\n            fail(\"Expecting IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            // expected\n        } \n    }\n", "    public void testChiSquareLargeTestStatistic() throws Exception {\n        double[] exp = new double[] {\n            3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0, \n            232921.0, 437665.75\n        };\n\n        long[] obs = new long[] {\n            2372383, 584222, 257170, 17750155, 7903832, 489265, 209628, 393899\n        };\n        org.apache.commons.math.stat.inference.ChiSquareTestImpl csti =\n            new org.apache.commons.math.stat.inference.ChiSquareTestImpl(); \n        double cst = csti.chiSquareTest(exp, obs); \n        assertEquals(\"chi-square p-value\", 0.0, cst, 1E-3);\n        assertEquals( \"chi-square test statistic\", \n                114875.90421929007, testStatistic.chiSquare(exp, obs), 1E-9);\n    }\n", "    public void testChiSquareZeroCount() throws Exception {\n        // Target values computed using R version 1.8.1 \n        long[][] counts = { {40, 0, 4}, {91, 1, 2}, {60, 2, 0}};\n        assertEquals( \"chi-square test statistic\", 9.67444662263,\n                testStatistic.chiSquare(counts), 1E-9);\n        assertEquals(\"chi-square p-value\", 0.0462835770603,\n                testStatistic.chiSquareTest(counts), 1E-9);       \n    }\n", "    public void testChiSquareDataSetsComparisonEqualCounts()\n    throws Exception {\n        long[] observed1 = {10, 12, 12, 10};\n        long[] observed2 = {5, 15, 14, 10};    \n        assertEquals(\"chi-square p value\", 0.541096, \n                testStatistic.chiSquareTestDataSetsComparison(\n                observed1, observed2), 1E-6);\n        assertEquals(\"chi-square test statistic\", 2.153846,\n                testStatistic.chiSquareDataSetsComparison(\n                observed1, observed2), 1E-6);\n        assertFalse(\"chi-square test result\", \n                testStatistic.chiSquareTestDataSetsComparison(\n                observed1, observed2, 0.4));\n    }\n", "    public void testChiSquareDataSetsComparisonUnEqualCounts()\n    throws Exception {\n        long[] observed1 = {10, 12, 12, 10, 15};\n        long[] observed2 = {15, 10, 10, 15, 5};    \n        assertEquals(\"chi-square p value\", 0.124115, \n                testStatistic.chiSquareTestDataSetsComparison(\n                observed1, observed2), 1E-6);\n        assertEquals(\"chi-square test statistic\", 7.232189,\n                testStatistic.chiSquareDataSetsComparison(\n                observed1, observed2), 1E-6);\n        assertTrue(\"chi-square test result\", \n                testStatistic.chiSquareTestDataSetsComparison(\n                observed1, observed2, 0.13));\n        assertFalse(\"chi-square test result\", \n                testStatistic.chiSquareTestDataSetsComparison(\n                observed1, observed2, 0.12));\n    }\n", "    public void testChiSquareDataSetsComparisonBadCounts()\n    throws Exception {\n        long[] observed1 = {10, -1, 12, 10, 15};\n        long[] observed2 = {15, 10, 10, 15, 5};\n        try {\n            testStatistic.chiSquareTestDataSetsComparison(\n                    observed1, observed2);\n            fail(\"Expecting IllegalArgumentException - negative count\");\n        } catch (IllegalArgumentException ex) {\n            // expected\n        }\n        long[] observed3 = {10, 0, 12, 10, 15};\n        long[] observed4 = {15, 0, 10, 15, 5};\n        try {\n            testStatistic.chiSquareTestDataSetsComparison(\n                    observed3, observed4);\n            fail(\"Expecting IllegalArgumentException - double 0's\");\n        } catch (IllegalArgumentException ex) {\n            // expected\n        }\n        long[] observed5 = {10, 10, 12, 10, 15};\n        long[] observed6 = {0, 0, 0, 0, 0};\n        try {\n            testStatistic.chiSquareTestDataSetsComparison(\n                    observed5, observed6);\n            fail(\"Expecting IllegalArgumentException - vanishing counts\");\n        } catch (IllegalArgumentException ex) {\n            // expected\n        }\n    }\n", "    public void testChiSquare() throws Exception {\n        \n        // Target values computed using R version 1.8.1 \n        // Some assembly required ;-)  \n        //      Use sum((obs - exp)^2/exp) for the chi-square statistic and\n        //      1 - pchisq(sum((obs - exp)^2/exp), length(obs) - 1) for the p-value\n        \n        long[] observed = {10, 9, 11};\n        double[] expected = {10, 10, 10};\n        assertEquals(\"chi-square statistic\", 0.2,  TestUtils.chiSquare(expected, observed), 10E-12);\n        assertEquals(\"chi-square p-value\", 0.904837418036, TestUtils.chiSquareTest(expected, observed), 1E-10);\n        \n        long[] observed1 = { 500, 623, 72, 70, 31 };\n        double[] expected1 = { 485, 541, 82, 61, 37 };\n        assertEquals( \"chi-square test statistic\", 9.023307936427388, TestUtils.chiSquare(expected1, observed1), 1E-10);\n        assertEquals(\"chi-square p-value\", 0.06051952647453607, TestUtils.chiSquareTest(expected1, observed1), 1E-9);\n        assertTrue(\"chi-square test reject\", TestUtils.chiSquareTest(expected1, observed1, 0.07));\n        assertTrue(\"chi-square test accept\", !TestUtils.chiSquareTest(expected1, observed1, 0.05));\n\n        try {\n            TestUtils.chiSquareTest(expected1, observed1, 95);\n            fail(\"alpha out of range, IllegalArgumentException expected\");\n        } catch (IllegalArgumentException ex) {\n            // expected\n        }  \n        \n        long[] tooShortObs = { 0 };\n        double[] tooShortEx = { 1 };\n        try {\n            TestUtils.chiSquare(tooShortEx, tooShortObs);\n            fail(\"arguments too short, IllegalArgumentException expected\");\n        } catch (IllegalArgumentException ex) {\n            // expected\n        }\n\n        // unmatched arrays\n        long[] unMatchedObs = { 0, 1, 2, 3 };\n        double[] unMatchedEx = { 1, 1, 2 };\n        try {\n            TestUtils.chiSquare(unMatchedEx, unMatchedObs);\n            fail(\"arrays have different lengths, IllegalArgumentException expected\");\n        } catch (IllegalArgumentException ex) {\n            // expected\n        }\n        \n        // 0 expected count\n        expected[0] = 0;\n        try {\n            TestUtils.chiSquareTest(expected, observed, .01);\n            fail(\"bad expected count, IllegalArgumentException expected\");\n        } catch (IllegalArgumentException ex) {\n            // expected\n        } \n        \n        // negative observed count\n        expected[0] = 1;\n        observed[0] = -1;\n        try {\n            TestUtils.chiSquareTest(expected, observed, .01);\n            fail(\"bad expected count, IllegalArgumentException expected\");\n        } catch (IllegalArgumentException ex) {\n            // expected\n        } \n        \n    }\n", "    public void testChiSquareIndependence() throws Exception {\n        \n        // Target values computed using R version 1.8.1 \n        \n        long[][] counts = { {40, 22, 43}, {91, 21, 28}, {60, 10, 22}};\n        assertEquals( \"chi-square test statistic\", 22.709027688, TestUtils.chiSquare(counts), 1E-9);\n        assertEquals(\"chi-square p-value\", 0.000144751460134, TestUtils.chiSquareTest(counts), 1E-9);\n        assertTrue(\"chi-square test reject\", TestUtils.chiSquareTest(counts, 0.0002));\n        assertTrue(\"chi-square test accept\", !TestUtils.chiSquareTest(counts, 0.0001));    \n        \n        long[][] counts2 = {{10, 15}, {30, 40}, {60, 90} };\n        assertEquals( \"chi-square test statistic\", 0.168965517241, TestUtils.chiSquare(counts2), 1E-9);\n        assertEquals(\"chi-square p-value\",0.918987499852, TestUtils.chiSquareTest(counts2), 1E-9);\n        assertTrue(\"chi-square test accept\", !TestUtils.chiSquareTest(counts2, 0.1)); \n        \n        // ragged input array\n        long[][] counts3 = { {40, 22, 43}, {91, 21, 28}, {60, 10}};\n        try {\n            TestUtils.chiSquare(counts3);\n            fail(\"Expecting IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            // expected\n        }\n        \n        // insufficient data\n        long[][] counts4 = {{40, 22, 43}};\n        try {\n            TestUtils.chiSquare(counts4);\n            fail(\"Expecting IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            // expected\n        } \n        long[][] counts5 = {{40}, {40}, {30}, {10}};\n        try {\n            TestUtils.chiSquare(counts5);\n            fail(\"Expecting IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            // expected\n        } \n        \n        // negative counts\n        long[][] counts6 = {{10, -2}, {30, 40}, {60, 90} };\n        try {\n            TestUtils.chiSquare(counts6);\n            fail(\"Expecting IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            // expected\n        } \n        \n        // bad alpha\n        try {\n            TestUtils.chiSquareTest(counts, 0);\n            fail(\"Expecting IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            // expected\n        } \n    }\n", "    public void testChiSquareLargeTestStatistic() throws Exception {\n        double[] exp = new double[] {\n                3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0, \n                232921.0, 437665.75\n        };\n\n        long[] obs = new long[] {\n                2372383, 584222, 257170, 17750155, 7903832, 489265, 209628, 393899\n        };\n        org.apache.commons.math.stat.inference.ChiSquareTestImpl csti =\n            new org.apache.commons.math.stat.inference.ChiSquareTestImpl(); \n        double cst = csti.chiSquareTest(exp, obs); \n        assertEquals(\"chi-square p-value\", 0.0, cst, 1E-3);\n        assertEquals( \"chi-square test statistic\", \n                114875.90421929007, TestUtils.chiSquare(exp, obs), 1E-9);\n    }\n", "    public void testChiSquareZeroCount() throws Exception {\n        // Target values computed using R version 1.8.1 \n        long[][] counts = { {40, 0, 4}, {91, 1, 2}, {60, 2, 0}};\n        assertEquals( \"chi-square test statistic\", 9.67444662263,\n                TestUtils.chiSquare(counts), 1E-9);\n        assertEquals(\"chi-square p-value\", 0.0462835770603,\n                TestUtils.chiSquareTest(counts), 1E-9);       \n    }\n"], "Math_105": ["    public void testSSENonNegative() {\n        double[] y = { 8915.102, 8919.302, 8923.502 };\n        double[] x = { 1.107178495E2, 1.107264895E2, 1.107351295E2 };\n        SimpleRegression reg = new SimpleRegression();\n        for (int i = 0; i < x.length; i++) {\n            reg.addData(x[i], y[i]);\n        }\n        assertTrue(reg.getSumSquaredErrors() >= 0.0);\n    } \n"], "Math_45": ["    @Test(expected=NumberIsTooLargeException.class)\n    public void testMath679() {\n        new OpenMapRealMatrix(3, Integer.MAX_VALUE);\n    }\n"], "Math_87": ["    @Test\n    public void testSingleVariableAndConstraint() throws OptimizationException {\n        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 3 }, 0);\n        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n        constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.LEQ, 10));\n\n        SimplexSolver solver = new SimplexSolver();\n        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);\n        assertEquals(10.0, solution.getPoint()[0], 0.0);\n        assertEquals(30.0, solution.getValue(), 0.0);\n    }\n"], "Math_3": ["    @Test\n    public void testLinearCombinationWithSingleElementArray() {\n        final double[] a = { 1.23456789 };\n        final double[] b = { 98765432.1 };\n\n        Assert.assertEquals(a[0] * b[0], MathArrays.linearCombination(a, b), 0d);\n    }\n"], "Math_73": ["    public void testBadEndpoints() throws Exception {\n        UnivariateRealFunction f = new SinFunction();\n        UnivariateRealSolver solver = new BrentSolver();\n        try {  // bad interval\n            solver.solve(f, 1, -1);\n            fail(\"Expecting IllegalArgumentException - bad interval\");\n        } catch (IllegalArgumentException ex) {\n            // expected\n        }\n        try {  // no bracket\n            solver.solve(f, 1, 1.5);\n            fail(\"Expecting IllegalArgumentException - non-bracketing\");\n        } catch (IllegalArgumentException ex) {\n            // expected\n        }\n        try {  // no bracket\n            solver.solve(f, 1, 1.5, 1.2);\n            fail(\"Expecting IllegalArgumentException - non-bracketing\");\n        } catch (IllegalArgumentException ex) {\n            // expected\n        }\n    }\n"], "Math_74": ["    @Test\n    public void polynomial() throws DerivativeException, IntegratorException {\n        TestProblem6 pb = new TestProblem6();\n        double range = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n\n        for (int nSteps = 1; nSteps < 7; ++nSteps) {\n            AdamsMoultonIntegrator integ =\n                new AdamsMoultonIntegrator(nSteps, 1.0e-6 * range, 0.1 * range, 1.0e-9, 1.0e-9);\n            TestProblemHandler handler = new TestProblemHandler(pb, integ);\n            integ.addStepHandler(handler);\n            integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                            pb.getFinalTime(), new double[pb.getDimension()]);\n            if (nSteps < 4) {\n                assertTrue(integ.getEvaluations() > 140);\n            } else {\n                assertTrue(integ.getEvaluations() < 90);\n            }\n        }\n\n    }\n"], "Math_80": ["    public void testMathpbx02() {\n\n        double[] mainTridiagonal = {\n        \t  7484.860960227216, 18405.28129035345, 13855.225609560746,\n        \t 10016.708722343366, 559.8117399576674, 6750.190788301587, \n        \t    71.21428769782159\n        };\n        double[] secondaryTridiagonal = {\n        \t -4175.088570476366,1975.7955858241994,5193.178422374075, \n        \t  1995.286659169179,75.34535882933804,-234.0808002076056\n        };\n\n        // the reference values have been computed using routine DSTEMR\n        // from the fortran library LAPACK version 3.2.1\n        double[] refEigenValues = {\n        \t\t20654.744890306974412,16828.208208485466457,\n        \t\t6893.155912634994820,6757.083016675340332,\n        \t\t5887.799885688558788,64.309089923240379,\n        \t\t57.992628792736340\n        };\n        RealVector[] refEigenVectors = {\n        \t\tnew ArrayRealVector(new double[] {-0.270356342026904, 0.852811091326997, 0.399639490702077, 0.198794657813990, 0.019739323307666, 0.000106983022327, -0.000001216636321}),\n        \t\tnew ArrayRealVector(new double[] {0.179995273578326,-0.402807848153042,0.701870993525734,0.555058211014888,0.068079148898236,0.000509139115227,-0.000007112235617}),\n        \t\tnew ArrayRealVector(new double[] {-0.399582721284727,-0.056629954519333,-0.514406488522827,0.711168164518580,0.225548081276367,0.125943999652923,-0.004321507456014}),\n        \t\tnew ArrayRealVector(new double[] {0.058515721572821,0.010200130057739,0.063516274916536,-0.090696087449378,-0.017148420432597,0.991318870265707,-0.034707338554096}),\n        \t\tnew ArrayRealVector(new double[] {0.855205995537564,0.327134656629775,-0.265382397060548,0.282690729026706,0.105736068025572,-0.009138126622039,0.000367751821196}),\n        \t\tnew ArrayRealVector(new double[] {-0.002913069901144,-0.005177515777101,0.041906334478672,-0.109315918416258,0.436192305456741,0.026307315639535,0.891797507436344}),\n        \t\tnew ArrayRealVector(new double[] {-0.005738311176435,-0.010207611670378,0.082662420517928,-0.215733886094368,0.861606487840411,-0.025478530652759,-0.451080697503958})\n        };\n\n        // the following line triggers the exception\n        EigenDecomposition decomposition =\n            new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, MathUtils.SAFE_MIN);\n\n        double[] eigenValues = decomposition.getRealEigenvalues();\n        for (int i = 0; i < refEigenValues.length; ++i) {\n            assertEquals(refEigenValues[i], eigenValues[i], 1.0e-3);\n            if (refEigenVectors[i].dotProduct(decomposition.getEigenvector(i)) < 0) {\n                assertEquals(0, refEigenVectors[i].add(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);\n            } else {\n                assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);\n            }\n        }\n\n    }\n"], "Math_4": ["    @Test\n    public void testIntersectionNotIntersecting() throws MathIllegalArgumentException {\n        SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(1.5, 1, 1));\n        SubLine sub2 = new SubLine(new Vector3D(2, 3, 0), new Vector3D(2, 3, 0.5));\n        Assert.assertNull(sub1.intersection(sub2, true));\n        Assert.assertNull(sub1.intersection(sub2, false));\n    }\n", "    @Test\n    public void testIntersectionParallel() {\n        final SubLine sub1 = new SubLine(new Vector2D(0, 1), new Vector2D(0, 2));\n        final SubLine sub2 = new SubLine(new Vector2D(66, 3), new Vector2D(66, 4));\n        Assert.assertNull(sub1.intersection(sub2, true));\n        Assert.assertNull(sub1.intersection(sub2, false));\n    }\n"], "Math_20": ["    @Test\n    public void testMath864() {\n        final CMAESOptimizer optimizer = new CMAESOptimizer();\n        final MultivariateFunction fitnessFunction = new MultivariateFunction() {\n                @Override\n                public double value(double[] parameters) {\n                    final double target = 1;\n                    final double error = target - parameters[0];\n                    return error * error;\n                }\n            };\n\n        final double[] start = { 0 };\n        final double[] lower = { -1e6 };\n        final double[] upper = { 0.5 };\n        final double[] result = optimizer.optimize(10000, fitnessFunction, GoalType.MINIMIZE,\n                                                   start, lower, upper).getPoint();\n        Assert.assertTrue(\"Out of bounds (\" + result[0] + \" > \" + upper[0] + \")\",\n                          result[0] <= upper[0]);\n    }\n"], "Math_27": ["    @Test\n    public void testMath835() {\n        final int numer = Integer.MAX_VALUE / 99;\n        final int denom = 1;\n        final double percentage = 100 * ((double) numer) / denom;\n        final Fraction frac = new Fraction(numer, denom);\n        // With the implementation that preceded the fix suggested in MATH-835,\n        // this test was failing, due to overflow.\n        Assert.assertEquals(percentage, frac.percentageValue(), Math.ulp(percentage));\n    }\n"], "Math_18": ["    @Test\n    public void testFitAccuracyDependsOnBoundary() {\n        final CMAESOptimizer optimizer = new CMAESOptimizer();\n        final MultivariateFunction fitnessFunction = new MultivariateFunction() {\n                public double value(double[] parameters) {\n                    final double target = 11.1;\n                    final double error = target - parameters[0];\n                    return error * error;\n                }\n            };\n\n        final double[] start = { 1 };\n \n        // No bounds.\n        PointValuePair result = optimizer.optimize(100000, fitnessFunction, GoalType.MINIMIZE,\n                                                   start);\n        final double resNoBound = result.getPoint()[0];\n\n        // Optimum is near the lower bound.\n        final double[] lower = { -20 };\n        final double[] upper = { 5e16 };\n        result = optimizer.optimize(100000, fitnessFunction, GoalType.MINIMIZE,\n                                    start, lower, upper);\n        final double resNearLo = result.getPoint()[0];\n\n        // Optimum is near the upper bound.\n        lower[0] = -5e16;\n        upper[0] = 20;\n        result = optimizer.optimize(100000, fitnessFunction, GoalType.MINIMIZE,\n                                    start, lower, upper);\n        final double resNearHi = result.getPoint()[0];\n\n        // System.out.println(\"resNoBound=\" + resNoBound +\n        //                    \" resNearLo=\" + resNearLo +\n        //                    \" resNearHi=\" + resNearHi);\n\n        // The two values currently differ by a substantial amount, indicating that\n        // the bounds definition can prevent reaching the optimum.\n        Assert.assertEquals(resNoBound, resNearLo, 1e-3);\n        Assert.assertEquals(resNoBound, resNearHi, 1e-3);\n    }\n"], "Math_11": ["    @Test\n    public void testUnivariateDistribution() {\n        final double[] mu = { -1.5 };\n        final double[][] sigma = { { 1 } };\n \n        final MultivariateNormalDistribution multi = new MultivariateNormalDistribution(mu, sigma);\n\n        final NormalDistribution uni = new NormalDistribution(mu[0], sigma[0][0]);\n        final Random rng = new Random();\n        final int numCases = 100;\n        final double tol = Math.ulp(1d);\n        for (int i = 0; i < numCases; i++) {\n            final double v = rng.nextDouble() * 10 - 5;\n            Assert.assertEquals(uni.density(v), multi.density(new double[] { v }), tol);\n        }\n    }\n"], "Math_16": ["    @Test\n    public void testMath905LargePositive() {\n        final double start = StrictMath.log(Double.MAX_VALUE);\n        final double endT = StrictMath.sqrt(2) * StrictMath.sqrt(Double.MAX_VALUE);\n        final double end = 2 * StrictMath.log(endT);\n\n        double maxErr = 0;\n        for (double x = start; x < end; x += 1e-3) {\n            final double tst = FastMath.cosh(x);\n            final double ref = Math.cosh(x);\n            maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref));            \n        }\n        Assert.assertEquals(0, maxErr, 3);\n\n        for (double x = start; x < end; x += 1e-3) {\n            final double tst = FastMath.sinh(x);\n            final double ref = Math.sinh(x);\n            maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref));            \n        }\n        Assert.assertEquals(0, maxErr, 3);\n    }\n", "    @Test\n    public void testMath905LargeNegative() {\n        final double start = -StrictMath.log(Double.MAX_VALUE);\n        final double endT = StrictMath.sqrt(2) * StrictMath.sqrt(Double.MAX_VALUE);\n        final double end = -2 * StrictMath.log(endT);\n\n        double maxErr = 0;\n        for (double x = start; x > end; x -= 1e-3) {\n            final double tst = FastMath.cosh(x);\n            final double ref = Math.cosh(x);\n            maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref));            \n        }\n        Assert.assertEquals(0, maxErr, 3);\n\n        for (double x = start; x > end; x -= 1e-3) {\n            final double tst = FastMath.sinh(x);\n            final double ref = Math.sinh(x);\n            maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref));            \n        }\n        Assert.assertEquals(0, maxErr, 3);\n    }\n"], "Math_29": ["    @Test\n    public void testEbeMultiplySameType() {\n        doTestEbeBinaryOperation(BinaryOperation.MUL, false);\n    }\n", "    @Test\n    public void testEbeMultiplyMixedTypes() {\n        doTestEbeBinaryOperation(BinaryOperation.MUL, true);\n    }\n", "    @Test\n    public void testEbeDivideMixedTypes() {\n        doTestEbeBinaryOperation(BinaryOperation.DIV, true);\n    }\n"], "Math_81": ["    public void testMath308() {\n\n        double[] mainTridiagonal = {\n            22.330154644539597, 46.65485522478641, 17.393672330044705, 54.46687435351116, 80.17800767709437\n        };\n        double[] secondaryTridiagonal = {\n            13.04450406501361, -5.977590941539671, 2.9040909856707517, 7.1570352792841225\n        };\n\n        // the reference values have been computed using routine DSTEMR\n        // from the fortran library LAPACK version 3.2.1\n        double[] refEigenValues = {\n            82.044413207204002, 53.456697699894512, 52.536278520113882, 18.847969733754262, 14.138204224043099\n        };\n        RealVector[] refEigenVectors = {\n            new ArrayRealVector(new double[] { -0.000462690386766, -0.002118073109055,  0.011530080757413,  0.252322434584915,  0.967572088232592 }),\n            new ArrayRealVector(new double[] {  0.314647769490148,  0.750806415553905, -0.167700312025760, -0.537092972407375,  0.143854968127780 }),\n            new ArrayRealVector(new double[] {  0.222368839324646,  0.514921891363332, -0.021377019336614,  0.801196801016305, -0.207446991247740 }),\n            new ArrayRealVector(new double[] {  0.713933751051495, -0.190582113553930,  0.671410443368332, -0.056056055955050,  0.006541576993581 }),\n            new ArrayRealVector(new double[] {  0.584677060845929, -0.367177264979103, -0.721453187784497,  0.052971054621812, -0.005740715188257 })\n        };\n\n        EigenDecomposition decomposition =\n            new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, MathUtils.SAFE_MIN);\n\n        double[] eigenValues = decomposition.getRealEigenvalues();\n        for (int i = 0; i < refEigenValues.length; ++i) {\n            assertEquals(refEigenValues[i], eigenValues[i], 1.0e-5);\n            assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 2.0e-7);\n        }\n\n    }\n"], "Math_5": ["    @Test\n    public void testReciprocalZero() {\n        Assert.assertEquals(Complex.ZERO.reciprocal(), Complex.INF);\n    }\n"], "Math_75": ["    public void testPcts() {\n        f.addValue(oneL);\n        f.addValue(twoL);\n        f.addValue(oneI);\n        f.addValue(twoI);\n        f.addValue(threeL);\n        f.addValue(threeL);\n        f.addValue(3);\n        f.addValue(threeI);\n        assertEquals(\"one pct\",0.25,f.getPct(1),tolerance);\n        assertEquals(\"two pct\",0.25,f.getPct(Long.valueOf(2)),tolerance);\n        assertEquals(\"three pct\",0.5,f.getPct(threeL),tolerance);\n        // MATH-329\n        assertEquals(\"three (Object) pct\",0.5,f.getPct((Object) (Integer.valueOf(3))),tolerance);\n        assertEquals(\"five pct\",0,f.getPct(5),tolerance);\n        assertEquals(\"foo pct\",0,f.getPct(\"foo\"),tolerance);\n        assertEquals(\"one cum pct\",0.25,f.getCumPct(1),tolerance);\n        assertEquals(\"two cum pct\",0.50,f.getCumPct(Long.valueOf(2)),tolerance);\n        assertEquals(\"Integer argument\",0.50,f.getCumPct(Integer.valueOf(2)),tolerance);\n        assertEquals(\"three cum pct\",1.0,f.getCumPct(threeL),tolerance);\n        assertEquals(\"five cum pct\",1.0,f.getCumPct(5),tolerance);\n        assertEquals(\"zero cum pct\",0.0,f.getCumPct(0),tolerance);\n        assertEquals(\"foo cum pct\",0,f.getCumPct(\"foo\"),tolerance);\n    }\n"], "Math_72": ["    public void testRootEndpoints() throws Exception {\n        UnivariateRealFunction f = new SinFunction();\n        UnivariateRealSolver solver = new BrentSolver();\n\n        // endpoint is root\n        double result = solver.solve(f, Math.PI, 4);\n        assertEquals(Math.PI, result, solver.getAbsoluteAccuracy());\n\n        result = solver.solve(f, 3, Math.PI);\n        assertEquals(Math.PI, result, solver.getAbsoluteAccuracy());\n\n        result = solver.solve(f, Math.PI, 4, 3.5);\n        assertEquals(Math.PI, result, solver.getAbsoluteAccuracy());\n\n        result = solver.solve(f, 3, Math.PI, 3.07);\n        assertEquals(Math.PI, result, solver.getAbsoluteAccuracy());\n\n    }\n"], "Math_86": ["    @Test(expected = NotPositiveDefiniteMatrixException.class)\n    public void testNotPositiveDefinite() throws MathException {\n        CholeskyDecomposition cd = new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(new double[][] {\n                { 14, 11, 13, 15, 24 },\n                { 11, 34, 13, 8,  25 },\n                { 13, 13, 14, 15, 21 },\n                { 15, 8,  15, 18, 23 },\n                { 24, 25, 21, 23, 45 }\n        }));\n        System.out.println(cd.getL().multiply(cd.getLT()));\n    }\n", "    @Test(expected = NotPositiveDefiniteMatrixException.class)\n    public void testMath274() throws MathException {\n        new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(new double[][] {\n                { 0.40434286, -0.09376327, 0.30328980, 0.04909388 },\n                {-0.09376327,  0.10400408, 0.07137959, 0.04762857 },\n                { 0.30328980,  0.07137959, 0.30458776, 0.04882449 },\n                { 0.04909388,  0.04762857, 0.04882449, 0.07543265 }\n            \n        }));\n    }\n"], "Math_2": ["    @Test\n    public void testMath1021() {\n        final int N = 43130568;\n        final int m = 42976365;\n        final int n = 50;\n        final HypergeometricDistribution dist = new HypergeometricDistribution(N, m, n);\n\n        for (int i = 0; i < 100; i++) {\n            final int sample = dist.sample();\n            Assert.assertTrue(\"sample=\" + sample, 0 <= sample);\n            Assert.assertTrue(\"sample=\" + sample, sample <= n);\n        }\n    }\n"], "Math_44": ["    @Test\n    public void testIssue695() {\n\n        FirstOrderDifferentialEquations equation = new FirstOrderDifferentialEquations() {\n            \n            public int getDimension() {\n                return 1;\n            }\n            \n            public void computeDerivatives(double t, double[] y, double[] yDot) {\n                yDot[0] = 1.0;\n            }\n        };\n\n        DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.001, 1000, 1.0e-14, 1.0e-14);\n        integrator.addEventHandler(new ResettingEvent(10.99), 0.1, 1.0e-9, 1000);\n        integrator.addEventHandler(new ResettingEvent(11.01), 0.1, 1.0e-9, 1000);\n        integrator.setInitialStepSize(3.0);\n\n        double target = 30.0;\n        double[] y = new double[1];\n        double tEnd = integrator.integrate(equation, 0.0, y, target, y);\n        Assert.assertEquals(target, tEnd, 1.0e-10);\n        Assert.assertEquals(32.0, y[0], 1.0e-10);\n\n    }\n"], "Math_88": ["    @Test\n    public void testMath272() throws OptimizationException {\n        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 2, 2, 1 }, 0);\n        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n        constraints.add(new LinearConstraint(new double[] { 1, 1, 0 }, Relationship.GEQ,  1));\n        constraints.add(new LinearConstraint(new double[] { 1, 0, 1 }, Relationship.GEQ,  1));\n        constraints.add(new LinearConstraint(new double[] { 0, 1, 0 }, Relationship.GEQ,  1));\n\n        SimplexSolver solver = new SimplexSolver();\n        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);\n        \n        assertEquals(0.0, solution.getPoint()[0], .0000001);\n        assertEquals(1.0, solution.getPoint()[1], .0000001);\n        assertEquals(1.0, solution.getPoint()[2], .0000001);\n        assertEquals(3.0, solution.getValue(), .0000001);\n      }\n"], "Math_103": ["    public void testExtremeValues() throws Exception {\n        NormalDistribution distribution = (NormalDistribution) getDistribution();\n        distribution.setMean(0);\n        distribution.setStandardDeviation(1);\n        for (int i = 0; i < 100; i+=5) { // make sure no convergence exception\n            double lowerTail = distribution.cumulativeProbability((double)-i);\n            double upperTail = distribution.cumulativeProbability((double) i);\n            if (i < 10) { // make sure not top-coded\n                assertTrue(lowerTail > 0.0d);\n                assertTrue(upperTail < 1.0d);\n            }\n            else { // make sure top coding not reversed\n                assertTrue(lowerTail < 0.00001);\n                assertTrue(upperTail > 0.99999);\n            }\n        } \n   }\n"], "Math_43": ["    @Test\n    public void testOverrideVarianceWithMathClass() throws Exception {\n        double[] scores = {1, 2, 3, 4};\n        SummaryStatistics stats = new SummaryStatistics();\n        stats.setVarianceImpl(new Variance(false)); //use \"population variance\"\n        for(double i : scores) {\n          stats.addValue(i);\n        }\n        Assert.assertEquals((new Variance(false)).evaluate(scores),stats.getVariance(), 0); \n    }\n", "    @Test\n    public void testOverrideMeanWithMathClass() throws Exception {\n        double[] scores = {1, 2, 3, 4};\n        SummaryStatistics stats = new SummaryStatistics();\n        stats.setMeanImpl(new Mean()); \n        for(double i : scores) {\n          stats.addValue(i);\n        }\n        Assert.assertEquals((new Mean()).evaluate(scores),stats.getMean(), 0); \n    }\n", "    @Test\n    public void testOverrideGeoMeanWithMathClass() throws Exception {\n        double[] scores = {1, 2, 3, 4};\n        SummaryStatistics stats = new SummaryStatistics();\n        stats.setGeoMeanImpl(new GeometricMean()); \n        for(double i : scores) {\n          stats.addValue(i);\n        }\n        Assert.assertEquals((new GeometricMean()).evaluate(scores),stats.getGeometricMean(), 0); \n    }\n"], "Math_17": ["    @Test\n    public void testMultiply()\n    {\n        test(field.newDfp(\"1\").multiply(field.newDfp(\"1\")),      // Basic tests   1*1 = 1\n             field.newDfp(\"1\"),\n             0, \"Multiply #1\");\n\n        test(field.newDfp(\"1\").multiply(1),             // Basic tests   1*1 = 1\n             field.newDfp(\"1\"),\n             0, \"Multiply #2\");\n\n        test(field.newDfp(\"-1\").multiply(field.newDfp(\"1\")),     // Basic tests   -1*1 = -1\n             field.newDfp(\"-1\"),\n             0, \"Multiply #3\");\n\n        test(field.newDfp(\"-1\").multiply(1),            // Basic tests   -1*1 = -1\n             field.newDfp(\"-1\"),\n             0, \"Multiply #4\");\n\n        // basic tests with integers\n        test(field.newDfp(\"2\").multiply(field.newDfp(\"3\")),\n             field.newDfp(\"6\"),\n             0, \"Multiply #5\");\n\n        test(field.newDfp(\"2\").multiply(3),\n             field.newDfp(\"6\"),\n             0, \"Multiply #6\");\n\n        test(field.newDfp(\"-2\").multiply(field.newDfp(\"3\")),\n             field.newDfp(\"-6\"),\n             0, \"Multiply #7\");\n\n        test(field.newDfp(\"-2\").multiply(3),\n             field.newDfp(\"-6\"),\n             0, \"Multiply #8\");\n\n        test(field.newDfp(\"2\").multiply(field.newDfp(\"-3\")),\n             field.newDfp(\"-6\"),\n             0, \"Multiply #9\");\n\n        test(field.newDfp(\"-2\").multiply(field.newDfp(\"-3\")),\n             field.newDfp(\"6\"),\n             0, \"Multiply #10\");\n\n        //multiply by zero\n\n        test(field.newDfp(\"-2\").multiply(field.newDfp(\"0\")),\n             field.newDfp(\"-0\"),\n             0, \"Multiply #11\");\n\n        test(field.newDfp(\"-2\").multiply(0),\n             field.newDfp(\"-0\"),\n             0, \"Multiply #12\");\n\n        test(field.newDfp(\"2\").multiply(field.newDfp(\"0\")),\n             field.newDfp(\"0\"),\n             0, \"Multiply #13\");\n\n        test(field.newDfp(\"2\").multiply(0),\n             field.newDfp(\"0\"),\n             0, \"Multiply #14\");\n\n        test(field.newDfp(\"2\").multiply(pinf),\n             pinf,\n             0, \"Multiply #15\");\n\n        test(field.newDfp(\"2\").multiply(ninf),\n             ninf,\n             0, \"Multiply #16\");\n\n        test(field.newDfp(\"-2\").multiply(pinf),\n             ninf,\n             0, \"Multiply #17\");\n\n        test(field.newDfp(\"-2\").multiply(ninf),\n             pinf,\n             0, \"Multiply #18\");\n\n        test(ninf.multiply(field.newDfp(\"-2\")),\n             pinf,\n             0, \"Multiply #18.1\");\n\n        test(field.newDfp(\"5e131071\").multiply(2),\n             pinf,\n             DfpField.FLAG_OVERFLOW, \"Multiply #19\");\n\n        test(field.newDfp(\"5e131071\").multiply(field.newDfp(\"1.999999999999999\")),\n             field.newDfp(\"9.9999999999999950000e131071\"),\n             0, \"Multiply #20\");\n\n        test(field.newDfp(\"-5e131071\").multiply(2),\n             ninf,\n             DfpField.FLAG_OVERFLOW, \"Multiply #22\");\n\n        test(field.newDfp(\"-5e131071\").multiply(field.newDfp(\"1.999999999999999\")),\n             field.newDfp(\"-9.9999999999999950000e131071\"),\n             0, \"Multiply #23\");\n\n        test(field.newDfp(\"1e-65539\").multiply(field.newDfp(\"1e-65539\")),\n             field.newDfp(\"1e-131078\"),\n             DfpField.FLAG_UNDERFLOW, \"Multiply #24\");\n\n        test(field.newDfp(\"1\").multiply(nan),\n             nan,\n             0, \"Multiply #25\");\n\n        test(nan.multiply(field.newDfp(\"1\")),\n             nan,\n             0, \"Multiply #26\");\n\n        test(nan.multiply(pinf),\n             nan,\n             0, \"Multiply #27\");\n\n        test(pinf.multiply(nan),\n             nan,\n             0, \"Multiply #27\");\n\n        test(pinf.multiply(field.newDfp(\"0\")),\n             nan,\n             DfpField.FLAG_INVALID, \"Multiply #28\");\n\n        test(field.newDfp(\"0\").multiply(pinf),\n             nan,\n             DfpField.FLAG_INVALID, \"Multiply #29\");\n\n        test(pinf.multiply(pinf),\n             pinf,\n             0, \"Multiply #30\");\n\n        test(ninf.multiply(pinf),\n             ninf,\n             0, \"Multiply #31\");\n\n        test(pinf.multiply(ninf),\n             ninf,\n             0, \"Multiply #32\");\n\n        test(ninf.multiply(ninf),\n             pinf,\n             0, \"Multiply #33\");\n\n        test(pinf.multiply(1),\n             pinf,\n             0, \"Multiply #34\");\n\n        test(pinf.multiply(0),\n             nan,\n             DfpField.FLAG_INVALID, \"Multiply #35\");\n\n        test(nan.multiply(1),\n             nan,\n             0, \"Multiply #36\");\n\n        test(field.newDfp(\"1\").multiply(10000),\n             field.newDfp(\"10000\"),\n             0, \"Multiply #37\");\n\n        test(field.newDfp(\"2\").multiply(1000000),\n             field.newDfp(\"2000000\"),\n             0, \"Multiply #38\");\n\n        test(field.newDfp(\"1\").multiply(-1),\n             field.newDfp(\"-1\"),\n             0, \"Multiply #39\");\n    }\n"], "Math_28": ["    @Test\n    public void testMath828Cycle() {\n        LinearObjectiveFunction f = new LinearObjectiveFunction(\n                new double[] { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}, 0.0);\n        \n        ArrayList <LinearConstraint>constraints = new ArrayList<LinearConstraint>();\n\n        constraints.add(new LinearConstraint(new double[] {0.0, 16.0, 14.0, 69.0, 1.0, 85.0, 52.0, 43.0, 64.0, 97.0, 14.0, 74.0, 89.0, 28.0, 94.0, 58.0, 13.0, 22.0, 21.0, 17.0, 30.0, 25.0, 1.0, 59.0, 91.0, 78.0, 12.0, 74.0, 56.0, 3.0, 88.0,}, Relationship.GEQ, 91.0));\n        constraints.add(new LinearConstraint(new double[] {0.0, 60.0, 40.0, 81.0, 71.0, 72.0, 46.0, 45.0, 38.0, 48.0, 40.0, 17.0, 33.0, 85.0, 64.0, 32.0, 84.0, 3.0, 54.0, 44.0, 71.0, 67.0, 90.0, 95.0, 54.0, 99.0, 99.0, 29.0, 52.0, 98.0, 9.0,}, Relationship.GEQ, 54.0));\n        constraints.add(new LinearConstraint(new double[] {0.0, 41.0, 12.0, 86.0, 90.0, 61.0, 31.0, 41.0, 23.0, 89.0, 17.0, 74.0, 44.0, 27.0, 16.0, 47.0, 80.0, 32.0, 11.0, 56.0, 68.0, 82.0, 11.0, 62.0, 62.0, 53.0, 39.0, 16.0, 48.0, 1.0, 63.0,}, Relationship.GEQ, 62.0));\n        constraints.add(new LinearConstraint(new double[] {83.0, -76.0, -94.0, -19.0, -15.0, -70.0, -72.0, -57.0, -63.0, -65.0, -22.0, -94.0, -22.0, -88.0, -86.0, -89.0, -72.0, -16.0, -80.0, -49.0, -70.0, -93.0, -95.0, -17.0, -83.0, -97.0, -31.0, -47.0, -31.0, -13.0, -23.0,}, Relationship.GEQ, 0.0));\n        constraints.add(new LinearConstraint(new double[] {41.0, -96.0, -41.0, -48.0, -70.0, -43.0, -43.0, -43.0, -97.0, -37.0, -85.0, -70.0, -45.0, -67.0, -87.0, -69.0, -94.0, -54.0, -54.0, -92.0, -79.0, -10.0, -35.0, -20.0, -41.0, -41.0, -65.0, -25.0, -12.0, -8.0, -46.0,}, Relationship.GEQ, 0.0));\n        constraints.add(new LinearConstraint(new double[] {27.0, -42.0, -65.0, -49.0, -53.0, -42.0, -17.0, -2.0, -61.0, -31.0, -76.0, -47.0, -8.0, -93.0, -86.0, -62.0, -65.0, -63.0, -22.0, -43.0, -27.0, -23.0, -32.0, -74.0, -27.0, -63.0, -47.0, -78.0, -29.0, -95.0, -73.0,}, Relationship.GEQ, 0.0));\n        constraints.add(new LinearConstraint(new double[] {15.0, -46.0, -41.0, -83.0, -98.0, -99.0, -21.0, -35.0, -7.0, -14.0, -80.0, -63.0, -18.0, -42.0, -5.0, -34.0, -56.0, -70.0, -16.0, -18.0, -74.0, -61.0, -47.0, -41.0, -15.0, -79.0, -18.0, -47.0, -88.0, -68.0, -55.0,}, Relationship.GEQ, 0.0));\n        \n        double epsilon = 1e-6;\n        PointValuePair solution = new SimplexSolver().optimize(f, constraints, GoalType.MINIMIZE, true);\n        Assert.assertEquals(1.0d, solution.getValue(), epsilon);\n        Assert.assertTrue(validSolution(solution, constraints, epsilon));        \n    }\n"], "Math_10": ["    @Test\n    public void testAtan2SpecialCases() {\n\n        DerivativeStructure pp =\n                DerivativeStructure.atan2(new DerivativeStructure(2, 2, 1, +0.0),\n                                          new DerivativeStructure(2, 2, 1, +0.0));\n        Assert.assertEquals(0, pp.getValue(), 1.0e-15);\n        Assert.assertEquals(+1, FastMath.copySign(1, pp.getValue()), 1.0e-15);\n\n        DerivativeStructure pn =\n                DerivativeStructure.atan2(new DerivativeStructure(2, 2, 1, +0.0),\n                                          new DerivativeStructure(2, 2, 1, -0.0));\n        Assert.assertEquals(FastMath.PI, pn.getValue(), 1.0e-15);\n\n        DerivativeStructure np =\n                DerivativeStructure.atan2(new DerivativeStructure(2, 2, 1, -0.0),\n                                          new DerivativeStructure(2, 2, 1, +0.0));\n        Assert.assertEquals(0, np.getValue(), 1.0e-15);\n        Assert.assertEquals(-1, FastMath.copySign(1, np.getValue()), 1.0e-15);\n\n        DerivativeStructure nn =\n                DerivativeStructure.atan2(new DerivativeStructure(2, 2, 1, -0.0),\n                                          new DerivativeStructure(2, 2, 1, -0.0));\n        Assert.assertEquals(-FastMath.PI, nn.getValue(), 1.0e-15);\n\n    }\n"], "Math_26": ["    @Test\n    public void testIntegerOverflow() {\n        checkIntegerOverflow(0.75000000001455192);\n        checkIntegerOverflow(1.0e10);\n        checkIntegerOverflow(-1.0e10);\n        checkIntegerOverflow(-43979.60679604749);\n    }\n"], "Math_19": ["    @Test(expected=NumberIsTooLargeException.class)\n    public void testBoundaryRangeTooLarge() {\n        final CMAESOptimizer optimizer = new CMAESOptimizer();\n        final MultivariateFunction fitnessFunction = new MultivariateFunction() {\n                public double value(double[] parameters) {\n                    if (Double.isNaN(parameters[0])) {\n                        throw new MathIllegalStateException();\n                    }\n                    final double target = 1;\n                    final double error = target - parameters[0];\n                    return error * error;\n                }\n            };\n\n        final double[] start = { 0 };\n\n        // The difference between upper and lower bounds is used to used\n        // normalize the variables: In case of overflow, NaN is produced.\n        final double max = Double.MAX_VALUE / 2;\n        final double tooLarge = FastMath.nextUp(max);\n        final double[] lower = { -tooLarge };\n        final double[] upper = { tooLarge };\n        final double[] result = optimizer.optimize(10000, fitnessFunction, GoalType.MINIMIZE,\n                                                   start, lower, upper).getPoint();\n    }\n"], "Math_21": ["    @Test\n    public void testFullRank() {\n\n        RealMatrix base = MatrixUtils.createRealMatrix(new double[][] {\n            { 0.1159548705,      0.,           0.,           0.      },\n            { 0.0896442724, 0.1223540781,      0.,           0.      },\n            { 0.0852155322, 4.558668e-3,  0.1083577299,      0.      },\n            { 0.0905486674, 0.0213768077, 0.0128878333, 0.1014155693 }\n        });\n\n        RealMatrix m = base.multiply(base.transpose());\n\n        RectangularCholeskyDecomposition d =\n                new RectangularCholeskyDecomposition(m, 1.0e-10);\n\n        RealMatrix root = d.getRootMatrix();\n        RealMatrix rebuiltM = root.multiply(root.transpose());\n        Assert.assertEquals(0.0, m.subtract(rebuiltM).getNorm(), 1.0e-15);\n\n        // the pivoted Cholesky decomposition is *not* unique. Here, the root is\n        // not equal to the original trianbular base matrix\n        Assert.assertTrue(root.subtract(base).getNorm() > 0.3);\n\n    }\n", "    @Test\n    public void testMath789() {\n\n        final RealMatrix m1 = MatrixUtils.createRealMatrix(new double[][]{\n            {0.013445532, 0.010394690, 0.009881156, 0.010499559},\n            {0.010394690, 0.023006616, 0.008196856, 0.010732709},\n            {0.009881156, 0.008196856, 0.019023866, 0.009210099},\n            {0.010499559, 0.010732709, 0.009210099, 0.019107243}\n        });\n        RealMatrix root1 = new RectangularCholeskyDecomposition(m1, 1.0e-10).getRootMatrix();\n        RealMatrix rebuiltM1 = root1.multiply(root1.transpose());\n        Assert.assertEquals(0.0, m1.subtract(rebuiltM1).getNorm(), 1.0e-16);\n\n        final RealMatrix m2 = MatrixUtils.createRealMatrix(new double[][]{\n            {0.0, 0.0, 0.0, 0.0, 0.0},\n            {0.0, 0.013445532, 0.010394690, 0.009881156, 0.010499559},\n            {0.0, 0.010394690, 0.023006616, 0.008196856, 0.010732709},\n            {0.0, 0.009881156, 0.008196856, 0.019023866, 0.009210099},\n            {0.0, 0.010499559, 0.010732709, 0.009210099, 0.019107243}\n        });\n        RealMatrix root2 = new RectangularCholeskyDecomposition(m2, 1.0e-10).getRootMatrix();\n        RealMatrix rebuiltM2 = root2.multiply(root2.transpose());\n        Assert.assertEquals(0.0, m2.subtract(rebuiltM2).getNorm(), 1.0e-16);\n\n        final RealMatrix m3 = MatrixUtils.createRealMatrix(new double[][]{\n            {0.013445532, 0.010394690, 0.0, 0.009881156, 0.010499559},\n            {0.010394690, 0.023006616, 0.0, 0.008196856, 0.010732709},\n            {0.0, 0.0, 0.0, 0.0, 0.0},\n            {0.009881156, 0.008196856, 0.0, 0.019023866, 0.009210099},\n            {0.010499559, 0.010732709, 0.0, 0.009210099, 0.019107243}\n        });\n        RealMatrix root3 = new RectangularCholeskyDecomposition(m3, 1.0e-10).getRootMatrix();\n        RealMatrix rebuiltM3 = root3.multiply(root3.transpose());\n        Assert.assertEquals(0.0, m3.subtract(rebuiltM3).getNorm(), 1.0e-16);\n\n    }\n"], "Closure_44": ["  public void testIssue620() {\n    assertPrint(\"alert(/ / / / /);\", \"alert(/ // / /)\");\n    assertPrint(\"alert(/ // / /);\", \"alert(/ // / /)\");\n  }\n"], "Time_8": ["    public void testForOffsetHoursMinutes_int_int() {\n        assertEquals(DateTimeZone.UTC, DateTimeZone.forOffsetHoursMinutes(0, 0));\n        assertEquals(DateTimeZone.forID(\"+23:59\"), DateTimeZone.forOffsetHoursMinutes(23, 59));\n        \n        assertEquals(DateTimeZone.forID(\"+02:15\"), DateTimeZone.forOffsetHoursMinutes(2, 15));\n        assertEquals(DateTimeZone.forID(\"+02:00\"), DateTimeZone.forOffsetHoursMinutes(2, 0));\n        try {\n            DateTimeZone.forOffsetHoursMinutes(2, -15);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        \n        assertEquals(DateTimeZone.forID(\"+00:15\"), DateTimeZone.forOffsetHoursMinutes(0, 15));\n        assertEquals(DateTimeZone.forID(\"+00:00\"), DateTimeZone.forOffsetHoursMinutes(0, 0));\n        assertEquals(DateTimeZone.forID(\"-00:15\"), DateTimeZone.forOffsetHoursMinutes(0, -15));\n        \n        assertEquals(DateTimeZone.forID(\"-02:00\"), DateTimeZone.forOffsetHoursMinutes(-2, 0));\n        assertEquals(DateTimeZone.forID(\"-02:15\"), DateTimeZone.forOffsetHoursMinutes(-2, -15));\n        assertEquals(DateTimeZone.forID(\"-02:15\"), DateTimeZone.forOffsetHoursMinutes(-2, 15));\n        \n        assertEquals(DateTimeZone.forID(\"-23:59\"), DateTimeZone.forOffsetHoursMinutes(-23, 59));\n        try {\n            DateTimeZone.forOffsetHoursMinutes(2, 60);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            DateTimeZone.forOffsetHoursMinutes(-2, 60);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            DateTimeZone.forOffsetHoursMinutes(24, 0);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            DateTimeZone.forOffsetHoursMinutes(-24, 0);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }        \n"], "Closure_108": ["  public void testIssue1144() {\n    test(\"var ns = {};\" +\n         \"ns.sub = {};\" +\n         \"/** @constructor */ ns.sub.C = function () {};\" +\n         \"goog.scope(function () {\" +\n         \"  var sub = ns.sub;\" +\n         \"  /** @type {sub.C} */\" +\n         \"  var x = null;\" +\n         \"});\",\n         SCOPE_NAMESPACE +\n         \"var ns = {};\" +\n         \"ns.sub = {};\" +\n         \"/** @constructor */ ns.sub.C = function () {};\" +\n         \"$jscomp.scope.x = null;\");\n  }\n"], "Lang_31": ["\tpublic void testContainsAnyStringWithSupplementaryChars() {\n\t\tassertEquals(true, StringUtils.containsAny(CharU20000 + CharU20001, CharU20000));\n\t\tassertEquals(true, StringUtils.containsAny(CharU20000 + CharU20001, CharU20001));\n\t\tassertEquals(true, StringUtils.containsAny(CharU20000, CharU20000));\n\t\t// Sanity check:\n\t\tassertEquals(-1, CharU20000.indexOf(CharU20001));\n\t\tassertEquals(0, CharU20000.indexOf(CharU20001.charAt(0)));\n\t\tassertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1)));\n\t\t// Test:\n\t\tassertEquals(false, StringUtils.containsAny(CharU20000, CharU20001));\n\t\tassertEquals(false, StringUtils.containsAny(CharU20001, CharU20000));\n\t}\n", "\tpublic void testContainsAnyCharArrayWithSupplementaryChars() {\n\t\tassertEquals(true, StringUtils.containsAny(CharU20000 + CharU20001, CharU20000.toCharArray()));\n\t\tassertEquals(true, StringUtils.containsAny(CharU20000 + CharU20001, CharU20001.toCharArray()));\n\t\tassertEquals(true, StringUtils.containsAny(CharU20000, CharU20000.toCharArray()));\n\t\t// Sanity check:\n\t\tassertEquals(-1, CharU20000.indexOf(CharU20001));\n\t\tassertEquals(0, CharU20000.indexOf(CharU20001.charAt(0)));\n\t\tassertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1)));\n\t\t// Test:\n\t\tassertEquals(false, StringUtils.containsAny(CharU20000, CharU20001.toCharArray()));\n\t\tassertEquals(false, StringUtils.containsAny(CharU20001, CharU20000.toCharArray()));\n\t}\n"], "Closure_130": ["  public void testIssue931() {\n    collapsePropertiesOnExternTypes = true;\n    testSame(\n      \"function f() {\\n\" +\n      \"  return function () {\\n\" +\n      \"    var args = arguments;\\n\" +\n      \"    setTimeout(function() { alert(args); }, 0);\\n\" +\n      \"  }\\n\" +\n      \"};\\n\");\n  }\n"], "Closure_43": ["  public void testLends10() throws Exception {\n    testTypes(\n        \"function defineClass(x) { return function() {}; } \" +\n        \"/** @constructor */\" +\n        \"var Foo = defineClass(\" +\n        \"    /** @lends {Foo.prototype} */ ({/** @type {number} */ bar: 1}));\" +\n        \"/** @return {string} */ function f() { return (new Foo()).bar; }\",\n        \"inconsistent return type\\n\" +\n        \"found   : number\\n\" +\n        \"required: string\");\n  }\n", "  public void testLends11() throws Exception {\n    testTypes(\n        \"function defineClass(x, y) { return function() {}; } \" +\n        \"/** @constructor */\" +\n        \"var Foo = function() {};\" +\n        \"/** @return {*} */ Foo.prototype.bar = function() { return 3; };\" +\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" * @extends {Foo}\\n\" +\n        \" */\\n\" +\n        \"var SubFoo = defineClass(Foo, \" +\n        \"    /** @lends {SubFoo.prototype} */ ({\\n\" +\n        \"      /** @return {number} */ bar: function() { return 3; }}));\" +\n        \"/** @return {string} */ function f() { return (new SubFoo()).bar(); }\",\n        \"inconsistent return type\\n\" +\n        \"found   : number\\n\" +\n        \"required: string\");\n  }\n"], "Lang_36": ["    public void testCreateNumber() {\n        // a lot of things can go wrong\n        assertEquals(\"createNumber(String) 1 failed\", new Float(\"1234.5\"), NumberUtils.createNumber(\"1234.5\"));\n        assertEquals(\"createNumber(String) 2 failed\", new Integer(\"12345\"), NumberUtils.createNumber(\"12345\"));\n        assertEquals(\"createNumber(String) 3 failed\", new Double(\"1234.5\"), NumberUtils.createNumber(\"1234.5D\"));\n        assertEquals(\"createNumber(String) 3 failed\", new Double(\"1234.5\"), NumberUtils.createNumber(\"1234.5d\"));\n        assertEquals(\"createNumber(String) 4 failed\", new Float(\"1234.5\"), NumberUtils.createNumber(\"1234.5F\"));\n        assertEquals(\"createNumber(String) 4 failed\", new Float(\"1234.5\"), NumberUtils.createNumber(\"1234.5f\"));\n        assertEquals(\"createNumber(String) 5 failed\", new Long(Integer.MAX_VALUE + 1L), NumberUtils.createNumber(\"\"\n            + (Integer.MAX_VALUE + 1L)));\n        assertEquals(\"createNumber(String) 6 failed\", new Long(12345), NumberUtils.createNumber(\"12345L\"));\n        assertEquals(\"createNumber(String) 6 failed\", new Long(12345), NumberUtils.createNumber(\"12345l\"));\n        assertEquals(\"createNumber(String) 7 failed\", new Float(\"-1234.5\"), NumberUtils.createNumber(\"-1234.5\"));\n        assertEquals(\"createNumber(String) 8 failed\", new Integer(\"-12345\"), NumberUtils.createNumber(\"-12345\"));\n        assertTrue(\"createNumber(String) 9 failed\", 0xFADE == NumberUtils.createNumber(\"0xFADE\").intValue());\n        assertTrue(\"createNumber(String) 10 failed\", -0xFADE == NumberUtils.createNumber(\"-0xFADE\").intValue());\n        assertEquals(\"createNumber(String) 11 failed\", new Double(\"1.1E200\"), NumberUtils.createNumber(\"1.1E200\"));\n        assertEquals(\"createNumber(String) 12 failed\", new Float(\"1.1E20\"), NumberUtils.createNumber(\"1.1E20\"));\n        assertEquals(\"createNumber(String) 13 failed\", new Double(\"-1.1E200\"), NumberUtils.createNumber(\"-1.1E200\"));\n        assertEquals(\"createNumber(String) 14 failed\", new Double(\"1.1E-200\"), NumberUtils.createNumber(\"1.1E-200\"));\n        assertEquals(\"createNumber(null) failed\", null, NumberUtils.createNumber(null));\n        assertEquals(\"createNumber(String) failed\", new BigInteger(\"12345678901234567890\"), NumberUtils\n                .createNumber(\"12345678901234567890L\"));\n\n        // jdk 1.2 doesn't support this. unsure about jdk 1.2.2\n        if (SystemUtils.isJavaVersionAtLeast(1.3f)) {\n            assertEquals(\"createNumber(String) 15 failed\", new BigDecimal(\"1.1E-700\"), NumberUtils\n                    .createNumber(\"1.1E-700F\"));\n        }\n        assertEquals(\"createNumber(String) 16 failed\", new Long(\"10\" + Integer.MAX_VALUE), NumberUtils\n                .createNumber(\"10\" + Integer.MAX_VALUE + \"L\"));\n        assertEquals(\"createNumber(String) 17 failed\", new Long(\"10\" + Integer.MAX_VALUE), NumberUtils\n                .createNumber(\"10\" + Integer.MAX_VALUE));\n        assertEquals(\"createNumber(String) 18 failed\", new BigInteger(\"10\" + Long.MAX_VALUE), NumberUtils\n                .createNumber(\"10\" + Long.MAX_VALUE));\n\n        // LANG-521\n        assertEquals(\"createNumber(String) LANG-521 failed\", new Float(\"2.\"), NumberUtils.createNumber(\"2.\"));\n    }\n", "    public void testIsNumber() {\n        String val = \"12345\";\n        assertTrue(\"isNumber(String) 1 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 1 failed\", checkCreateNumber(val));\n        val = \"1234.5\";\n        assertTrue(\"isNumber(String) 2 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 2 failed\", checkCreateNumber(val));\n        val = \".12345\";\n        assertTrue(\"isNumber(String) 3 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 3 failed\", checkCreateNumber(val));\n        val = \"1234E5\";\n        assertTrue(\"isNumber(String) 4 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 4 failed\", checkCreateNumber(val));\n        val = \"1234E+5\";\n        assertTrue(\"isNumber(String) 5 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 5 failed\", checkCreateNumber(val));\n        val = \"1234E-5\";\n        assertTrue(\"isNumber(String) 6 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 6 failed\", checkCreateNumber(val));\n        val = \"123.4E5\";\n        assertTrue(\"isNumber(String) 7 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 7 failed\", checkCreateNumber(val));\n        val = \"-1234\";\n        assertTrue(\"isNumber(String) 8 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 8 failed\", checkCreateNumber(val));\n        val = \"-1234.5\";\n        assertTrue(\"isNumber(String) 9 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 9 failed\", checkCreateNumber(val));\n        val = \"-.12345\";\n        assertTrue(\"isNumber(String) 10 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 10 failed\", checkCreateNumber(val));\n        val = \"-1234E5\";\n        assertTrue(\"isNumber(String) 11 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 11 failed\", checkCreateNumber(val));\n        val = \"0\";\n        assertTrue(\"isNumber(String) 12 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 12 failed\", checkCreateNumber(val));\n        val = \"-0\";\n        assertTrue(\"isNumber(String) 13 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 13 failed\", checkCreateNumber(val));\n        val = \"01234\";\n        assertTrue(\"isNumber(String) 14 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 14 failed\", checkCreateNumber(val));\n        val = \"-01234\";\n        assertTrue(\"isNumber(String) 15 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 15 failed\", checkCreateNumber(val));\n        val = \"0xABC123\";\n        assertTrue(\"isNumber(String) 16 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 16 failed\", checkCreateNumber(val));\n        val = \"0x0\";\n        assertTrue(\"isNumber(String) 17 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 17 failed\", checkCreateNumber(val));\n        val = \"123.4E21D\";\n        assertTrue(\"isNumber(String) 19 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 19 failed\", checkCreateNumber(val));\n        val = \"-221.23F\";\n        assertTrue(\"isNumber(String) 20 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 20 failed\", checkCreateNumber(val));\n        val = \"22338L\";\n        assertTrue(\"isNumber(String) 21 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 21 failed\", checkCreateNumber(val));\n        val = null;\n        assertTrue(\"isNumber(String) 1 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 1 Neg failed\", !checkCreateNumber(val));\n        val = \"\";\n        assertTrue(\"isNumber(String) 2 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 2 Neg failed\", !checkCreateNumber(val));\n        val = \"--2.3\";\n        assertTrue(\"isNumber(String) 3 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 3 Neg failed\", !checkCreateNumber(val));\n        val = \".12.3\";\n        assertTrue(\"isNumber(String) 4 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 4 Neg failed\", !checkCreateNumber(val));\n        val = \"-123E\";\n        assertTrue(\"isNumber(String) 5 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 5 Neg failed\", !checkCreateNumber(val));\n        val = \"-123E+-212\";\n        assertTrue(\"isNumber(String) 6 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 6 Neg failed\", !checkCreateNumber(val));\n        val = \"-123E2.12\";\n        assertTrue(\"isNumber(String) 7 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 7 Neg failed\", !checkCreateNumber(val));\n        val = \"0xGF\";\n        assertTrue(\"isNumber(String) 8 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 8 Neg failed\", !checkCreateNumber(val));\n        val = \"0xFAE-1\";\n        assertTrue(\"isNumber(String) 9 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 9 Neg failed\", !checkCreateNumber(val));\n        val = \".\";\n        assertTrue(\"isNumber(String) 10 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 10 Neg failed\", !checkCreateNumber(val));\n        val = \"-0ABC123\";\n        assertTrue(\"isNumber(String) 11 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 11 Neg failed\", !checkCreateNumber(val));\n        val = \"123.4E-D\";\n        assertTrue(\"isNumber(String) 12 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 12 Neg failed\", !checkCreateNumber(val));\n        val = \"123.4ED\";\n        assertTrue(\"isNumber(String) 13 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 13 Neg failed\", !checkCreateNumber(val));\n        val = \"1234E5l\";\n        assertTrue(\"isNumber(String) 14 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 14 Neg failed\", !checkCreateNumber(val));\n        val = \"11a\";\n        assertTrue(\"isNumber(String) 15 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 15 Neg failed\", !checkCreateNumber(val)); \n        val = \"1a\";\n        assertTrue(\"isNumber(String) 16 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 16 Neg failed\", !checkCreateNumber(val)); \n        val = \"a\";\n        assertTrue(\"isNumber(String) 17 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 17 Neg failed\", !checkCreateNumber(val)); \n        val = \"11g\";\n        assertTrue(\"isNumber(String) 18 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 18 Neg failed\", !checkCreateNumber(val)); \n        val = \"11z\";\n        assertTrue(\"isNumber(String) 19 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 19 Neg failed\", !checkCreateNumber(val)); \n        val = \"11def\";\n        assertTrue(\"isNumber(String) 20 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 20 Neg failed\", !checkCreateNumber(val)); \n        val = \"11d11\";\n        assertTrue(\"isNumber(String) 21 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 21 Neg failed\", !checkCreateNumber(val)); \n        val = \"11 11\";\n        assertTrue(\"isNumber(String) 22 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 22 Neg failed\", !checkCreateNumber(val));\n        val = \" 1111\";\n        assertTrue(\"isNumber(String) 23 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 23 Neg failed\", !checkCreateNumber(val));\n        val = \"1111 \";\n        assertTrue(\"isNumber(String) 24 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 24 Neg failed\", !checkCreateNumber(val));\n\n        // LANG-521\n        val = \"2.\";\n        assertTrue(\"isNumber(String) LANG-521 failed\", NumberUtils.isNumber(val));\n    }\n"], "Closure_88": ["  public void testIssue297() {\n    args.add(\"--compilation_level=SIMPLE_OPTIMIZATIONS\");\n    test(\"function f(p) {\" +\n         \" var x;\" +\n         \" return ((x=p.id) && (x=parseInt(x.substr(1))) && x>0);\" +\n         \"}\",\n         \"function f(b) {\" +\n         \" var a;\" +\n         \" return ((a=b.id) && (a=parseInt(a.substr(1))) && a>0);\" +\n         \"}\");\n  }  \n", "  public void testIssue297a() {\n    testSame(\"function f(p) {\" +\n         \" var x;\" +\n         \" return ((x=p.id) && (x=parseInt(x.substr(1))) && x>0);\" +\n         \"}; f('');\");\n  }\n", "  public void testIssue297b() {\n    test(\"function f() {\" +\n         \" var x;\" +\n         \" return (x='') && (x = x.substr(1));\" +\n         \"};\",\n         \"function f() {\" +\n         \" var x;\" +\n         \" return (x='') && (x.substr(1));\" +\n         \"};\");\n  }\n", "  public void testIssue297c() {\n    test(\"function f() {\" +\n         \" var x;\" +\n         \" return (x=1) && (x = f(x));\" +\n         \"};\",\n         \"function f() {\" +\n         \" var x;\" +\n         \" return (x=1) && f(x);\" +\n         \"};\");\n  }\n", "  public void testIssue297d() {\n    test(\"function f(a) {\" +\n         \" return (a=1) && (a = f(a));\" +\n         \"};\",\n         \"function f(a) {\" +\n         \" return (a=1) && (f(a));\" +\n         \"};\");\n  }\n", "  public void testIssue297e() {\n    test(\"function f(a) {\" +\n         \" return (a=1) - (a = g(a));\" +\n         \"};\",\n         \"function f(a) {\" +\n         \" return (a=1) - (g(a));\" +\n         \"};\");\n  }\n", "  public void testIssue297f() {\n    test(\"function f(a) {\" +\n         \" h((a=1) - (a = g(a)));\" +\n         \"};\",\n         \"function f(a) {\" +\n         \" h((a=1) - (g(a)));\" +\n         \"};\");\n  }\n", "  public void testIssue297g() {\n    test(\"function f(a) {\" +\n         \" var b = h((b=1) - (b = g(b)));\" +\n         \" return b;\" +\n         \"};\",\n         // The last assignment in the initializer should be eliminated\n         \"function f(a) {\" +\n         \" var b = h((b=1) - (b = g(b)));\" +\n         \" return b;\" +\n         \"};\");\n  }\n", "  public void testIssue297h() {\n    test(\"function f(a) {\" +\n         \" var b = b=1;\" +\n         \" return b;\" +\n         \"};\",\n         // The assignment in the initializer should be eliminated\n         \"function f(a) {\" +\n         \" var b = b = 1;\" +\n         \" return b;\" +\n         \"};\");\n  }\n"], "Closure_106": ["  public void testJSDocComments() {\n    test(\"function A() { /** This is a jsdoc comment */ this.foo; }\", ok);\n    test(\"function A() { /* This is a normal comment */ this.foo; }\", e);\n  }\n", "  public void testCrashInCommaOperator() {\n    test(\"var a = {}; a.b = function() {},a.b();\",\n         \"var a$b; a$b=function() {},a$b();\");\n  }\n", "  public void testCrashInNestedAssign() {\n    test(\"var a = {}; if (a.b = function() {}) a.b();\",\n         \"var a$b; if (a$b=function() {}) { a$b(); }\");\n  }\n", "  public void testTwinReferenceCancelsChildCollapsing() {\n    test(\"var a = {}; if (a.b = function() {}) { a.b.c = 3; a.b(a.b.c); }\",\n         \"var a$b; if (a$b = function() {}) { a$b.c = 3; a$b(a$b.c); }\");\n  }\n"], "Closure_81": ["  public void testUnnamedFunctionStatement() {\n    // Statements\n    parseError(\"function() {};\", \"unnamed function statement\");\n    parseError(\"if (true) { function() {}; }\", \"unnamed function statement\");\n    parse(\"function f() {};\");\n    // Expressions\n    parse(\"(function f() {});\");\n    parse(\"(function () {});\");\n  }\n"], "Time_6": ["    public void test_plusYears_positiveToZero_crossCutover() {\n        LocalDate date = new LocalDate(2003, 6, 30, GJ_CHRONOLOGY);\n        LocalDate expected = new LocalDate(-1, 6, 30, GJ_CHRONOLOGY);\n        assertEquals(expected, date.plusYears(-2003));\n    }\n", "    public void test_plusYears_positiveToNegative_crossCutover() {\n        LocalDate date = new LocalDate(2003, 6, 30, GJ_CHRONOLOGY);\n        LocalDate expected = new LocalDate(-2, 6, 30, GJ_CHRONOLOGY);\n        assertEquals(expected, date.plusYears(-2004));\n    }\n", "    public void test_plusWeekyears_positiveToZero_crossCutover() {\n        LocalDate date = new LocalDate(2003, 6, 30, GJ_CHRONOLOGY);\n        LocalDate expected = new LocalDate(-1, 6, 30, GJ_CHRONOLOGY).withWeekOfWeekyear(date.getWeekOfWeekyear()).withDayOfWeek(date.getDayOfWeek());\n        assertEquals(expected, date.weekyear().addToCopy(-2003));\n    }\n", "    public void test_plusWeekyears_positiveToNegative_crossCutover() {\n        LocalDate date = new LocalDate(2003, 6, 30, GJ_CHRONOLOGY);\n        LocalDate expected = new LocalDate(-2, 6, 30, GJ_CHRONOLOGY).withWeekOfWeekyear(date.getWeekOfWeekyear()).withDayOfWeek(date.getDayOfWeek());\n        assertEquals(expected, date.weekyear().addToCopy(-2004));\n    }\n", "    public void test_cutoverPreZero() {\n        DateTime cutover = new LocalDate(-2, 6, 30, ISOChronology.getInstanceUTC()).toDateTimeAtStartOfDay(DateTimeZone.UTC);\n        try {\n            GJChronology.getInstance(DateTimeZone.UTC, cutover);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            // expected\n        }\n    }\n"], "Closure_75": ["  public void testIEString() {\n    testSame(\"!+'\\\\v1'\");\n  }\n"], "Closure_72": ["  public void testInlineFunctions31() {\n    // Don't introduce a duplicate label in the same scope\n    test(\"function foo(){ lab:{4;} }\" +\n        \"lab:{foo();}\",\n        \"lab:{{JSCompiler_inline_label_0:{4}}}\");\n  }\n"], "Time_1": ["    public void testConstructorEx7_TypeArray_intArray() throws Throwable {\n        int[] values = new int[] {1, 1, 1};\n        DateTimeFieldType[] types = new DateTimeFieldType[] {\n            DateTimeFieldType.dayOfMonth(), DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() };\n        try {\n            new Partial(types, values);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n        }\n        \n        types = new DateTimeFieldType[] {\n            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.monthOfYear() };\n        try {\n            new Partial(types, values);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n        }\n        \n        types = new DateTimeFieldType[] {\n            DateTimeFieldType.year(), DateTimeFieldType.era(), DateTimeFieldType.monthOfYear() };\n        try {\n            new Partial(types, values);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n        }\n        \n        types = new DateTimeFieldType[] {\n            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.era() };\n        try {\n            new Partial(types, values);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n        }\n        \n        types = new DateTimeFieldType[] {\n            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfYear() };\n        try {\n            new Partial(types, values);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n        }\n        \n        types = new DateTimeFieldType[] {\n            DateTimeFieldType.yearOfEra(), DateTimeFieldType.year(), DateTimeFieldType.dayOfYear() };\n        try {\n            new Partial(types, values);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n        }\n    }\n"], "Lang_38": ["    public void testLang538() {\n        final String dateTime = \"2009-10-16T16:42:16.000Z\";\n\n        // more commonly constructed with: cal = new GregorianCalendar(2009, 9, 16, 8, 42, 16)\n        // for the unit test to work in any time zone, constructing with GMT-8 rather than default locale time zone\n        GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(\"GMT-8\"));\n        cal.clear();\n        cal.set(2009, 9, 16, 8, 42, 16);\n\n        FastDateFormat format = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\", TimeZone.getTimeZone(\"GMT\"));\n        assertEquals(\"dateTime\", dateTime, format.format(cal));\n    }\n"], "Closure_101": ["  public void testProcessClosurePrimitives() {\n    test(\"var goog = {}; goog.provide('goog.dom');\",\n         \"var goog = {}; goog.dom = {};\");\n    args.add(\"--process_closure_primitives=false\");\n    testSame(\"var goog = {}; goog.provide('goog.dom');\");\n  }\n"], "Closure_86": ["  public void testLocalValue1() throws Exception {\n    // Names are not known to be local.\n    assertFalse(testLocalValue(\"x\"));\n    assertFalse(testLocalValue(\"x()\"));\n    assertFalse(testLocalValue(\"this\"));\n    assertFalse(testLocalValue(\"arguments\"));\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    assertFalse(testLocalValue(\"new x()\"));\n\n    // property references are assume to be non-local\n    assertFalse(testLocalValue(\"(new x()).y\"));\n    assertFalse(testLocalValue(\"(new x())['y']\"));\n\n    // Primitive values are local\n    assertTrue(testLocalValue(\"null\"));\n    assertTrue(testLocalValue(\"undefined\"));\n    assertTrue(testLocalValue(\"Infinity\"));\n    assertTrue(testLocalValue(\"NaN\"));\n    assertTrue(testLocalValue(\"1\"));\n    assertTrue(testLocalValue(\"'a'\"));\n    assertTrue(testLocalValue(\"true\"));\n    assertTrue(testLocalValue(\"false\"));\n    assertTrue(testLocalValue(\"[]\"));\n    assertTrue(testLocalValue(\"{}\"));\n\n    // The contents of arrays and objects don't matter\n    assertTrue(testLocalValue(\"[x]\"));\n    assertTrue(testLocalValue(\"{'a':x}\"));\n\n    // Pre-increment results in primitive number\n    assertTrue(testLocalValue(\"++x\"));\n    assertTrue(testLocalValue(\"--x\"));\n\n    // Post-increment, the previous value matters.\n    assertFalse(testLocalValue(\"x++\"));\n    assertFalse(testLocalValue(\"x--\"));\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    assertTrue(testLocalValue(\"x=1\"));\n    assertFalse(testLocalValue(\"x=[]\"));\n    assertFalse(testLocalValue(\"x=y\"));\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    assertTrue(testLocalValue(\"x+=y\"));\n    assertTrue(testLocalValue(\"x*=y\"));\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    assertTrue(testLocalValue(\"x==y\"));\n    assertTrue(testLocalValue(\"x!=y\"));\n    assertTrue(testLocalValue(\"x>y\"));\n    // Only the right side of a comma matters\n    assertTrue(testLocalValue(\"(1,2)\"));\n    assertTrue(testLocalValue(\"(x,1)\"));\n    assertFalse(testLocalValue(\"(x,y)\"));\n\n    // Both the operands of OR matter\n    assertTrue(testLocalValue(\"1||2\"));\n    assertFalse(testLocalValue(\"x||1\"));\n    assertFalse(testLocalValue(\"x||y\"));\n    assertFalse(testLocalValue(\"1||y\"));\n\n    // Both the operands of AND matter\n    assertTrue(testLocalValue(\"1&&2\"));\n    assertFalse(testLocalValue(\"x&&1\"));\n    assertFalse(testLocalValue(\"x&&y\"));\n    assertFalse(testLocalValue(\"1&&y\"));\n\n    // Only the results of HOOK matter\n    assertTrue(testLocalValue(\"x?1:2\"));\n    assertFalse(testLocalValue(\"x?x:2\"));\n    assertFalse(testLocalValue(\"x?1:x\"));\n    assertFalse(testLocalValue(\"x?x:y\"));\n\n    // Results of ops are local values\n    assertTrue(testLocalValue(\"!y\"));\n    assertTrue(testLocalValue(\"~y\"));\n    assertTrue(testLocalValue(\"y + 1\"));\n    assertTrue(testLocalValue(\"y + z\"));\n    assertTrue(testLocalValue(\"y * z\"));\n\n    assertTrue(testLocalValue(\"'a' in x\"));\n    assertTrue(testLocalValue(\"typeof x\"));\n    assertTrue(testLocalValue(\"x instanceof y\"));\n\n    assertTrue(testLocalValue(\"void x\"));\n    assertTrue(testLocalValue(\"void 0\"));\n\n    assertFalse(testLocalValue(\"{}.x\"));\n\n    assertTrue(testLocalValue(\"{}.toString()\"));\n    assertTrue(testLocalValue(\"o.toString()\"));\n\n    assertFalse(testLocalValue(\"o.valueOf()\"));\n  }\n", "  public void testIssue303() throws Exception {\n    checkMarkedCalls(\n        \"/** @constructor */ function F() {\" +\n        \"  var self = this;\" +\n        \"  window.setTimeout(function() {\" +\n        \"    window.location = self.location;\" +\n        \"  }, 0);\" +\n        \"}\" +\n        \"F.prototype.setLocation = function(x) {\" +\n        \"  this.location = x;\" +\n        \"};\" +\n        \"(new F()).setLocation('http://www.google.com/');\",\n        ImmutableList.<String>of());\n  }\n", "  public void testIssue303b() throws Exception {\n    checkMarkedCalls(\n        \"/** @constructor */ function F() {\" +\n        \"  var self = this;\" +\n        \"  window.setTimeout(function() {\" +\n        \"    window.location = self.location;\" +\n        \"  }, 0);\" +\n        \"}\" +\n        \"F.prototype.setLocation = function(x) {\" +\n        \"  this.location = x;\" +\n        \"};\" +\n        \"function x() {\" +\n        \"  (new F()).setLocation('http://www.google.com/');\" +\n        \"} window['x'] = x;\",\n        ImmutableList.<String>of());\n  }\n", "  public void testAnnotationInExterns_new4() throws Exception {\n    // The entire expression containing \"externObjSEThisMethod\" is considered\n    // side-effect free in this context.\n\n    checkMarkedCalls(\"new externObjSEThis().externObjSEThisMethod('')\",\n        BROKEN_NEW ?\n            ImmutableList.<String>of(\n               \"externObjSEThis\") :\n            ImmutableList.<String>of(\n               \"externObjSEThis\", \"NEW STRING externObjSEThisMethod\"));\n  }\n", "  public void testAnnotationInExterns_new6() throws Exception {\n    // While \"externObjSEThisMethod\" has modifies \"this\"\n    // it does not have global side-effects with \"this\" is\n    // a known local value.\n    checkMarkedCalls(\n        \"function f() {\" +\n        \"  new externObjSEThis().externObjSEThisMethod('') \" +\n        \"};\" +\n        \"f();\",\n        BROKEN_NEW ?\n            ImmutableList.<String>of(\n                \"externObjSEThis\") :\n           ImmutableList.<String>of(\n               \"externObjSEThis\", \"NEW STRING externObjSEThisMethod\", \"f\"));\n  }\n", "  public void testLocalizedSideEffects8() throws Exception {\n    // Returning a local object that has been modified\n    // is not a global side-effect.\n    checkMarkedCalls(\"/** @constructor A */ function A() {};\" +\n                     \"function f() {\" +\n                     \"  var a = new A; a.foo = 1; return a;\" +\n                     \"}\" +\n                     \"f()\",\n                     BROKEN_NEW ?\n                         ImmutableList.<String>of(\"A\") :\n                         ImmutableList.<String>of(\"A\", \"f\"));\n  }\n", "  public void testLocalizedSideEffects9() throws Exception {\n    // Returning a local object that has been modified\n    // is not a global side-effect.\n    checkMarkedCalls(\"/** @constructor A */ function A() {this.x = 1};\" +\n                     \"function f() {\" +\n                     \"  var a = new A; a.foo = 1; return a;\" +\n                     \"}\" +\n                     \"f()\",\n                     BROKEN_NEW ?\n                         ImmutableList.<String>of(\"A\") :\n                         ImmutableList.<String>of(\"A\", \"f\"));\n  }\n"], "Closure_19": ["  public void testNoThisInference() {\n    JSType thisType = createNullableType(OBJECT_TYPE);\n    assumingThisType(thisType);\n    inFunction(\"var out = 3; if (goog.isNull(this)) out = this;\");\n    verify(\"out\", createUnionType(OBJECT_TYPE, NUMBER_TYPE));\n  }\n"], "Lang_53": ["    public void testRoundLang346() throws Exception\n    {\n        TimeZone.setDefault(defaultZone);\n        dateTimeParser.setTimeZone(defaultZone);\n        Calendar testCalendar = Calendar.getInstance();\n        testCalendar.set(2007, 6, 2, 8, 8, 50);\n        Date date = testCalendar.getTime();\n        assertEquals(\"Minute Round Up Failed\",\n                     dateTimeParser.parse(\"July 2, 2007 08:09:00.000\"),\n                     DateUtils.round(date, Calendar.MINUTE));\n\n        testCalendar.set(2007, 6, 2, 8, 8, 20);\n        date = testCalendar.getTime();\n        assertEquals(\"Minute No Round Failed\",\n                     dateTimeParser.parse(\"July 2, 2007 08:08:00.000\"),\n                     DateUtils.round(date, Calendar.MINUTE));\n\n        testCalendar.set(2007, 6, 2, 8, 8, 50);\n        testCalendar.set(Calendar.MILLISECOND, 600);\n        date = testCalendar.getTime();\n\n        assertEquals(\"Second Round Up with 600 Milli Seconds Failed\",\n                     dateTimeParser.parse(\"July 2, 2007 08:08:51.000\"),\n                     DateUtils.round(date, Calendar.SECOND));\n\n        testCalendar.set(2007, 6, 2, 8, 8, 50);\n        testCalendar.set(Calendar.MILLISECOND, 200);\n        date = testCalendar.getTime();\n        assertEquals(\"Second Round Down with 200 Milli Seconds Failed\",\n                     dateTimeParser.parse(\"July 2, 2007 08:08:50.000\"),\n                     DateUtils.round(date, Calendar.SECOND));\n\n        testCalendar.set(2007, 6, 2, 8, 8, 20);\n        testCalendar.set(Calendar.MILLISECOND, 600);\n        date = testCalendar.getTime();\n        assertEquals(\"Second Round Up with 200 Milli Seconds Failed\",\n                     dateTimeParser.parse(\"July 2, 2007 08:08:21.000\"),\n                     DateUtils.round(date, Calendar.SECOND));\n\n        testCalendar.set(2007, 6, 2, 8, 8, 20);\n        testCalendar.set(Calendar.MILLISECOND, 200);\n        date = testCalendar.getTime();\n        assertEquals(\"Second Round Down with 200 Milli Seconds Failed\",\n                     dateTimeParser.parse(\"July 2, 2007 08:08:20.000\"),\n                     DateUtils.round(date, Calendar.SECOND));\n\n        testCalendar.set(2007, 6, 2, 8, 8, 50);\n        date = testCalendar.getTime();\n        assertEquals(\"Hour Round Down Failed\",\n                     dateTimeParser.parse(\"July 2, 2007 08:00:00.000\"),\n                     DateUtils.round(date, Calendar.HOUR));\n\n        testCalendar.set(2007, 6, 2, 8, 31, 50);\n        date = testCalendar.getTime();\n        assertEquals(\"Hour Round Up Failed\",\n                     dateTimeParser.parse(\"July 2, 2007 09:00:00.000\"),\n                     DateUtils.round(date, Calendar.HOUR));\n    }\n"], "Closure_26": ["  public void testProcessCJS() {\n    args.add(\"--process_common_js_modules\");\n    args.add(\"--common_js_entry_module=foo/bar\");\n    setFilename(0, \"foo/bar.js\");\n    test(\"exports.test = 1\",\n        \"var module$foo$bar={test:1};\");\n  }\n", "  public void testTransformAMDAndProcessCJS() {\n    args.add(\"--transform_amd_modules\");\n    args.add(\"--process_common_js_modules\");\n    args.add(\"--common_js_entry_module=foo/bar\");\n    setFilename(0, \"foo/bar.js\");\n    test(\"define({foo: 1})\",\n        \"var module$foo$bar={}, module$foo$bar={foo:1};\");\n  }\n", "  public void testWithoutExports() {\n    setFilename(\"test\");\n    test(\n        \"var name = require('name');\" +\n        \"name()\",\n        \"goog.provide('module$test');\" +\n        \"var module$test = {};\" +\n        \"goog.require('module$name');\" +\n        \"var name$$module$test = module$name;\" +\n        \"name$$module$test();\");\n    setFilename(\"test/sub\");\n    test(\n        \"var name = require('mod/name');\" +\n        \"(function() { name(); })();\",\n        \"goog.provide('module$test$sub');\" +\n        \"var module$test$sub = {};\" +\n        \"goog.require('module$mod$name');\" +\n        \"var name$$module$test$sub = module$mod$name;\" +\n        \"(function() { name$$module$test$sub(); })();\");\n  }\n", "  public void testExports() {\n    setFilename(\"test\");\n    test(\n        \"var name = require('name');\" +\n        \"exports.foo = 1;\",\n        \"goog.provide('module$test');\" +\n        \"var module$test = {};\" +\n        \"goog.require('module$name');\" +\n        \"var name$$module$test = module$name;\" +\n        \"module$test.foo = 1;\");\n    test(\n        \"var name = require('name');\" +\n        \"module.exports = function() {};\",\n        \"goog.provide('module$test');\" +\n        \"var module$test = {};\" +\n        \"goog.require('module$name');\" +\n        \"var name$$module$test = module$name;\" +\n        \"module$test.module$exports = function() {};\" +\n        \"if(module$test.module$exports)\" +\n        \"module$test=module$test.module$exports\");\n  }\n", "  public void testVarRenaming() {\n    setFilename(\"test\");\n    test(\n        \"var a = 1, b = 2;\" +\n        \"(function() { var a; b = 4})()\",\n        \"goog.provide('module$test');\" +\n        \"var module$test = {};\" +\n        \"var a$$module$test = 1, b$$module$test = 2;\" +\n        \"(function() { var a; b$$module$test = 4})();\");\n  }\n", "  public void testDash() {\n    setFilename(\"test-test\");\n    test(\n        \"var name = require('name'); exports.foo = 1;\",\n        \"goog.provide('module$test_test');\" +\n        \"var module$test_test = {};\" +\n        \"goog.require('module$name');\" +\n        \"var name$$module$test_test = module$name;\" +\n        \"module$test_test.foo = 1;\");\n  }\n", "  public void testModuleName() {\n    assertEquals(\"module$foo$baz\",\n        ProcessCommonJSModules.toModuleName(\"./baz.js\", \"foo/bar.js\"));\n    assertEquals(\"module$foo$baz_bar\",\n        ProcessCommonJSModules.toModuleName(\"./baz-bar.js\", \"foo/bar.js\"));\n    assertEquals(\"module$baz\",\n        ProcessCommonJSModules.toModuleName(\"../baz.js\", \"foo/bar.js\"));\n    assertEquals(\"module$baz\",\n        ProcessCommonJSModules.toModuleName(\"../../baz.js\", \"foo/bar/abc.js\"));\n    assertEquals(\"module$baz\", ProcessCommonJSModules.toModuleName(\n        \"../../../baz.js\", \"foo/bar/abc/xyz.js\"));\n    setFilename(\"foo/bar\");\n    test(\n        \"var name = require('name');\",\n        \"goog.provide('module$foo$bar'); var module$foo$bar = {};\" +\n        \"goog.require('module$name');\" +\n        \"var name$$module$foo$bar = module$name;\");\n    test(\n        \"var name = require('./name');\",\n        \"goog.provide('module$foo$bar');\" +\n        \"var module$foo$bar = {};\" +\n        \"goog.require('module$foo$name');\" +\n        \"var name$$module$foo$bar = module$foo$name;\");\n\n  }\n"], "Lang_54": ["    public void testLang328() {\n        assertValidToLocale(\"fr__POSIX\", \"fr\", \"\", \"POSIX\");\n    }\n"], "Closure_21": ["  public void testUselessCode() {\n    test(\"function f(x) { if(x) return; }\", ok);\n    test(\"function f(x) { if(x); }\", \"function f(x) { if(x); }\", e);\n\n    test(\"if(x) x = y;\", ok);\n    test(\"if(x) x == bar();\", \"if(x) JSCOMPILER_PRESERVE(x == bar());\", e);\n\n    test(\"x = 3;\", ok);\n    test(\"x == 3;\", \"JSCOMPILER_PRESERVE(x == 3);\", e);\n\n    test(\"var x = 'test'\", ok);\n    test(\"var x = 'test'\\n'str'\",\n         \"var x = 'test'\\nJSCOMPILER_PRESERVE('str')\", e);\n\n    test(\"\", ok);\n    test(\"foo();;;;bar();;;;\", ok);\n\n    test(\"var a, b; a = 5, b = 6\", ok);\n    test(\"var a, b; a = 5, b == 6\",\n         \"var a, b; a = 5, JSCOMPILER_PRESERVE(b == 6)\", e);\n    test(\"var a, b; a = (5, 6)\",\n         \"var a, b; a = (JSCOMPILER_PRESERVE(5), 6)\", e);\n    test(\"var a, b; a = (bar(), 6, 7)\",\n         \"var a, b; a = (bar(), JSCOMPILER_PRESERVE(6), 7)\", e);\n    test(\"var a, b; a = (bar(), bar(), 7, 8)\",\n         \"var a, b; a = (bar(), bar(), JSCOMPILER_PRESERVE(7), 8)\", e);\n    test(\"var a, b; a = (b = 7, 6)\", ok);\n    test(\"function x(){}\\nfunction f(a, b){}\\nf(1,(x(), 2));\", ok);\n    test(\"function x(){}\\nfunction f(a, b){}\\nf(1,(2, 3));\",\n         \"function x(){}\\nfunction f(a, b){}\\n\" +\n         \"f(1,(JSCOMPILER_PRESERVE(2), 3));\", e);\n  }\n", "  public void testUselessCodeInFor() {\n    test(\"for(var x = 0; x < 100; x++) { foo(x) }\", ok);\n    test(\"for(; true; ) { bar() }\", ok);\n    test(\"for(foo(); true; foo()) { bar() }\", ok);\n    test(\"for(void 0; true; foo()) { bar() }\",\n         \"for(JSCOMPILER_PRESERVE(void 0); true; foo()) { bar() }\", e);\n    test(\"for(foo(); true; void 0) { bar() }\",\n         \"for(foo(); true; JSCOMPILER_PRESERVE(void 0)) { bar() }\", e);\n    test(\"for(foo(); true; (1, bar())) { bar() }\",\n         \"for(foo(); true; (JSCOMPILER_PRESERVE(1), bar())) { bar() }\", e);\n\n    test(\"for(foo in bar) { foo() }\", ok);\n    test(\"for (i = 0; el = el.previousSibling; i++) {}\", ok);\n    test(\"for (i = 0; el = el.previousSibling; i++);\", ok);\n  }\n"], "Chart_24": ["    public void testGetPaint() {\n        GrayPaintScale gps = new GrayPaintScale();\n        Color c = (Color) gps.getPaint(0.0);\n        assertTrue(c.equals(Color.black));\n        c = (Color) gps.getPaint(1.0);\n        assertTrue(c.equals(Color.white));\n        \n        // check lookup values that are outside the bounds - see bug report\n        // 1767315\n        c = (Color) gps.getPaint(-0.5);\n        assertTrue(c.equals(Color.black));\n        c = (Color) gps.getPaint(1.5);\n        assertTrue(c.equals(Color.white));\n    }\n"], "Lang_5": ["    @Test\n    public void testLang865() {\n        assertValidToLocale(\"_GB\", \"\", \"GB\", \"\");\n        assertValidToLocale(\"_GB_P\", \"\", \"GB\", \"P\");\n        assertValidToLocale(\"_GB_POSIX\", \"\", \"GB\", \"POSIX\");\n        try {\n            LocaleUtils.toLocale(\"_G\");\n            fail(\"Must be at least 3 chars if starts with underscore\");\n        } catch (final IllegalArgumentException iae) {\n        }\n        try {\n            LocaleUtils.toLocale(\"_Gb\");\n            fail(\"Must be uppercase if starts with underscore\");\n        } catch (final IllegalArgumentException iae) {\n        }\n        try {\n            LocaleUtils.toLocale(\"_gB\");\n            fail(\"Must be uppercase if starts with underscore\");\n        } catch (final IllegalArgumentException iae) {\n        }\n        try {\n            LocaleUtils.toLocale(\"_1B\");\n            fail(\"Must be letter if starts with underscore\");\n        } catch (final IllegalArgumentException iae) {\n        }\n        try {\n            LocaleUtils.toLocale(\"_G1\");\n            fail(\"Must be letter if starts with underscore\");\n        } catch (final IllegalArgumentException iae) {\n        }\n        try {\n            LocaleUtils.toLocale(\"_GB_\");\n            fail(\"Must be at least 5 chars if starts with underscore\");\n        } catch (final IllegalArgumentException iae) {\n        }\n        try {\n            LocaleUtils.toLocale(\"_GBAP\");\n            fail(\"Must have underscore after the country if starts with underscore and is at least 5 chars\");\n        } catch (final IllegalArgumentException iae) {\n        }\n    }\n"], "Lang_62": ["    public void testNumberOverflow() throws Exception {\n        doTestUnescapeEntity(\"&#12345678;\", \"&#12345678;\");\n        doTestUnescapeEntity(\"x&#12345678;y\", \"x&#12345678;y\");\n        doTestUnescapeEntity(\"&#x12345678;\", \"&#x12345678;\");\n        doTestUnescapeEntity(\"x&#x12345678;y\", \"x&#x12345678;y\");\n    }\n"], "Closure_17": ["  public void testIssue688() throws Exception {\n    testTypes(\n        \"/** @const */ var SOME_DEFAULT =\\n\" +\n        \"    /** @type {TwoNumbers} */ ({first: 1, second: 2});\\n\" +\n        \"/**\\n\" +\n        \"* Class defining an interface with two numbers.\\n\" +\n        \"* @interface\\n\" +\n        \"*/\\n\" +\n        \"function TwoNumbers() {}\\n\" +\n        \"/** @type number */\\n\" +\n        \"TwoNumbers.prototype.first;\\n\" +\n        \"/** @type number */\\n\" +\n        \"TwoNumbers.prototype.second;\\n\" +\n        \"/** @return {number} */ function f() { return SOME_DEFAULT; }\",\n        \"inconsistent return type\\n\" +\n        \"found   : (TwoNumbers|null)\\n\" +\n        \"required: number\");\n  }\n"], "Chart_12": ["    public void testConstructor() {\n    \tMultiplePiePlot plot = new MultiplePiePlot();\n    \tassertNull(plot.getDataset());\n\n    \t// the following checks that the plot registers itself as a listener\n    \t// with the dataset passed to the constructor - see patch 1943021\n    \tDefaultCategoryDataset dataset = new DefaultCategoryDataset();\n    \tplot = new MultiplePiePlot(dataset);\n    \tassertTrue(dataset.hasListener(plot));\n    }\n"], "Lang_65": ["    public void testTruncateLang59() throws Exception {\n\n        // Set TimeZone to Mountain Time\n        TimeZone MST_MDT = TimeZone.getTimeZone(\"MST7MDT\");\n        TimeZone.setDefault(MST_MDT);\n        DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS z\");\n        format.setTimeZone(MST_MDT);\n\n        Date oct31_01MDT = new Date(1099206000000L); \n\n        Date oct31MDT             = new Date(oct31_01MDT.getTime()       - 3600000L); // - 1 hour\n        Date oct31_01_02MDT       = new Date(oct31_01MDT.getTime()       + 120000L);  // + 2 minutes\n        Date oct31_01_02_03MDT    = new Date(oct31_01_02MDT.getTime()    + 3000L);    // + 3 seconds\n        Date oct31_01_02_03_04MDT = new Date(oct31_01_02_03MDT.getTime() + 4L);       // + 4 milliseconds\n\n        assertEquals(\"Check 00:00:00.000\", \"2004-10-31 00:00:00.000 MDT\", format.format(oct31MDT));\n        assertEquals(\"Check 01:00:00.000\", \"2004-10-31 01:00:00.000 MDT\", format.format(oct31_01MDT));\n        assertEquals(\"Check 01:02:00.000\", \"2004-10-31 01:02:00.000 MDT\", format.format(oct31_01_02MDT));\n        assertEquals(\"Check 01:02:03.000\", \"2004-10-31 01:02:03.000 MDT\", format.format(oct31_01_02_03MDT));\n        assertEquals(\"Check 01:02:03.004\", \"2004-10-31 01:02:03.004 MDT\", format.format(oct31_01_02_03_04MDT));\n\n        // ------- Demonstrate Problem -------\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(new Date(oct31_01MDT.getTime()));\n        gval.set(Calendar.MINUTE, gval.get(Calendar.MINUTE)); // set minutes to the same value\n        assertEquals(\"Demonstrate Problem\", gval.getTime().getTime(), oct31_01MDT.getTime() + 3600000L);\n\n        // ---------- Test Truncate ----------\n        assertEquals(\"Truncate Calendar.MILLISECOND\",\n                oct31_01_02_03_04MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.MILLISECOND));\n\n        assertEquals(\"Truncate Calendar.SECOND\",\n                   oct31_01_02_03MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.SECOND));\n\n        assertEquals(\"Truncate Calendar.MINUTE\",\n                      oct31_01_02MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.MINUTE));\n\n        assertEquals(\"Truncate Calendar.HOUR_OF_DAY\",\n                         oct31_01MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.HOUR_OF_DAY));\n\n        assertEquals(\"Truncate Calendar.HOUR\",\n                         oct31_01MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.HOUR));\n\n        assertEquals(\"Truncate Calendar.DATE\",\n                            oct31MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.DATE));\n\n\n        // ---------- Test Round (down) ----------\n        assertEquals(\"Round Calendar.MILLISECOND\",\n                oct31_01_02_03_04MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.MILLISECOND));\n\n        assertEquals(\"Round Calendar.SECOND\",\n                   oct31_01_02_03MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.SECOND));\n\n        assertEquals(\"Round Calendar.MINUTE\",\n                      oct31_01_02MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.MINUTE));\n\n        assertEquals(\"Round Calendar.HOUR_OF_DAY\",\n                         oct31_01MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.HOUR_OF_DAY));\n\n        assertEquals(\"Round Calendar.HOUR\",\n                         oct31_01MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.HOUR));\n\n        assertEquals(\"Round Calendar.DATE\",\n                            oct31MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.DATE));\n\n        // restore default time zone\n        TimeZone.setDefault(defaultZone);\n    }\n"], "Chart_15": ["    public void testDrawWithNullDataset() {\n        JFreeChart chart = ChartFactory.createPieChart3D(\"Test\", null, true, \n                false, false);\n        boolean success = false;\n        try {\n            BufferedImage image = new BufferedImage(200 , 100, \n                    BufferedImage.TYPE_INT_RGB);\n            Graphics2D g2 = image.createGraphics();\n            chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, null);\n            g2.dispose();\n            success = true;\n        }\n        catch (Exception e) {\n            success = false;\n        }\n        assertTrue(success);\n    }\n"], "Closure_10": ["  public void testIssue821() {\n    foldSame(\"var a =(Math.random()>0.5? '1' : 2 ) + 3 + 4;\");\n    foldSame(\"var a = ((Math.random() ? 0 : 1) ||\" +\n             \"(Math.random()>0.5? '1' : 2 )) + 3 + 4;\");\n  }\n"], "Closure_87": ["  public void testIssue291() {\n    fold(\"if (true) { f.onchange(); }\", \"if (1) f.onchange();\");\n    foldSame(\"if (f) { f.onchange(); }\");\n    foldSame(\"if (f) { f.bar(); } else { f.onchange(); }\");\n    fold(\"if (f) { f.bonchange(); }\", \"f && f.bonchange();\");\n    foldSame(\"if (f) { f['x'](); }\");\n  }\n"], "Lang_39": ["    public void testReplace_StringStringArrayStringArray() {\n\n        \n        //JAVADOC TESTS START\n        assertNull(StringUtils.replaceEach(null, new String[]{\"a\"}, new String[]{\"b\"}));\n        assertEquals(StringUtils.replaceEach(\"\", new String[]{\"a\"}, new String[]{\"b\"}),\"\");\n        assertEquals(StringUtils.replaceEach(\"aba\", null, null),\"aba\");\n        assertEquals(StringUtils.replaceEach(\"aba\", new String[0], null),\"aba\");\n        assertEquals(StringUtils.replaceEach(\"aba\", null, new String[0]),\"aba\");\n        assertEquals(StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null),\"aba\");\n\n        assertEquals(StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}),\"b\");\n        assertEquals(StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}),\"aba\");\n        assertEquals(StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}),\"wcte\");\n        assertEquals(StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}),\"dcte\");\n        //JAVADOC TESTS END\n\n        assertEquals(\"bcc\", StringUtils.replaceEach(\"abc\", new String[]{\"a\", \"b\"}, new String[]{\"b\", \"c\"}));\n        assertEquals(\"q651.506bera\", StringUtils.replaceEach(\"d216.102oren\",\n            new String[]{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \n                \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"A\", \"B\", \"C\", \"D\", \n                \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \n                \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"},\n            new String[]{\"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"a\", \n                \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"N\", \"O\", \"P\", \"Q\", \n                \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \n                \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"5\", \"6\", \"7\", \"8\", \"9\", \"1\", \"2\", \"3\", \"4\"}));\n\n        // Test null safety inside arrays - LANG-552\n        assertEquals(StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{null}),\"aba\");\n        assertEquals(StringUtils.replaceEach(\"aba\", new String[]{\"a\", \"b\"}, new String[]{\"c\", null}),\"cbc\");\n    }\n", "    public void testReplace_StringStringArrayStringArrayBoolean() {\n        //JAVADOC TESTS START\n        assertNull(StringUtils.replaceEachRepeatedly(null, new String[]{\"a\"}, new String[]{\"b\"}));\n        assertEquals(StringUtils.replaceEachRepeatedly(\"\", new String[]{\"a\"}, new String[]{\"b\"}),\"\");\n        assertEquals(StringUtils.replaceEachRepeatedly(\"aba\", null, null),\"aba\");\n        assertEquals(StringUtils.replaceEachRepeatedly(\"aba\", new String[0], null),\"aba\");\n        assertEquals(StringUtils.replaceEachRepeatedly(\"aba\", null, new String[0]),\"aba\");\n        assertEquals(StringUtils.replaceEachRepeatedly(\"aba\", new String[0], null),\"aba\");\n\n        assertEquals(StringUtils.replaceEachRepeatedly(\"aba\", new String[]{\"a\"}, new String[]{\"\"}),\"b\");\n        assertEquals(StringUtils.replaceEachRepeatedly(\"aba\", new String[]{null}, new String[]{\"a\"}),\"aba\");\n        assertEquals(StringUtils.replaceEachRepeatedly(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}),\"wcte\");\n        assertEquals(StringUtils.replaceEachRepeatedly(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}),\"tcte\");\n\n        try {\n            StringUtils.replaceEachRepeatedly(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"});\n            fail(\"Should be a circular reference\");\n        } catch (IllegalStateException e) {}\n\n        //JAVADOC TESTS END\n\n    }\n"], "Closure_100": ["  public void testGlobalThis7() {\n    testFailure(\"var a = this.foo;\");\n  }\n", "  public void testStaticFunction6() {\n    testSame(\"function a() { return function() { this = 8; } }\");\n  }\n", "  public void testStaticFunction7() {\n    testSame(\"var a = function() { return function() { this = 8; } }\");\n  }\n", "  public void testStaticFunction8() {\n    testFailure(\"var a = function() { return this.foo; };\");\n  }\n", "  public void testStaticMethod2() {\n    testSame(\"a.b = function() { return function() { this.m2 = 5; } }\");\n  }\n", "  public void testStaticMethod3() {\n    testSame(\"a.b.c = function() { return function() { this.m2 = 5; } }\");\n  }\n", "  public void testInnerFunction1() {\n    testFailure(\"function f() { function g() { return this.x; } }\");\n  }\n", "  public void testInnerFunction2() {\n    testFailure(\"function f() { var g = function() { return this.x; } }\");\n  }\n", "  public void testInnerFunction3() {\n    testFailure(\n        \"function f() { var x = {}; x.y = function() { return this.x; } }\");\n  }\n"], "Closure_73": ["  public void testUnicode() {\n    assertPrint(\"var x ='\\\\x0f';\", \"var x=\\\"\\\\u000f\\\"\");\n    assertPrint(\"var x ='\\\\x68';\", \"var x=\\\"h\\\"\");\n    assertPrint(\"var x ='\\\\x7f';\", \"var x=\\\"\\\\u007f\\\"\");\n  }\n"], "Closure_74": ["  public void testFoldComparison3() {\n    fold(\"x = !1 == !0\", \"x = false\");\n\n    fold(\"x = !0 == !0\", \"x = true\");\n    fold(\"x = !1 == !1\", \"x = true\");\n    fold(\"x = !1 == null\", \"x = false\");\n    fold(\"x = !1 == !0\", \"x = false\");\n    fold(\"x = !0 == null\", \"x = false\");\n\n    fold(\"!0 == !0\", \"true\");\n    fold(\"!1 == null\", \"false\");\n    fold(\"!1 == !0\", \"false\");\n    fold(\"!0 == null\", \"false\");\n\n    fold(\"x = !0 === !0\", \"x = true\");\n    fold(\"x = !1 === !1\", \"x = true\");\n    fold(\"x = !1 === null\", \"x = false\");\n    fold(\"x = !1 === !0\", \"x = false\");\n    fold(\"x = !0 === null\", \"x = false\");\n\n    fold(\"!0 === !0\", \"true\");\n    fold(\"!1 === null\", \"false\");\n    fold(\"!1 === !0\", \"false\");\n    fold(\"!0 === null\", \"false\");\n  }\n", "  public void testInvertibleOperators() {\n    Map<String, String> inverses = ImmutableMap.<String, String>builder()\n        .put(\"==\", \"!=\")\n        .put(\"===\", \"!==\")\n        .put(\"<=\", \">\")\n        .put(\"<\", \">=\")\n        .put(\">=\", \"<\")\n        .put(\">\", \"<=\")\n        .put(\"!=\", \"==\")\n        .put(\"!==\", \"===\")\n        .build();\n    Set<String> comparators = ImmutableSet.of(\"<=\", \"<\", \">=\", \">\");\n    Set<String> equalitors = ImmutableSet.of(\"==\", \"===\");\n    Set<String> uncomparables = ImmutableSet.of(\"undefined\", \"void 0\");\n    List<String> operators = ImmutableList.copyOf(inverses.values());\n    for (int iOperandA = 0; iOperandA < LITERAL_OPERANDS.size(); iOperandA++) {\n      for (int iOperandB = 0;\n           iOperandB < LITERAL_OPERANDS.size();\n           iOperandB++) {\n        for (int iOp = 0; iOp < operators.size(); iOp++) {\n          String a = LITERAL_OPERANDS.get(iOperandA);\n          String b = LITERAL_OPERANDS.get(iOperandB);\n          String op = operators.get(iOp);\n          String inverse = inverses.get(op);\n\n          // Test invertability.\n          if (comparators.contains(op) &&\n              (uncomparables.contains(a) || uncomparables.contains(b))) {\n            assertSameResults(join(a, op, b), \"false\");\n            assertSameResults(join(a, inverse, b), \"false\");\n          } else if (a.equals(b) && equalitors.contains(op)) {\n            if (a.equals(\"NaN\") || a.equals(\"Infinity\")) {\n              foldSame(join(a, op, b));\n              foldSame(join(a, inverse, b));\n            } else {\n              assertSameResults(join(a, op, b), \"true\");\n              assertSameResults(join(a, inverse, b), \"false\");\n            }\n          } else {\n            assertNotSameResults(join(a, op, b), join(a, inverse, b));\n          }\n        }\n      }\n    }\n  }\n", "  public void testCommutativeOperators() {\n    List<String> operators =\n        ImmutableList.of(\n            \"==\",\n            \"!=\",\n            \"===\",\n            \"!==\",\n            \"*\",\n            \"|\",\n            \"&\",\n            \"^\");\n    for (int iOperandA = 0; iOperandA < LITERAL_OPERANDS.size(); iOperandA++) {\n      for (int iOperandB = iOperandA;\n           iOperandB < LITERAL_OPERANDS.size();\n           iOperandB++) {\n        for (int iOp = 0; iOp < operators.size(); iOp++) {\n          String a = LITERAL_OPERANDS.get(iOperandA);\n          String b = LITERAL_OPERANDS.get(iOperandB);\n          String op = operators.get(iOp);\n\n          // Test commutativity.\n          // TODO(nicksantos): Eventually, all cases should be collapsed.\n          assertSameResultsOrUncollapsed(join(a, op, b), join(b, op, a));\n        }\n      }\n    }\n  }\n"], "Time_7": ["    public void testParseInto_monthDay_feb29_newYork_startOfYear() {\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"M d\").withLocale(Locale.UK);\n        MutableDateTime result = new MutableDateTime(2004, 1, 1, 0, 0, 0, 0, NEWYORK);\n        assertEquals(4, f.parseInto(result, \"2 29\", 0));\n        assertEquals(new MutableDateTime(2004, 2, 29, 0, 0, 0, 0, NEWYORK), result);\n    }\n", "    public void testParseInto_monthDay_feb29_tokyo_endOfYear() {\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"M d\").withLocale(Locale.UK);\n        MutableDateTime result = new MutableDateTime(2004, 12, 31, 23, 59, 59, 999, TOKYO);\n        assertEquals(4, f.parseInto(result, \"2 29\", 0));\n        assertEquals(new MutableDateTime(2004, 2, 29, 23, 59, 59, 999, TOKYO), result);\n    }\n"], "Closure_80": ["  public void testLocalValue1() throws Exception {\n    // Names are not known to be local.\n    assertFalse(testLocalValue(\"x\"));\n    assertFalse(testLocalValue(\"x()\"));\n    assertFalse(testLocalValue(\"this\"));\n    assertFalse(testLocalValue(\"arguments\"));\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    assertFalse(testLocalValue(\"new x()\"));\n\n    // property references are assume to be non-local\n    assertFalse(testLocalValue(\"(new x()).y\"));\n    assertFalse(testLocalValue(\"(new x())['y']\"));\n\n    // Primitive values are local\n    assertTrue(testLocalValue(\"null\"));\n    assertTrue(testLocalValue(\"undefined\"));\n    assertTrue(testLocalValue(\"Infinity\"));\n    assertTrue(testLocalValue(\"NaN\"));\n    assertTrue(testLocalValue(\"1\"));\n    assertTrue(testLocalValue(\"'a'\"));\n    assertTrue(testLocalValue(\"true\"));\n    assertTrue(testLocalValue(\"false\"));\n    assertTrue(testLocalValue(\"[]\"));\n    assertTrue(testLocalValue(\"{}\"));\n\n    // The contents of arrays and objects don't matter\n    assertTrue(testLocalValue(\"[x]\"));\n    assertTrue(testLocalValue(\"{'a':x}\"));\n\n    // Pre-increment results in primitive number\n    assertTrue(testLocalValue(\"++x\"));\n    assertTrue(testLocalValue(\"--x\"));\n\n    // Post-increment, the previous value matters.\n    assertFalse(testLocalValue(\"x++\"));\n    assertFalse(testLocalValue(\"x--\"));\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    assertTrue(testLocalValue(\"x=1\"));\n    assertFalse(testLocalValue(\"x=[]\"));\n    assertFalse(testLocalValue(\"x=y\"));\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    assertTrue(testLocalValue(\"x+=y\"));\n    assertTrue(testLocalValue(\"x*=y\"));\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    assertTrue(testLocalValue(\"x==y\"));\n    assertTrue(testLocalValue(\"x!=y\"));\n    assertTrue(testLocalValue(\"x>y\"));\n    // Only the right side of a comma matters\n    assertTrue(testLocalValue(\"(1,2)\"));\n    assertTrue(testLocalValue(\"(x,1)\"));\n    assertFalse(testLocalValue(\"(x,y)\"));\n\n    // Both the operands of OR matter\n    assertTrue(testLocalValue(\"1||2\"));\n    assertFalse(testLocalValue(\"x||1\"));\n    assertFalse(testLocalValue(\"x||y\"));\n    assertFalse(testLocalValue(\"1||y\"));\n\n    // Both the operands of AND matter\n    assertTrue(testLocalValue(\"1&&2\"));\n    assertFalse(testLocalValue(\"x&&1\"));\n    assertFalse(testLocalValue(\"x&&y\"));\n    assertFalse(testLocalValue(\"1&&y\"));\n\n    // Only the results of HOOK matter\n    assertTrue(testLocalValue(\"x?1:2\"));\n    assertFalse(testLocalValue(\"x?x:2\"));\n    assertFalse(testLocalValue(\"x?1:x\"));\n    assertFalse(testLocalValue(\"x?x:y\"));\n\n    // Results of ops are local values\n    assertTrue(testLocalValue(\"!y\"));\n    assertTrue(testLocalValue(\"~y\"));\n    assertTrue(testLocalValue(\"y + 1\"));\n    assertTrue(testLocalValue(\"y + z\"));\n    assertTrue(testLocalValue(\"y * z\"));\n\n    assertTrue(testLocalValue(\"'a' in x\"));\n    assertTrue(testLocalValue(\"typeof x\"));\n    assertTrue(testLocalValue(\"x instanceof y\"));\n\n    assertTrue(testLocalValue(\"void x\"));\n    assertTrue(testLocalValue(\"void 0\"));\n\n    assertFalse(testLocalValue(\"{}.x\"));\n\n    assertTrue(testLocalValue(\"{}.toString()\"));\n    assertTrue(testLocalValue(\"o.toString()\"));\n\n    assertFalse(testLocalValue(\"o.valueOf()\"));\n\n    assertTrue(testLocalValue(\"delete a.b\"));\n  }\n", "  public void testIsBooleanResult() {\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));\n\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));\n\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));\n\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));\n\n    // Definitely not boolean\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));\n  }\n"], "Closure_107": ["  public void testGetMsgWiringNoWarnings() throws Exception {\n    args.add(\"--compilation_level=ADVANCED_OPTIMIZATIONS\");\n    test(\"/** @desc A bad foo. */ var MSG_FOO = 1;\", \"\");\n  }\n"], "Closure_42": ["  public void testForEach() {\n    parseError(\n        \"function f(stamp, status) {\\n\" +\n        \"  for each ( var curTiming in this.timeLog.timings ) {\\n\" +\n        \"    if ( curTiming.callId == stamp ) {\\n\" +\n        \"      curTiming.flag = status;\\n\" +\n        \"      break;\\n\" +\n        \"    }\\n\" +\n        \"  }\\n\" +\n        \"};\",\n        \"unsupported language extension: for each\");\n  }\n"], "Closure_131": ["  public void testDoNotConvert() {\n    testSame(\"a[0]\");\n    testSame(\"a['']\");\n    testSame(\"a[' ']\");\n    testSame(\"a[',']\");\n    testSame(\"a[';']\");\n    testSame(\"a[':']\");\n    testSame(\"a['.']\");\n    testSame(\"a['0']\");\n    testSame(\"a['p ']\");\n    testSame(\"a['p' + '']\");\n    testSame(\"a[p]\");\n    testSame(\"a[P]\");\n    testSame(\"a[$]\");\n    testSame(\"a[p()]\");\n    testSame(\"a['default']\");\n    // Ignorable control characters are ok in Java identifiers, but not in JS.\n    testSame(\"a['A\\u0004']\");\n    // upper case lower half of o from phonetic extensions set.\n    // valid in Safari, not in Firefox, IE.\n    test(\"a['\\u1d17A']\", \"a['\\u1d17A']\");\n    // Latin capital N with tilde - nice if we handled it, but for now let's\n    // only allow simple Latin (aka ASCII) to be converted.\n    test(\"a['\\u00d1StuffAfter']\", \"a['\\u00d1StuffAfter']\");\n  }\n", "  public void testQuotedProps() {\n    testSame(\"({'':0})\");\n    testSame(\"({'1.0':0})\");\n    testSame(\"({'\\u1d17A':0})\");\n    testSame(\"({'a\\u0004b':0})\");\n  }\n"], "Closure_89": ["  public void testAliasCreatedForFunctionDepth1_1() {\n    testSame(\"var a = function(){}; a.b = 1; var c = a; c.b = 2; a.b != c.b;\");\n  }\n", "  public void testAliasCreatedForFunctionDepth1_2() {\n    testSame(\"var a = function(){}; a.b = 1; f(a); a.b;\");\n  }\n", "  public void testAliasCreatedForFunctionDepth1_3() {\n    testSame(\"var a = function(){}; a.b = 1; new f(a); a.b;\");\n  }\n", "  public void testAliasCreatedForFunctionDepth2() {\n    test(\n        \"var a = {}; a.b = function() {}; a.b.c = 1; var d = a.b;\" +\n        \"a.b.c != d.c;\",\n        \"var a$b = function() {}; a$b.c = 1; var d = a$b;\" +\n        \"a$b.c != d.c;\");\n  }\n", "  public void testAddPropertyToUncollapsibleFunctionInLocalScopeDepth1() {\n    testSame(\"function a() {} var c = a; (function() {a.b = 0;})(); a.b;\");\n  }\n", "  public void testAddPropertyToUncollapsibleNamedCtorInLocalScopeDepth1() {\n    // This technically should be collapsed, according to the rules.\n    // We don't collapse named constructors for legacy reasons\n    // (this pass has been around too long, and we don't know who's\n    // depending on this behavior).\n    testSame(\n          \"/** @constructor */ function a() {} var c = a; \" +\n          \"(function() {a.b = 0;})(); a.b;\");\n  }\n", "  public void testAddPropertyToUncollapsibleFunctionInLocalScopeDepth2() {\n    test(\"var a = {}; a.b = function (){}; var d = a.b;\" +\n         \"(function() {a.b.c = 0;})(); a.b.c;\",\n         \"var a$b = function (){}; var d = a$b;\" +\n         \"(function() {a$b.c = 0;})(); a$b.c;\");\n  }\n", "  public void testAddPropertyToChildOfUncollapsibleFunctionInLocalScope() {\n    testSame(\n        \"function a() {} a.b = {x: 0}; var c = a;\" +\n        \"(function() {a.b.y = 0;})(); a.b.y;\");\n  }\n"], "Lang_37": ["    public void testJira567(){\n        Number[] n;\n        // Valid array construction\n        n = ArrayUtils.addAll(new Number[]{Integer.valueOf(1)}, new Long[]{Long.valueOf(2)});\n        assertEquals(2,n.length);\n        assertEquals(Number.class,n.getClass().getComponentType());\n        try {\n            // Invalid - can't store Long in Integer array\n               n = ArrayUtils.addAll(new Integer[]{Integer.valueOf(1)}, new Long[]{Long.valueOf(2)});\n               fail(\"Should have generated IllegalArgumentException\");\n        } catch (IllegalArgumentException expected) {\n        }\n    }\n"], "Closure_45": ["  public void testIssue618_1() {\n    this.removeGlobal = false;\n    testSame(\n        \"function f() {\\n\" +\n        \"  var a = [], b;\\n\" +\n        \"  a.push(b = []);\\n\" +\n        \"  b[0] = 1;\\n\" +\n        \"  return a;\\n\" +\n        \"}\");\n  }\n"], "Closure_109": ["  public void testStructuralConstructor2() throws Exception {\n    JSType type = testParseType(\n        \"function (new:?)\",\n        // toString skips unknowns, but isConstructor reveals the truth.\n        \"function (): ?\");\n    assertTrue(type.isConstructor());\n    assertFalse(type.isNominalConstructor());\n  }\n", "  public void testStructuralConstructor3() throws Exception {\n    resolve(parse(\"@type {function (new:*)} */\").getType(),\n        \"constructed type must be an object type\");\n  }\n"], "Lang_30": ["    public void testContainsAny_StringCharArrayWithBadSupplementaryChars() {\n        // Test edge case: 1/2 of a (broken) supplementary char\n        assertEquals(false, StringUtils.containsAny(CharUSuppCharHigh, CharU20001.toCharArray()));\n        assertEquals(false, StringUtils.containsAny(\"abc\" + CharUSuppCharHigh + \"xyz\", CharU20001.toCharArray()));\n        assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001));\n        assertEquals(false, StringUtils.containsAny(CharUSuppCharLow, CharU20001.toCharArray()));\n        assertEquals(false, StringUtils.containsAny(CharU20001, CharUSuppCharHigh.toCharArray()));\n        assertEquals(0, CharU20001.indexOf(CharUSuppCharLow));\n        assertEquals(true, StringUtils.containsAny(CharU20001, CharUSuppCharLow.toCharArray()));\n    }\n", "    public void testContainsAny_StringWithBadSupplementaryChars() {\n        // Test edge case: 1/2 of a (broken) supplementary char\n        assertEquals(false, StringUtils.containsAny(CharUSuppCharHigh, CharU20001));\n        assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001));\n        assertEquals(false, StringUtils.containsAny(CharUSuppCharLow, CharU20001));\n        assertEquals(false, StringUtils.containsAny(CharU20001, CharUSuppCharHigh));\n        assertEquals(0, CharU20001.indexOf(CharUSuppCharLow));\n        assertEquals(true, StringUtils.containsAny(CharU20001, CharUSuppCharLow));\n    }\n", "    public void testContainsNone_CharArrayWithBadSupplementaryChars() {\n        // Test edge case: 1/2 of a (broken) supplementary char\n        assertEquals(true, StringUtils.containsNone(CharUSuppCharHigh, CharU20001.toCharArray()));\n        assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001));\n        assertEquals(true, StringUtils.containsNone(CharUSuppCharLow, CharU20001.toCharArray()));\n        assertEquals(-1, CharU20001.indexOf(CharUSuppCharHigh));\n        assertEquals(true, StringUtils.containsNone(CharU20001, CharUSuppCharHigh.toCharArray()));\n        assertEquals(0, CharU20001.indexOf(CharUSuppCharLow));\n        assertEquals(false, StringUtils.containsNone(CharU20001, CharUSuppCharLow.toCharArray()));\n    }\n", "    public void testContainsNone_CharArrayWithSupplementaryChars() {\n        assertEquals(false, StringUtils.containsNone(CharU20000 + CharU20001, CharU20000.toCharArray()));\n        assertEquals(false, StringUtils.containsNone(CharU20000 + CharU20001, CharU20001.toCharArray()));\n        assertEquals(false, StringUtils.containsNone(CharU20000, CharU20000.toCharArray()));\n        // Sanity check:\n        assertEquals(-1, CharU20000.indexOf(CharU20001));\n        assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0)));\n        assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1)));\n        // Test:\n        assertEquals(true, StringUtils.containsNone(CharU20000, CharU20001.toCharArray()));\n        assertEquals(true, StringUtils.containsNone(CharU20001, CharU20000.toCharArray()));\n    }\n", "    public void testContainsNone_StringWithBadSupplementaryChars() {\n        // Test edge case: 1/2 of a (broken) supplementary char\n        assertEquals(true, StringUtils.containsNone(CharUSuppCharHigh, CharU20001));\n        assertEquals(-1, CharUSuppCharLow.indexOf(CharU20001));\n        assertEquals(true, StringUtils.containsNone(CharUSuppCharLow, CharU20001));\n        assertEquals(-1, CharU20001.indexOf(CharUSuppCharHigh));\n        assertEquals(true, StringUtils.containsNone(CharU20001, CharUSuppCharHigh));\n        assertEquals(0, CharU20001.indexOf(CharUSuppCharLow));\n        assertEquals(false, StringUtils.containsNone(CharU20001, CharUSuppCharLow));        \n    }\n", "    public void testContainsNone_StringWithSupplementaryChars() {\n        assertEquals(false, StringUtils.containsNone(CharU20000 + CharU20001, CharU20000));\n        assertEquals(false, StringUtils.containsNone(CharU20000 + CharU20001, CharU20001));\n        assertEquals(false, StringUtils.containsNone(CharU20000, CharU20000));\n        // Sanity check:\n        assertEquals(-1, CharU20000.indexOf(CharU20001));\n        assertEquals(0, CharU20000.indexOf(CharU20001.charAt(0)));\n        assertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1)));\n        // Test:\n        assertEquals(true, StringUtils.containsNone(CharU20000, CharU20001));\n        assertEquals(true, StringUtils.containsNone(CharU20001, CharU20000));\n    }\n", "    public void testIndexOfAny_StringCharArrayWithSupplementaryChars() {\n        assertEquals(0, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20000.toCharArray()));\n        assertEquals(2, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20001.toCharArray()));\n        assertEquals(0, StringUtils.indexOfAny(CharU20000, CharU20000.toCharArray()));\n        assertEquals(-1, StringUtils.indexOfAny(CharU20000, CharU20001.toCharArray()));    \n    }\n", "    public void testIndexOfAny_StringStringWithSupplementaryChars() {\n        assertEquals(0, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20000));\n        assertEquals(2, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20001));\n        assertEquals(0, StringUtils.indexOfAny(CharU20000, CharU20000));\n        assertEquals(-1, StringUtils.indexOfAny(CharU20000, CharU20001));    \n    }\n", "    public void testIndexOfAnyBut_StringCharArrayWithSupplementaryChars() {\n        assertEquals(2, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20000.toCharArray()));\n        assertEquals(0, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20001.toCharArray()));\n        assertEquals(-1, StringUtils.indexOfAnyBut(CharU20000, CharU20000.toCharArray()));\n        assertEquals(0, StringUtils.indexOfAnyBut(CharU20000, CharU20001.toCharArray()));        \n    }\n", "    public void testIndexOfAnyBut_StringStringWithSupplementaryChars() {\n        assertEquals(2, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20000));\n        assertEquals(0, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20001));\n        assertEquals(-1, StringUtils.indexOfAnyBut(CharU20000, CharU20000));\n        assertEquals(0, StringUtils.indexOfAnyBut(CharU20000, CharU20001));        \n    }\n"], "Time_9": ["    public void testForOffsetHoursMinutes_int_int() {\n        assertEquals(DateTimeZone.UTC, DateTimeZone.forOffsetHoursMinutes(0, 0));\n        assertEquals(DateTimeZone.forID(\"+23:59\"), DateTimeZone.forOffsetHoursMinutes(23, 59));\n        assertEquals(DateTimeZone.forID(\"+03:15\"), DateTimeZone.forOffsetHoursMinutes(3, 15));\n        assertEquals(DateTimeZone.forID(\"-02:00\"), DateTimeZone.forOffsetHoursMinutes(-2, 0));\n        assertEquals(DateTimeZone.forID(\"-02:30\"), DateTimeZone.forOffsetHoursMinutes(-2, 30));\n        assertEquals(DateTimeZone.forID(\"-23:59\"), DateTimeZone.forOffsetHoursMinutes(-23, 59));\n        try {\n            DateTimeZone.forOffsetHoursMinutes(2, 60);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            DateTimeZone.forOffsetHoursMinutes(-2, 60);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            DateTimeZone.forOffsetHoursMinutes(2, -1);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            DateTimeZone.forOffsetHoursMinutes(-2, -1);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            DateTimeZone.forOffsetHoursMinutes(24, 0);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            DateTimeZone.forOffsetHoursMinutes(-24, 0);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }        \n"], "Lang_3": ["    @Test\n    public void testStringCreateNumberEnsureNoPrecisionLoss(){\n        String shouldBeFloat = \"1.23\";\n        String shouldBeDouble = \"3.40282354e+38\";\n        String shouldBeBigDecimal = \"1.797693134862315759e+308\";\n        \n        assertTrue(NumberUtils.createNumber(shouldBeFloat) instanceof Float);\n        assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double);\n        assertTrue(NumberUtils.createNumber(shouldBeBigDecimal) instanceof BigDecimal);\n    }\n"], "Lang_64": ["    public void testCompareTo_otherEnumType() {\n        try {\n            ValuedColorEnum.BLUE.compareTo(ValuedLanguageEnum.ENGLISH);\n            fail();\n        } catch (ClassCastException ex) {\n            // expected\n        }\n    }\n"], "Closure_11": ["  public void testGetprop4() throws Exception {\n    testTypes(\"var x = null; x.prop = 3;\",\n        \"No properties on this expression\\n\" +\n        \"found   : null\\n\" +\n        \"required: Object\");\n  }\n", "  public void testIssue810() throws Exception {\n    testTypes(\n        \"/** @constructor */\" +\n        \"var Type = function () {\" +\n        \"};\" +\n        \"Type.prototype.doIt = function(obj) {\" +\n        \"  this.prop = obj.unknownProp;\" +\n        \"};\",\n        \"Property unknownProp never defined on obj\");\n  }\n"], "Chart_14": ["    public void testRemoveDomainMarker() {\n    \tCategoryPlot plot = new CategoryPlot();\n    \tassertFalse(plot.removeDomainMarker(new CategoryMarker(\"Category 1\")));\n    }\n", "    public void testRemoveRangeMarker() {\n    \tCategoryPlot plot = new CategoryPlot();\n    \tassertFalse(plot.removeRangeMarker(new ValueMarker(0.5)));\n    }\n", "    public void testRemoveDomainMarker() {\n    \tXYPlot plot = new XYPlot();\n    \tassertFalse(plot.removeDomainMarker(new ValueMarker(0.5)));\n    }\n", "    public void testRemoveRangeMarker() {\n    \tXYPlot plot = new XYPlot();\n    \tassertFalse(plot.removeRangeMarker(new ValueMarker(0.5)));\n    }\n"], "Closure_29": ["  public void testObject10() {\n    testLocal(\"var x; var b = f(); x = {a:a, b:b}; if(x.a) g(x.b);\",\n         \"var JSCompiler_object_inline_a_0;\" +\n         \"var JSCompiler_object_inline_b_1;\" +\n         \"var b = f();\" +\n         \"JSCompiler_object_inline_a_0=a,JSCompiler_object_inline_b_1=b,true;\" +\n         \"if(JSCompiler_object_inline_a_0) g(JSCompiler_object_inline_b_1)\");\n    testLocal(\"var x = {}; var b = f(); x = {a:a, b:b}; if(x.a) g(x.b) + x.c\",\n         \"var x = {}; var b = f(); x = {a:a, b:b}; if(x.a) g(x.b) + x.c\");\n    testLocal(\"var x; var b = f(); x = {a:a, b:b}; x.c = c; if(x.a) g(x.b) + x.c\",\n         \"var JSCompiler_object_inline_a_0;\" +\n         \"var JSCompiler_object_inline_b_1;\" +\n         \"var JSCompiler_object_inline_c_2;\" +\n         \"var b = f();\" +\n         \"JSCompiler_object_inline_a_0 = a,JSCompiler_object_inline_b_1 = b, \" +\n         \"  JSCompiler_object_inline_c_2=void 0,true;\" +\n         \"JSCompiler_object_inline_c_2 = c;\" +\n         \"if (JSCompiler_object_inline_a_0)\" +\n         \"  g(JSCompiler_object_inline_b_1) + JSCompiler_object_inline_c_2;\");\n    testLocal(\"var x = {a:a}; if (b) x={b:b}; f(x.a||x.b);\",\n         \"var JSCompiler_object_inline_a_0 = a;\" +\n         \"var JSCompiler_object_inline_b_1;\" +\n         \"if(b) JSCompiler_object_inline_b_1 = b,\" +\n         \"      JSCompiler_object_inline_a_0 = void 0,\" +\n         \"      true;\" +\n         \"f(JSCompiler_object_inline_a_0 || JSCompiler_object_inline_b_1)\");\n    testLocal(\"var x; var y = 5; x = {a:a, b:b, c:c}; if (b) x={b:b}; f(x.a||x.b);\",\n         \"var JSCompiler_object_inline_a_0;\" +\n         \"var JSCompiler_object_inline_b_1;\" +\n         \"var JSCompiler_object_inline_c_2;\" +\n         \"var y=5;\" +\n         \"JSCompiler_object_inline_a_0=a,\" +\n         \"JSCompiler_object_inline_b_1=b,\" +\n         \"JSCompiler_object_inline_c_2=c,\" +\n         \"true;\" +\n         \"if (b) JSCompiler_object_inline_b_1=b,\" +\n         \"       JSCompiler_object_inline_a_0=void 0,\" +\n         \"       JSCompiler_object_inline_c_2=void 0,\" +\n         \"       true;\" +\n         \"f(JSCompiler_object_inline_a_0||JSCompiler_object_inline_b_1)\");\n  }\n", "  public void testObject12() {\n    testLocal(\"var a; a = {x:1, y:2}; f(a.x, a.y2);\",\n        \"var a; a = {x:1, y:2}; f(a.x, a.y2);\");\n  }\n", "  public void testObject22() {\n    testLocal(\"while(1) { var a = {y:1}; if (b) a.x = 2; f(a.y, a.x);}\",\n      \"for(;1;){\" +\n      \" var JSCompiler_object_inline_y_0=1;\" +\n      \" var JSCompiler_object_inline_x_1;\" +\n      \" if(b) JSCompiler_object_inline_x_1=2;\" +\n      \" f(JSCompiler_object_inline_y_0,JSCompiler_object_inline_x_1)\" +\n      \"}\");\n\n    testLocal(\"var a; while (1) { f(a.x, a.y); a = {x:1, y:1};}\",\n        \"var a; while (1) { f(a.x, a.y); a = {x:1, y:1};}\");\n  }\n", "  public void testIssue724() {\n    testSameLocal(\n        \"var getType; getType = {};\" +\n        \"return functionToCheck && \" +\n        \"   getType.toString.apply(functionToCheck) === \" +\n        \"   '[object Function]';\");\n  }\n", "  public void testIssue724() {\n    CompilerOptions options = createCompilerOptions();\n    CompilationLevel.ADVANCED_OPTIMIZATIONS\n        .setOptionsForCompilationLevel(options);\n    String code =\n        \"isFunction = function(functionToCheck) {\" +\n        \"  var getType = {};\" +\n        \"  return functionToCheck && \" +\n        \"      getType.toString.apply(functionToCheck) === \" +\n        \"     '[object Function]';\" +\n        \"};\";\n    String result =\n        \"isFunction=function(a){var b={};\" +\n        \"return a&&\\\"[object Function]\\\"===b.b.a(a)}\";\n\n    test(options, code, result);\n  }\n"], "Lang_63": ["    public void testJiraLang281() {\n        Calendar cal = Calendar.getInstance();\n        cal.set(Calendar.MONTH, Calendar.DECEMBER);\n        cal.set(Calendar.DAY_OF_MONTH, 31);\n        cal.set(Calendar.YEAR, 2005);\n        cal.set(Calendar.HOUR_OF_DAY, 0);\n        cal.set(Calendar.MINUTE, 0);\n        cal.set(Calendar.SECOND, 0);\n        cal.set(Calendar.MILLISECOND, 0);\n\n        Calendar cal2 = Calendar.getInstance();\n        cal2.set(Calendar.MONTH, Calendar.OCTOBER);\n        cal2.set(Calendar.DAY_OF_MONTH, 6);\n        cal2.set(Calendar.YEAR, 2006);\n        cal2.set(Calendar.HOUR_OF_DAY, 0);\n        cal2.set(Calendar.MINUTE, 0);\n        cal2.set(Calendar.SECOND, 0);\n        cal2.set(Calendar.MILLISECOND, 0);\n        String result = DurationFormatUtils.formatPeriod(cal.getTime().getTime(), cal2.getTime().getTime(), \"MM\");\n        assertEquals(\"09\", result);\n    }\n"], "Lang_4": ["    @Test\n    public void testLang882() throws IOException {\n        final LookupTranslator lt = new LookupTranslator(new CharSequence[][] { { new StringBuffer(\"one\"), new StringBuffer(\"two\") } });\n        final StringWriter out = new StringWriter();\n        final int result = lt.translate(new StringBuffer(\"one\"), 0, out);\n        assertEquals(\"Incorrect codepoint consumption\", 3, result);\n        assertEquals(\"Incorrect value\", \"two\", out.toString());\n    }\n"], "Chart_13": ["    public void testSizingWithWidthConstraint() {\n        RectangleConstraint constraint = new RectangleConstraint(\n            10.0, new Range(10.0, 10.0), LengthConstraintType.FIXED,\n            0.0, new Range(0.0, 0.0), LengthConstraintType.NONE\n        );\n                \n        BlockContainer container = new BlockContainer(new BorderArrangement());\n        BufferedImage image = new BufferedImage(\n            200, 100, BufferedImage.TYPE_INT_RGB\n        );\n        Graphics2D g2 = image.createGraphics();\n        \n        // TBLRC\n        // 00001 - center item only\n        container.add(new EmptyBlock(5.0, 6.0));\n        Size2D size = container.arrange(g2, constraint);\n        assertEquals(10.0, size.width, EPSILON);\n        assertEquals(6.0, size.height, EPSILON);\n        \n        container.clear();\n        container.add(new EmptyBlock(15.0, 16.0));\n        size = container.arrange(g2, constraint);\n        assertEquals(10.0, size.width, EPSILON);\n        assertEquals(16.0, size.height, EPSILON);\n\n        // TBLRC\n        // 00010 - right item only\n        container.clear();\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.RIGHT);\n        size = container.arrange(g2, constraint);\n        assertEquals(10.0, size.width, EPSILON);\n        assertEquals(45.6, size.height, EPSILON);\n        \n        // TBLRC\n        // 00011 - right and center items\n        container.clear();\n        container.add(new EmptyBlock(7.0, 20.0));\n        container.add(new EmptyBlock(8.0, 45.6), RectangleEdge.RIGHT);\n        size = container.arrange(g2, constraint);\n        assertEquals(10.0, size.width, EPSILON);\n        assertEquals(45.6, size.height, EPSILON);\n        \n        // TBLRC\n        // 00100 - left item only\n        container.clear();\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.LEFT);\n        size = container.arrange(g2, constraint);\n        assertEquals(10.0, size.width, EPSILON);\n        assertEquals(45.6, size.height, EPSILON);\n        \n        // TBLRC\n        // 00101 - left and center items\n        container.clear();\n        container.add(new EmptyBlock(10.0, 20.0));\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.LEFT);\n        size = container.arrange(g2, constraint);\n        assertEquals(10.0, size.width, EPSILON);\n        assertEquals(45.6, size.height, EPSILON);\n        \n        // TBLRC\n        // 00110 - left and right items\n        container.clear();\n        container.add(new EmptyBlock(10.0, 20.0), RectangleEdge.RIGHT);\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.LEFT);\n        size = container.arrange(g2, constraint);\n        assertEquals(10.0, size.width, EPSILON);\n        assertEquals(45.6, size.height, EPSILON);\n        \n        // TBLRC\n        // 00111 - left, right and center items\n        container.clear();\n        container.add(new EmptyBlock(10.0, 20.0));\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.LEFT);\n        container.add(new EmptyBlock(5.4, 3.2), RectangleEdge.RIGHT);\n        size = container.arrange(g2, constraint);\n        assertEquals(10.0, size.width, EPSILON);\n        assertEquals(45.6, size.height, EPSILON);\n        \n        // TBLRC\n        // 01000 - bottom item only\n        container.clear();\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.BOTTOM);\n        size = container.arrange(g2, constraint);\n        assertEquals(10.0, size.width, EPSILON);\n        assertEquals(45.6, size.height, EPSILON);\n        \n        // TBLRC\n        // 01001 - bottom and center only\n        container.clear();\n        container.add(new EmptyBlock(10.0, 20.0));\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.BOTTOM);\n        size = container.arrange(g2, constraint);\n        assertEquals(10.0, size.width, EPSILON);\n        assertEquals(65.6, size.height, EPSILON);\n        \n        // TBLRC\n        // 01010 - bottom and right only\n        container.clear();\n        container.add(new EmptyBlock(10.0, 20.0), RectangleEdge.RIGHT);\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.BOTTOM);\n        size = container.arrange(g2, constraint);\n        assertEquals(10.0, size.width, EPSILON);\n        assertEquals(65.6, size.height, EPSILON);\n        \n        // TBLRC\n        // 01011 - bottom, right and center\n        container.clear();\n        container.add(new EmptyBlock(21.0, 12.3));\n        container.add(new EmptyBlock(10.0, 20.0), RectangleEdge.RIGHT);\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.BOTTOM);\n        size = container.arrange(g2, constraint);\n        assertEquals(10.0, size.width, EPSILON);\n        assertEquals(65.6, size.height, EPSILON);\n        \n        // TBLRC\n        // 01100\n        container.clear();\n        container.add(new EmptyBlock(10.0, 20.0), RectangleEdge.LEFT);\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.BOTTOM);\n        size = container.arrange(g2, constraint);\n        assertEquals(10.0, size.width, EPSILON);\n        assertEquals(65.6, size.height, EPSILON);\n        \n        // TBLRC\n        // 01101 - bottom, left and center\n        container.clear();\n        container.add(new EmptyBlock(21.0, 12.3));\n        container.add(new EmptyBlock(10.0, 20.0), RectangleEdge.LEFT);\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.BOTTOM);\n        size = container.arrange(g2, constraint);\n        assertEquals(10.0, size.width, EPSILON);\n        assertEquals(65.6, size.height, EPSILON);\n        \n        // TBLRC\n        // 01110 - bottom. left and right\n        container.clear();\n        container.add(new EmptyBlock(21.0, 12.3), RectangleEdge.RIGHT);\n        container.add(new EmptyBlock(10.0, 20.0), RectangleEdge.LEFT);\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.BOTTOM);\n        size = container.arrange(g2, constraint);\n        assertEquals(10.0, size.width, EPSILON);\n        assertEquals(65.6, size.height, EPSILON);\n        \n        // TBLRC\n        // 01111\n        container.clear();\n        container.add(new EmptyBlock(3.0, 4.0), RectangleEdge.BOTTOM);\n        container.add(new EmptyBlock(5.0, 6.0), RectangleEdge.LEFT);\n        container.add(new EmptyBlock(7.0, 8.0), RectangleEdge.RIGHT);\n        container.add(new EmptyBlock(9.0, 10.0));\n        size = container.arrange(g2, constraint);\n        assertEquals(10.0, size.width, EPSILON);\n        assertEquals(14.0, size.height, EPSILON);\n        \n        // TBLRC\n        // 10000 - top item only\n        container.clear();\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.TOP);\n        size = container.arrange(g2, constraint);\n        assertEquals(10.0, size.width, EPSILON);\n        assertEquals(45.6, size.height, EPSILON);\n        \n        // TBLRC\n        // 10001 - top and center only\n        container.clear();\n        container.add(new EmptyBlock(10.0, 20.0));\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.TOP);\n        size = container.arrange(g2, constraint);\n        assertEquals(10.0, size.width, EPSILON);\n        assertEquals(65.6, size.height, EPSILON);\n                \n        // TBLRC\n        // 10010 - right and top only\n        container.clear();\n        container.add(new EmptyBlock(10.0, 20.0), RectangleEdge.RIGHT);\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.TOP);\n        size = container.arrange(g2, constraint);\n        assertEquals(10.0, size.width, EPSILON);\n        assertEquals(65.6, size.height, EPSILON);\n        \n        // TBLRC\n        // 10011 - top, right and center\n        container.clear();\n        container.add(new EmptyBlock(21.0, 12.3));\n        container.add(new EmptyBlock(10.0, 20.0), RectangleEdge.TOP);\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.RIGHT);\n        size = container.arrange(g2, constraint);\n        assertEquals(10.0, size.width, EPSILON);\n        assertEquals(65.6, size.height, EPSILON);\n\n        // TBLRC\n        // 10100 - top and left only\n        container.clear();\n        container.add(new EmptyBlock(10.0, 20.0), RectangleEdge.LEFT);\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.TOP);\n        size = container.arrange(g2, constraint);\n        assertEquals(10.0, size.width, EPSILON);\n        assertEquals(65.6, size.height, EPSILON);\n        \n        // TBLRC\n        // 10101 - top, left and center\n        container.clear();\n        container.add(new EmptyBlock(21.0, 12.3));\n        container.add(new EmptyBlock(10.0, 20.0), RectangleEdge.TOP);\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.LEFT);\n        size = container.arrange(g2, constraint);\n        assertEquals(10.0, size.width, EPSILON);\n        assertEquals(65.6, size.height, EPSILON);\n        \n        // TBLRC\n        // 10110 - top, left and right\n        container.clear();\n        container.add(new EmptyBlock(21.0, 12.3), RectangleEdge.RIGHT);\n        container.add(new EmptyBlock(10.0, 20.0), RectangleEdge.TOP);\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.LEFT);\n        size = container.arrange(g2, constraint);\n        assertEquals(10.0, size.width, EPSILON);\n        assertEquals(65.6, size.height, EPSILON);\n        \n        // TBLRC\n        // 10111\n        container.clear();\n        container.add(new EmptyBlock(1.0, 2.0), RectangleEdge.TOP);\n        container.add(new EmptyBlock(5.0, 6.0), RectangleEdge.LEFT);\n        container.add(new EmptyBlock(7.0, 8.0), RectangleEdge.RIGHT);\n        container.add(new EmptyBlock(9.0, 10.0));\n        size = container.arrange(g2, constraint);\n        assertEquals(10.0, size.width, EPSILON);\n        assertEquals(12.0, size.height, EPSILON);\n\n        // TBLRC\n        // 11000 - top and bottom only\n        container.clear();\n        container.add(new EmptyBlock(10.0, 20.0), RectangleEdge.TOP);\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.BOTTOM);\n        size = container.arrange(g2, constraint);\n        assertEquals(10.0, size.width, EPSILON);\n        assertEquals(65.6, size.height, EPSILON);\n        \n        // TBLRC\n        // 11001\n        container.clear();\n        container.add(new EmptyBlock(21.0, 12.3));\n        container.add(new EmptyBlock(10.0, 20.0), RectangleEdge.TOP);\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.BOTTOM);\n        size = container.arrange(g2, constraint);\n        assertEquals(10.0, size.width, EPSILON);\n        assertEquals(77.9, size.height, EPSILON);\n        \n        // TBLRC\n        // 11010 - top, bottom and right\n        container.clear();\n        container.add(new EmptyBlock(21.0, 12.3), RectangleEdge.RIGHT);\n        container.add(new EmptyBlock(10.0, 20.0), RectangleEdge.TOP);\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.BOTTOM);\n        size = container.arrange(g2, constraint);\n        assertEquals(10.0, size.width, EPSILON);\n        assertEquals(77.9, size.height, EPSILON);\n                \n        // TBLRC\n        // 11011\n        container.clear();\n        container.add(new EmptyBlock(1.0, 2.0), RectangleEdge.TOP);\n        container.add(new EmptyBlock(3.0, 4.0), RectangleEdge.BOTTOM);\n        container.add(new EmptyBlock(7.0, 8.0), RectangleEdge.RIGHT);\n        container.add(new EmptyBlock(9.0, 10.0));\n        size = container.arrange(g2, constraint);\n        assertEquals(10.0, size.width, EPSILON);\n        assertEquals(16.0, size.height, EPSILON);\n        \n        // TBLRC\n        // 11100\n        container.clear();\n        container.add(new EmptyBlock(21.0, 12.3), RectangleEdge.LEFT);\n        container.add(new EmptyBlock(10.0, 20.0), RectangleEdge.TOP);\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.BOTTOM);\n        size = container.arrange(g2, constraint);\n        assertEquals(10.0, size.width, EPSILON);\n        assertEquals(77.9, size.height, EPSILON);\n\n        // TBLRC\n        // 11101\n        container.clear();\n        container.add(new EmptyBlock(1.0, 2.0), RectangleEdge.TOP);\n        container.add(new EmptyBlock(3.0, 4.0), RectangleEdge.BOTTOM);\n        container.add(new EmptyBlock(5.0, 6.0), RectangleEdge.LEFT);\n        container.add(new EmptyBlock(9.0, 10.0));\n        size = container.arrange(g2, constraint);\n        assertEquals(10.0, size.width, EPSILON);\n        assertEquals(16.0, size.height, EPSILON);\n        \n        // TBLRC\n        // 11110\n        container.clear();\n        container.add(new EmptyBlock(1.0, 2.0), RectangleEdge.TOP);\n        container.add(new EmptyBlock(3.0, 4.0), RectangleEdge.BOTTOM);\n        container.add(new EmptyBlock(5.0, 6.0), RectangleEdge.LEFT);\n        container.add(new EmptyBlock(7.0, 8.0), RectangleEdge.RIGHT);\n        size = container.arrange(g2, constraint);\n        assertEquals(10.0, size.width, EPSILON);\n        assertEquals(14.0, size.height, EPSILON);\n        \n        // TBLRC\n        // 11111 - all\n        container.clear();\n        container.add(new EmptyBlock(1.0, 2.0), RectangleEdge.TOP);\n        container.add(new EmptyBlock(3.0, 4.0), RectangleEdge.BOTTOM);\n        container.add(new EmptyBlock(5.0, 6.0), RectangleEdge.LEFT);\n        container.add(new EmptyBlock(7.0, 8.0), RectangleEdge.RIGHT);\n        container.add(new EmptyBlock(9.0, 10.0));\n        size = container.arrange(g2, constraint);\n        assertEquals(10.0, size.width, EPSILON);\n        assertEquals(16.0, size.height, EPSILON);\n\n        // TBLRC\n        // 00000 - no items\n        container.clear();\n        size = container.arrange(g2, constraint);\n        assertEquals(10.0, size.width, EPSILON);\n        assertEquals(0.0, size.height, EPSILON);\n        \n    }\n"], "Closure_16": ["  public void testIssue772() throws Exception {\n    CompilerOptions options = createCompilerOptions();\n    options.closurePass = true;\n    options.checkTypes = true;\n    test(\n        options,\n        \"/** @const */ var a = {};\" +\n        \"/** @const */ a.b = {};\" +\n        \"/** @const */ a.b.c = {};\" +\n        \"goog.scope(function() {\" +\n        \"  var b = a.b;\" +\n        \"  var c = b.c;\" +\n        \"  /** @typedef {string} */\" +\n        \"  c.MyType;\" +\n        \"  /** @param {c.MyType} x The variable. */\" +\n        \"  c.myFunc = function(x) {};\" +\n        \"});\",\n        \"/** @const */ var a = {};\" +\n        \"/** @const */ a.b = {};\" +\n        \"/** @const */ a.b.c = {};\" +\n        \"a.b.c.MyType;\" +\n        \"a.b.c.myFunc = function(x) {};\");\n  }\n", "  public void testIssue772() {\n    testTypes(\n        \"var b = a.b;\" +\n        \"var c = b.c;\",\n        \"/** @param {c.MyType} x */ types.actual;\" +\n        \"/** @param {a.b.c.MyType} x */ types.expected;\");\n  }\n"], "Lang_55": ["    public void testLang315() {\n        StopWatch watch = new StopWatch();\n        watch.start();\n            try {Thread.sleep(200);} catch (InterruptedException ex) {}\n        watch.suspend();\n        long suspendTime = watch.getTime();\n            try {Thread.sleep(200);} catch (InterruptedException ex) {}\n        watch.stop();\n        long totalTime = watch.getTime();\n        assertTrue( suspendTime == totalTime );\n    }\n"], "Chart_25": ["    public void testDrawWithNullMeanVertical() {\n        boolean success = false;\n        try {\n            DefaultStatisticalCategoryDataset dataset \n                    = new DefaultStatisticalCategoryDataset();\n            dataset.add(1.0, 2.0, \"S1\", \"C1\");\n            dataset.add(null, new Double(4.0), \"S1\", \"C2\");\n            CategoryPlot plot = new CategoryPlot(dataset, \n                    new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), \n                    new StatisticalBarRenderer());\n            JFreeChart chart = new JFreeChart(plot);\n            /* BufferedImage image = */ chart.createBufferedImage(300, 200, \n                    null);\n            success = true;\n        }\n        catch (NullPointerException e) {\n            e.printStackTrace();\n            success = false;\n        }\n        assertTrue(success);\n    }\n", "    public void testDrawWithNullMeanHorizontal() {\n        boolean success = false;\n        try {\n            DefaultStatisticalCategoryDataset dataset \n                    = new DefaultStatisticalCategoryDataset();\n            dataset.add(1.0, 2.0, \"S1\", \"C1\");\n            dataset.add(null, new Double(4.0), \"S1\", \"C2\");\n            CategoryPlot plot = new CategoryPlot(dataset, \n                    new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), \n                    new StatisticalBarRenderer());\n            plot.setOrientation(PlotOrientation.HORIZONTAL);\n            JFreeChart chart = new JFreeChart(plot);\n            /* BufferedImage image = */ chart.createBufferedImage(300, 200, \n                    null);\n            success = true;\n        }\n        catch (NullPointerException e) {\n            e.printStackTrace();\n            success = false;\n        }\n        assertTrue(success);\n    }\n", "    public void testDrawWithNullDeviationVertical() {\n        boolean success = false;\n        try {\n            DefaultStatisticalCategoryDataset dataset \n                    = new DefaultStatisticalCategoryDataset();\n            dataset.add(1.0, 2.0, \"S1\", \"C1\");\n            dataset.add(new Double(4.0), null, \"S1\", \"C2\");\n            CategoryPlot plot = new CategoryPlot(dataset, \n                    new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), \n                    new StatisticalBarRenderer());\n            JFreeChart chart = new JFreeChart(plot);\n            /* BufferedImage image = */ chart.createBufferedImage(300, 200, \n                    null);\n            success = true;\n        }\n        catch (NullPointerException e) {\n            e.printStackTrace();\n            success = false;\n        }\n        assertTrue(success);\n    }\n", "    public void testDrawWithNullDeviationHorizontal() {\n        boolean success = false;\n        try {\n            DefaultStatisticalCategoryDataset dataset \n                    = new DefaultStatisticalCategoryDataset();\n            dataset.add(1.0, 2.0, \"S1\", \"C1\");\n            dataset.add(new Double(4.0), null, \"S1\", \"C2\");\n            CategoryPlot plot = new CategoryPlot(dataset, \n                    new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), \n                    new StatisticalBarRenderer());\n            plot.setOrientation(PlotOrientation.HORIZONTAL);\n            JFreeChart chart = new JFreeChart(plot);\n            /* BufferedImage image = */ chart.createBufferedImage(300, 200, \n                    null);\n            success = true;\n        }\n        catch (NullPointerException e) {\n            e.printStackTrace();\n            success = false;\n        }\n        assertTrue(success);\n    }\n"], "Closure_20": ["  public void testSimpleFunctionCall() {\n    test(\"var a = String(23)\", \"var a = '' + 23\");\n    test(\"var a = String('hello')\", \"var a = '' + 'hello'\");\n    testSame(\"var a = String('hello', bar());\");\n    testSame(\"var a = String({valueOf: function() { return 1; }});\");\n  }\n"], "Lang_52": ["    public void testEscapeJavaScript() {\n        assertEquals(null, StringEscapeUtils.escapeJavaScript(null));\n        try {\n            StringEscapeUtils.escapeJavaScript(null, null);\n            fail();\n        } catch (IOException ex) {\n            fail();\n        } catch (IllegalArgumentException ex) {\n        }\n        try {\n            StringEscapeUtils.escapeJavaScript(null, \"\");\n            fail();\n        } catch (IOException ex) {\n            fail();\n        } catch (IllegalArgumentException ex) {\n        }\n        \n        assertEquals(\"He didn\\\\'t say, \\\\\\\"stop!\\\\\\\"\", StringEscapeUtils.escapeJavaScript(\"He didn't say, \\\"stop!\\\"\"));\n        assertEquals(\"document.getElementById(\\\\\\\"test\\\\\\\").value = \\\\'<script>alert(\\\\'aaa\\\\');<\\\\/script>\\\\';\", \n                StringEscapeUtils.escapeJavaScript(\"document.getElementById(\\\"test\\\").value = '<script>alert('aaa');</script>';\"));\n    }\n"], "Closure_18": ["  public void testDependencySorting() throws Exception {\n    CompilerOptions options = createCompilerOptions();\n    options.setDependencyOptions(\n        new DependencyOptions()\n        .setDependencySorting(true));\n    test(\n        options,\n        new String[] {\n          \"goog.require('x');\",\n          \"goog.provide('x');\",\n        },\n        new String[] {\n          \"goog.provide('x');\",\n          \"goog.require('x');\",\n\n          // For complicated reasons involving modules,\n          // the compiler creates a synthetic source file.\n          \"\",\n        });\n  }\n"], "Closure_27": ["  public void testIssue727_1() {\n    testIR(\n        IR.tryFinally(\n            IR.block(),\n            IR.block()),\n        \"TRY\\n\" +\n        \"    BLOCK\\n\" +\n        \"    BLOCK\\n\" +\n        \"    BLOCK\\n\");\n  }\n", "  public void testIssue727_2() {\n    testIR(\n        IR.tryCatch(\n            IR.block(),\n            IR.catchNode(\n                IR.name(\"e\"),\n                IR.block())),\n        \"TRY\\n\" +\n        \"    BLOCK\\n\" +\n        \"    BLOCK\\n\" +\n        \"        CATCH\\n\" +\n        \"            NAME e\\n\" +\n        \"            BLOCK\\n\");\n  }\n", "  public void testIssue727_3() {\n    testIR(\n        IR.tryCatchFinally(\n            IR.block(),\n            IR.catchNode(IR.name(\"e\"), IR.block()),\n            IR.block()),\n        \"TRY\\n\" +\n        \"    BLOCK\\n\" +\n        \"    BLOCK\\n\" +\n        \"        CATCH\\n\" +\n        \"            NAME e\\n\" +\n        \"            BLOCK\\n\" +\n        \"    BLOCK\\n\");\n  }\n"], "Chart_22": ["    public void testGetValueByKey() {\n        KeyedObjects2D data = new KeyedObjects2D();\n        data.addObject(\"Obj1\", \"R1\", \"C1\");\n        data.addObject(\"Obj2\", \"R2\", \"C2\");\n        assertEquals(\"Obj1\", data.getObject(\"R1\", \"C1\"));\n        assertEquals(\"Obj2\", data.getObject(\"R2\", \"C2\"));\n        assertNull(data.getObject(\"R1\", \"C2\"));\n        assertNull(data.getObject(\"R2\", \"C1\"));\n        \n        // check invalid indices\n        boolean pass = false;\n        try {\n            data.getObject(\"XX\", \"C1\");\n        }\n        catch (UnknownKeyException e) {\n            pass = true;\n        }\n        assertTrue(pass);\n        \n        pass = false;\n        try {\n            data.getObject(\"R1\", \"XX\");\n        }\n        catch (UnknownKeyException e) {\n            pass = true;\n        }\n        assertTrue(pass);\n\n        pass = false;\n        try {\n            data.getObject(\"XX\", \"C1\");\n        }\n        catch (UnknownKeyException e) {\n            pass = true;\n        }\n        assertTrue(pass);\n\n        pass = false;\n        try {\n            data.getObject(\"R1\", \"XX\");\n        }\n        catch (UnknownKeyException e) {\n            pass = true;\n        }\n        assertTrue(pass);\n    }\n", "    public void testSetObject() {\n        KeyedObjects2D data = new KeyedObjects2D();\n        data.setObject(\"Obj1\", \"R1\", \"C1\");\n        data.setObject(\"Obj2\", \"R2\", \"C2\");\n        assertEquals(\"Obj1\", data.getObject(\"R1\", \"C1\"));\n        assertEquals(\"Obj2\", data.getObject(\"R2\", \"C2\"));\n        assertNull(data.getObject(\"R1\", \"C2\"));\n        assertNull(data.getObject(\"R2\", \"C1\"));\n        \n        // confirm overwriting an existing value\n        data.setObject(\"ABC\", \"R2\", \"C2\");\n        assertEquals(\"ABC\", data.getObject(\"R2\", \"C2\"));\n        \n        // try null keys\n        boolean pass = false;\n        try {\n            data.setObject(\"X\", null, \"C1\");\n        }\n        catch (IllegalArgumentException e) {\n            pass = true;\n        }\n        assertTrue(pass);\n        \n        pass = false;\n        try {\n            data.setObject(\"X\", \"R1\", null);\n        }\n        catch (IllegalArgumentException e) {\n            pass = true;\n        }\n        assertTrue(pass);\n    }\n", "    public void testRemoveColumnByIndex() {\n        KeyedObjects2D data = new KeyedObjects2D();\n        data.setObject(\"Obj1\", \"R1\", \"C1\");\n        data.setObject(\"Obj2\", \"R2\", \"C2\");\n        data.removeColumn(0);\n        assertEquals(1, data.getColumnCount());\n        assertEquals(\"Obj2\", data.getObject(1, 0));\n        \n        // try negative column index\n        boolean pass = false;\n        try {\n            data.removeColumn(-1);\n        }\n        catch (IndexOutOfBoundsException e) {\n            pass = true;\n        }\n        assertTrue(pass);\n        \n        // try column index too high\n        pass = false;\n        try {\n            data.removeColumn(data.getColumnCount());\n        }\n        catch (IndexOutOfBoundsException e) {\n            pass = true;\n        }\n        assertTrue(pass);\n    }\n", "    public void testRemoveRowByKey() {\n        KeyedObjects2D data = new KeyedObjects2D();\n        data.setObject(\"Obj1\", \"R1\", \"C1\");\n        data.setObject(\"Obj2\", \"R2\", \"C2\");\n        data.removeRow(\"R2\");\n        assertEquals(1, data.getRowCount());\n        assertEquals(\"Obj1\", data.getObject(0, 0));\n        \n        // try unknown row key\n        boolean pass = false;\n        try {\n            data.removeRow(\"XXX\");\n        }\n        catch (UnknownKeyException e) {\n            pass = true;\n        }\n        assertTrue(pass);\n        \n        // try null row key\n        pass = false;\n        try {\n            data.removeRow(null);\n        }\n        catch (IllegalArgumentException e) {\n            pass = true;\n        }\n        assertTrue(pass);\n    }\n", "    public void testRemoveColumnByKey() {\n        KeyedObjects2D data = new KeyedObjects2D();\n        data.setObject(\"Obj1\", \"R1\", \"C1\");\n        data.setObject(\"Obj2\", \"R2\", \"C2\");\n        data.removeColumn(\"C2\");\n        assertEquals(1, data.getColumnCount());\n        assertEquals(\"Obj1\", data.getObject(0, 0));\n        \n        // try unknown column key\n        boolean pass = false;\n        try {\n            data.removeColumn(\"XXX\");\n        }\n        catch (UnknownKeyException e) {\n            pass = true;\n        }\n        assertTrue(pass);\n        \n        // try null column key\n        pass = false;\n        try {\n            data.removeColumn(null);\n        }\n        catch (IllegalArgumentException e) {\n            pass = true;\n        }\n        assertTrue(pass);\n    }\n", "    public void testRemoveValue() {\n        KeyedObjects2D data = new KeyedObjects2D();\n        data.setObject(\"Obj1\", \"R1\", \"C1\");\n        data.setObject(\"Obj2\", \"R2\", \"C2\");\n        data.removeObject(\"R2\", \"C2\");\n        assertEquals(1, data.getRowCount());\n        assertEquals(1, data.getColumnCount());\n        assertEquals(\"Obj1\", data.getObject(0, 0));\n    }\n"], "Lang_48": ["    public void testBigDecimal() {\n        BigDecimal o1 = new BigDecimal(\"2.0\");\n        BigDecimal o2 = new BigDecimal(\"2.00\");\n        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n        assertTrue(new EqualsBuilder().append(o1, o2).isEquals());\n    }\n"], "Closure_34": ["  public void testManyAdds() {\n    int numAdds = 10000;\n    List<String> numbers = Lists.newArrayList(\"0\", \"1\");\n    Node current = new Node(Token.ADD, Node.newNumber(0), Node.newNumber(1));\n    for (int i = 2; i < numAdds; i++) {\n      current = new Node(Token.ADD, current);\n\n      // 1000 is printed as 1E3, and screws up our test.\n      int num = i % 1000;\n      numbers.add(String.valueOf(num));\n      current.addChildToBack(Node.newNumber(num));\n    }\n\n    String expected = Joiner.on(\"+\").join(numbers);\n    String actual = printNode(current).replace(\"\\n\", \"\");\n    assertEquals(expected, actual);\n  }\n"], "Lang_41": ["    public void test_getShortClassName_Class() {\n        assertEquals(\"ClassUtils\", ClassUtils.getShortClassName(ClassUtils.class));\n        assertEquals(\"Map.Entry\", ClassUtils.getShortClassName(Map.Entry.class));\n        assertEquals(\"\", ClassUtils.getShortClassName((Class) null));\n\n        // LANG-535\n        assertEquals(\"String[]\", ClassUtils.getShortClassName(String[].class));\n        assertEquals(\"Map.Entry[]\", ClassUtils.getShortClassName(Map.Entry[].class));\n\n        // Primitives\n        assertEquals(\"boolean\", ClassUtils.getShortClassName(boolean.class));\n        assertEquals(\"byte\", ClassUtils.getShortClassName(byte.class));\n        assertEquals(\"char\", ClassUtils.getShortClassName(char.class));\n        assertEquals(\"short\", ClassUtils.getShortClassName(short.class));\n        assertEquals(\"int\", ClassUtils.getShortClassName(int.class));\n        assertEquals(\"long\", ClassUtils.getShortClassName(long.class));\n        assertEquals(\"float\", ClassUtils.getShortClassName(float.class));\n        assertEquals(\"double\", ClassUtils.getShortClassName(double.class));\n\n        // Primitive Arrays\n        assertEquals(\"boolean[]\", ClassUtils.getShortClassName(boolean[].class));\n        assertEquals(\"byte[]\", ClassUtils.getShortClassName(byte[].class));\n        assertEquals(\"char[]\", ClassUtils.getShortClassName(char[].class));\n        assertEquals(\"short[]\", ClassUtils.getShortClassName(short[].class));\n        assertEquals(\"int[]\", ClassUtils.getShortClassName(int[].class));\n        assertEquals(\"long[]\", ClassUtils.getShortClassName(long[].class));\n        assertEquals(\"float[]\", ClassUtils.getShortClassName(float[].class));\n        assertEquals(\"double[]\", ClassUtils.getShortClassName(double[].class));\n\n        // Arrays of arrays of ...\n        assertEquals(\"String[][]\", ClassUtils.getShortClassName(String[][].class));\n        assertEquals(\"String[][][]\", ClassUtils.getShortClassName(String[][][].class));\n        assertEquals(\"String[][][][]\", ClassUtils.getShortClassName(String[][][][].class));\n    }\n", "    public void test_getPackageName_Class() {\n        assertEquals(\"java.lang\", ClassUtils.getPackageName(String.class));\n        assertEquals(\"java.util\", ClassUtils.getPackageName(Map.Entry.class));\n        assertEquals(\"\", ClassUtils.getPackageName((Class)null));\n\n        // LANG-535\n        assertEquals(\"java.lang\", ClassUtils.getPackageName(String[].class));\n\n        // Primitive Arrays\n        assertEquals(\"\", ClassUtils.getPackageName(boolean[].class));\n        assertEquals(\"\", ClassUtils.getPackageName(byte[].class));\n        assertEquals(\"\", ClassUtils.getPackageName(char[].class));\n        assertEquals(\"\", ClassUtils.getPackageName(short[].class));\n        assertEquals(\"\", ClassUtils.getPackageName(int[].class));\n        assertEquals(\"\", ClassUtils.getPackageName(long[].class));\n        assertEquals(\"\", ClassUtils.getPackageName(float[].class));\n        assertEquals(\"\", ClassUtils.getPackageName(double[].class));\n\n        // Arrays of arrays of ...\n        assertEquals(\"java.lang\", ClassUtils.getPackageName(String[][].class));\n        assertEquals(\"java.lang\", ClassUtils.getPackageName(String[][][].class));\n        assertEquals(\"java.lang\", ClassUtils.getPackageName(String[][][][].class));\n    }\n"], "Closure_33": ["  public void testIssue700() throws Exception {\n    testTypes(\n        \"/**\\n\" +\n        \" * @param {{text: string}} opt_data\\n\" +\n        \" * @return {string}\\n\" +\n        \" */\\n\" +\n        \"function temp1(opt_data) {\\n\" +\n        \"  return opt_data.text;\\n\" +\n        \"}\\n\" +\n        \"\\n\" +\n        \"/**\\n\" +\n        \" * @param {{activity: (boolean|number|string|null|Object)}} opt_data\\n\" +\n        \" * @return {string}\\n\" +\n        \" */\\n\" +\n        \"function temp2(opt_data) {\\n\" +\n        \"  /** @notypecheck */\\n\" +\n        \"  function __inner() {\\n\" +\n        \"    return temp1(opt_data.activity);\\n\" +\n        \"  }\\n\" +\n        \"  return __inner();\\n\" +\n        \"}\\n\" +\n        \"\\n\" +\n        \"/**\\n\" +\n        \" * @param {{n: number, text: string, b: boolean}} opt_data\\n\" +\n        \" * @return {string}\\n\" +\n        \" */\\n\" +\n        \"function temp3(opt_data) {\\n\" +\n        \"  return 'n: ' + opt_data.n + ', t: ' + opt_data.text + '.';\\n\" +\n        \"}\\n\" +\n        \"\\n\" +\n        \"function callee() {\\n\" +\n        \"  var output = temp3({\\n\" +\n        \"    n: 0,\\n\" +\n        \"    text: 'a string',\\n\" +\n        \"    b: true\\n\" +\n        \"  })\\n\" +\n        \"  alert(output);\\n\" +\n        \"}\\n\" +\n        \"\\n\" +\n        \"callee();\");\n  }\n"], "Lang_46": ["    public void testEscapeJavaWithSlash() {\n        final String input = \"String with a slash (/) in it\";\n\n        final String expected = input;\n        final String actual = StringEscapeUtils.escapeJava(input);\n\n        /**\n         * In 2.4 StringEscapeUtils.escapeJava(String) escapes '/' characters, which are not a valid character to escape\n         * in a Java string.\n         */\n        assertEquals(expected, actual);\n    }\n"], "Lang_12": ["    public void testLANG805() {\n        long seed = System.currentTimeMillis();\n        assertEquals(\"aaa\", RandomStringUtils.random(3,0,0,false,false,new char[]{'a'},new Random(seed)));\n    }\n", "    public void testExceptions() {\n        final char[] DUMMY = new char[]{'a'}; // valid char array\n        try {\n            RandomStringUtils.random(-1);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            RandomStringUtils.random(-1, true, true);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            RandomStringUtils.random(-1, DUMMY);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            RandomStringUtils.random(1, new char[0]); // must not provide empty array => IAE\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            RandomStringUtils.random(-1, \"\");\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            RandomStringUtils.random(-1, (String)null);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            RandomStringUtils.random(-1, 'a', 'z', false, false);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            RandomStringUtils.random(-1, 'a', 'z', false, false, DUMMY);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            RandomStringUtils.random(-1, 'a', 'z', false, false, DUMMY, new Random());\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }\n"], "Closure_58": ["  public void testExpressionInForIn() {\n    assertLiveBeforeX(\"var a = [0]; X:for (a[1] in foo) { }\", \"a\");\n  }\n"], "Closure_114": ["  public void testAssignWithCall() {\n    test(\"var fun, x; (fun = function(){ x; })();\",\n        \"var x; (function(){ x; })();\");\n  }\n", "  public void testAssignWithCall2() {\n    test(\"var fun, x; (123, fun = function(){ x; })();\",\n        \"(123, function(){ x; })();\");\n  }\n"], "Time_24": ["    public void testParseLocalDate_weekyear_month_week_2010() {\n        Chronology chrono = GJChronology.getInstanceUTC();\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"xxxx-MM-ww\").withChronology(chrono);\n        assertEquals(new LocalDate(2010, 1, 4, chrono), f.parseLocalDate(\"2010-01-01\"));\n    }\n", "    public void testParseLocalDate_weekyear_month_week_2011() {\n        Chronology chrono = GJChronology.getInstanceUTC();\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"xxxx-MM-ww\").withChronology(chrono);\n        assertEquals(new LocalDate(2011, 1, 3, chrono), f.parseLocalDate(\"2011-01-01\"));\n    }\n", "    public void testParseLocalDate_weekyear_month_week_2012() {\n        Chronology chrono = GJChronology.getInstanceUTC();\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"xxxx-MM-ww\").withChronology(chrono);\n        assertEquals(new LocalDate(2012, 1, 2, chrono), f.parseLocalDate(\"2012-01-01\"));\n    }\n", "    public void testParseLocalDate_year_month_week_2010() {\n        Chronology chrono = GJChronology.getInstanceUTC();\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"yyyy-MM-ww\").withChronology(chrono);\n        assertEquals(new LocalDate(2010, 1, 4, chrono), f.parseLocalDate(\"2010-01-01\"));\n    }\n", "    public void testParseLocalDate_year_month_week_2011() {\n        Chronology chrono = GJChronology.getInstanceUTC();\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"yyyy-MM-ww\").withChronology(chrono);\n        assertEquals(new LocalDate(2011, 1, 3, chrono), f.parseLocalDate(\"2011-01-01\"));\n    }\n", "    public void testParseLocalDate_year_month_week_2012() {\n        Chronology chrono = GJChronology.getInstanceUTC();\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"yyyy-MM-ww\").withChronology(chrono);\n        assertEquals(new LocalDate(2012, 1, 2, chrono), f.parseLocalDate(\"2012-01-01\"));\n    }\n", "    public void testParseLocalDate_year_month_week_2016() {\n        Chronology chrono = GJChronology.getInstanceUTC();\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"yyyy-MM-ww\").withChronology(chrono);\n        assertEquals(new LocalDate(2016, 1, 4, chrono), f.parseLocalDate(\"2016-01-01\"));\n    }\n"], "Closure_67": ["  public void testAliasing7() {\n    // An exported alias must preserved any referenced values in the\n    // referenced function.\n    testSame(\"function e(){}\" +\n           \"e.prototype['alias1'] = e.prototype.method1 = \" +\n               \"function(){this.method2()};\" +\n           \"e.prototype.method2 = function(){};\");\n  }\n"], "Lang_15": ["    @SuppressWarnings(\"boxing\") // deliberately used here\n    @Test\n    public void testIsAssignable() throws SecurityException, NoSuchMethodException,\n            NoSuchFieldException {\n        List list0 = null;\n        List<Object> list1 = null;\n        List<?> list2 = null;\n        List<? super Object> list3 = null;\n        List<String> list4 = null;\n        List<? extends String> list5 = null;\n        List<? super String> list6 = null;\n        List[] list7 = null;\n        List<Object>[] list8 = null;\n        List<?>[] list9 = null;\n        List<? super Object>[] list10 = null;\n        List<String>[] list11 = null;\n        List<? extends String>[] list12 = null;\n        List<? super String>[] list13;\n        Class<?> clazz = getClass();\n        Method method = clazz.getMethod(\"dummyMethod\", List.class, List.class, List.class,\n                List.class, List.class, List.class, List.class, List[].class, List[].class,\n                List[].class, List[].class, List[].class, List[].class, List[].class);\n        Type[] types = method.getGenericParameterTypes();\n//        list0 = list0;\n        delegateBooleanAssertion(types, 0, 0, true);\n        list1 = list0;\n        delegateBooleanAssertion(types, 0, 1, true);\n        list0 = list1;\n        delegateBooleanAssertion(types, 1, 0, true);\n        list2 = list0;\n        delegateBooleanAssertion(types, 0, 2, true);\n        list0 = list2;\n        delegateBooleanAssertion(types, 2, 0, true);\n        list3 = list0;\n        delegateBooleanAssertion(types, 0, 3, true);\n        list0 = list3;\n        delegateBooleanAssertion(types, 3, 0, true);\n        list4 = list0;\n        delegateBooleanAssertion(types, 0, 4, true);\n        list0 = list4;\n        delegateBooleanAssertion(types, 4, 0, true);\n        list5 = list0;\n        delegateBooleanAssertion(types, 0, 5, true);\n        list0 = list5;\n        delegateBooleanAssertion(types, 5, 0, true);\n        list6 = list0;\n        delegateBooleanAssertion(types, 0, 6, true);\n        list0 = list6;\n        delegateBooleanAssertion(types, 6, 0, true);\n//        list1 = list1;\n        delegateBooleanAssertion(types, 1, 1, true);\n        list2 = list1;\n        delegateBooleanAssertion(types, 1, 2, true);\n        list1 = (List<Object>) list2;\n        delegateBooleanAssertion(types, 2, 1, false);\n        list3 = list1;\n        delegateBooleanAssertion(types, 1, 3, true);\n        list1 = (List<Object>) list3;\n        delegateBooleanAssertion(types, 3, 1, false);\n        // list4 = list1;\n        delegateBooleanAssertion(types, 1, 4, false);\n        // list1 = list4;\n        delegateBooleanAssertion(types, 4, 1, false);\n        // list5 = list1;\n        delegateBooleanAssertion(types, 1, 5, false);\n        // list1 = list5;\n        delegateBooleanAssertion(types, 5, 1, false);\n        list6 = list1;\n        delegateBooleanAssertion(types, 1, 6, true);\n        list1 = (List<Object>) list6;\n        delegateBooleanAssertion(types, 6, 1, false);\n//        list2 = list2;\n        delegateBooleanAssertion(types, 2, 2, true);\n        list2 = list3;\n        delegateBooleanAssertion(types, 2, 3, false);\n        list2 = list4;\n        delegateBooleanAssertion(types, 3, 2, true);\n        list3 = (List<? super Object>) list2;\n        delegateBooleanAssertion(types, 2, 4, false);\n        list2 = list5;\n        delegateBooleanAssertion(types, 4, 2, true);\n        list4 = (List<String>) list2;\n        delegateBooleanAssertion(types, 2, 5, false);\n        list2 = list6;\n        delegateBooleanAssertion(types, 5, 2, true);\n        list5 = (List<? extends String>) list2;\n        delegateBooleanAssertion(types, 2, 6, false);\n//        list3 = list3;\n        delegateBooleanAssertion(types, 6, 2, true);\n        list6 = (List<? super String>) list2;\n        delegateBooleanAssertion(types, 3, 3, true);\n        // list4 = list3;\n        delegateBooleanAssertion(types, 3, 4, false);\n        // list3 = list4;\n        delegateBooleanAssertion(types, 4, 3, false);\n        // list5 = list3;\n        delegateBooleanAssertion(types, 3, 5, false);\n        // list3 = list5;\n        delegateBooleanAssertion(types, 5, 3, false);\n        list6 = list3;\n        delegateBooleanAssertion(types, 3, 6, true);\n        list3 = (List<? super Object>) list6;\n        delegateBooleanAssertion(types, 6, 3, false);\n//        list4 = list4;\n        delegateBooleanAssertion(types, 4, 4, true);\n        list5 = list4;\n        delegateBooleanAssertion(types, 4, 5, true);\n        list4 = (List<String>) list5;\n        delegateBooleanAssertion(types, 5, 4, false);\n        list6 = list4;\n        delegateBooleanAssertion(types, 4, 6, true);\n        list4 = (List<String>) list6;\n        delegateBooleanAssertion(types, 6, 4, false);\n//        list5 = list5;\n        delegateBooleanAssertion(types, 5, 5, true);\n        list6 = (List<? super String>) list5;\n        delegateBooleanAssertion(types, 5, 6, false);\n        list5 = (List<? extends String>) list6;\n        delegateBooleanAssertion(types, 6, 5, false);\n//        list6 = list6;\n        delegateBooleanAssertion(types, 6, 6, true);\n\n//        list7 = list7;\n        delegateBooleanAssertion(types, 7, 7, true);\n        list8 = list7;\n        delegateBooleanAssertion(types, 7, 8, true);\n        list7 = list8;\n        delegateBooleanAssertion(types, 8, 7, true);\n        list9 = list7;\n        delegateBooleanAssertion(types, 7, 9, true);\n        list7 = list9;\n        delegateBooleanAssertion(types, 9, 7, true);\n        list10 = list7;\n        delegateBooleanAssertion(types, 7, 10, true);\n        list7 = list10;\n        delegateBooleanAssertion(types, 10, 7, true);\n        list11 = list7;\n        delegateBooleanAssertion(types, 7, 11, true);\n        list7 = list11;\n        delegateBooleanAssertion(types, 11, 7, true);\n        list12 = list7;\n        delegateBooleanAssertion(types, 7, 12, true);\n        list7 = list12;\n        delegateBooleanAssertion(types, 12, 7, true);\n        list13 = list7;\n        delegateBooleanAssertion(types, 7, 13, true);\n        list7 = list13;\n        delegateBooleanAssertion(types, 13, 7, true);\n//        list8 = list8;\n        delegateBooleanAssertion(types, 8, 8, true);\n        list9 = list8;\n        delegateBooleanAssertion(types, 8, 9, true);\n        list8 = (List<Object>[]) list9;\n        delegateBooleanAssertion(types, 9, 8, false);\n        list10 = list8;\n        delegateBooleanAssertion(types, 8, 10, true);\n        list8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse\n        delegateBooleanAssertion(types, 10, 8, false);\n        // list11 = list8;\n        delegateBooleanAssertion(types, 8, 11, false);\n        // list8 = list11;\n        delegateBooleanAssertion(types, 11, 8, false);\n        // list12 = list8;\n        delegateBooleanAssertion(types, 8, 12, false);\n        // list8 = list12;\n        delegateBooleanAssertion(types, 12, 8, false);\n        list13 = list8;\n        delegateBooleanAssertion(types, 8, 13, true);\n        list8 = (List<Object>[]) list13;\n        delegateBooleanAssertion(types, 13, 8, false);\n//        list9 = list9;\n        delegateBooleanAssertion(types, 9, 9, true);\n        list10 = (List<? super Object>[]) list9;\n        delegateBooleanAssertion(types, 9, 10, false);\n        list9 = list10;\n        delegateBooleanAssertion(types, 10, 9, true);\n        list11 = (List<String>[]) list9;\n        delegateBooleanAssertion(types, 9, 11, false);\n        list9 = list11;\n        delegateBooleanAssertion(types, 11, 9, true);\n        list12 = (List<? extends String>[]) list9;\n        delegateBooleanAssertion(types, 9, 12, false);\n        list9 = list12;\n        delegateBooleanAssertion(types, 12, 9, true);\n        list13 = (List<? super String>[]) list9;\n        delegateBooleanAssertion(types, 9, 13, false);\n        list9 = list13;\n        delegateBooleanAssertion(types, 13, 9, true);\n//        list10 = list10;\n        delegateBooleanAssertion(types, 10, 10, true);\n        // list11 = list10;\n        delegateBooleanAssertion(types, 10, 11, false);\n        // list10 = list11;\n        delegateBooleanAssertion(types, 11, 10, false);\n        // list12 = list10;\n        delegateBooleanAssertion(types, 10, 12, false);\n        // list10 = list12;\n        delegateBooleanAssertion(types, 12, 10, false);\n        list13 = list10;\n        delegateBooleanAssertion(types, 10, 13, true);\n        list10 = (List<? super Object>[]) list13;\n        delegateBooleanAssertion(types, 13, 10, false);\n//        list11 = list11;\n        delegateBooleanAssertion(types, 11, 11, true);\n        list12 = list11;\n        delegateBooleanAssertion(types, 11, 12, true);\n        list11 = (List<String>[]) list12;\n        delegateBooleanAssertion(types, 12, 11, false);\n        list13 = list11;\n        delegateBooleanAssertion(types, 11, 13, true);\n        list11 = (List<String>[]) list13;\n        delegateBooleanAssertion(types, 13, 11, false);\n//        list12 = list12;\n        delegateBooleanAssertion(types, 12, 12, true);\n        list13 = (List<? super String>[]) list12;\n        delegateBooleanAssertion(types, 12, 13, false);\n        list12 = (List<? extends String>[]) list13;\n        delegateBooleanAssertion(types, 13, 12, false);\n//        list13 = list13;\n        delegateBooleanAssertion(types, 13, 13, true);\n        Type disType = getClass().getField(\"dis\").getGenericType();\n        // Reporter.log( ( ( ParameterizedType ) disType\n        // ).getOwnerType().getClass().toString() );\n        Type datType = getClass().getField(\"dat\").getGenericType();\n        Type daType = getClass().getField(\"da\").getGenericType();\n        Type uhderType = getClass().getField(\"uhder\").getGenericType();\n        Type dingType = getClass().getField(\"ding\").getGenericType();\n        Type testerType = getClass().getField(\"tester\").getGenericType();\n        Type tester2Type = getClass().getField(\"tester2\").getGenericType();\n        Type dat2Type = getClass().getField(\"dat2\").getGenericType();\n        Type dat3Type = getClass().getField(\"dat3\").getGenericType();\n        dis = dat;\n        Assert.assertTrue(TypeUtils.isAssignable(datType, disType));\n        // dis = da;\n        Assert.assertFalse(TypeUtils.isAssignable(daType, disType));\n        dis = uhder;\n        Assert.assertTrue(TypeUtils.isAssignable(uhderType, disType));\n        dis = ding;\n        Assert.assertFalse(String.format(\"type %s not assignable to %s!\", dingType, disType),\n                TypeUtils.isAssignable(dingType, disType));\n        dis = tester;\n        Assert.assertTrue(TypeUtils.isAssignable(testerType, disType));\n        // dis = tester2;\n        Assert.assertFalse(TypeUtils.isAssignable(tester2Type, disType));\n        // dat = dat2;\n        Assert.assertFalse(TypeUtils.isAssignable(dat2Type, datType));\n        // dat2 = dat;\n        Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type));\n        // dat = dat3;\n        Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType));\n        char ch = 0;\n        boolean bo = false;\n        byte by = 0;\n        short sh = 0;\n        int in = 0;\n        long lo = 0;\n        float fl = 0;\n        double du = 0;\n        du = ch;\n        Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class));\n        du = by;\n        Assert.assertTrue(TypeUtils.isAssignable(byte.class, double.class));\n        du = sh;\n        Assert.assertTrue(TypeUtils.isAssignable(short.class, double.class));\n        du = in;\n        Assert.assertTrue(TypeUtils.isAssignable(int.class, double.class));\n        du = lo;\n        Assert.assertTrue(TypeUtils.isAssignable(long.class, double.class));\n        du = fl;\n        Assert.assertTrue(TypeUtils.isAssignable(float.class, double.class));\n        lo = in;\n        Assert.assertTrue(TypeUtils.isAssignable(int.class, long.class));\n        lo = Integer.valueOf(0);\n        Assert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class));\n        // Long lngW = 1;\n        Assert.assertFalse(TypeUtils.isAssignable(int.class, Long.class));\n        // lngW = Integer.valueOf( 0 );\n        Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class));\n        in = Integer.valueOf(0);\n        Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class));\n        Integer inte = in;\n        Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class));\n        Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class));\n        Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class));\n        Type intComparableType = getClass().getField(\"intComparable\").getGenericType();\n        intComparable = 1;\n        Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType));\n        Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class));\n        Serializable ser = 1;\n        Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class));\n        Type longComparableType = getClass().getField(\"longComparable\").getGenericType();\n        // longComparable = 1;\n        Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType));\n        // longComparable = Integer.valueOf( 0 );\n        Assert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType));\n        // int[] ia;\n        // long[] la = ia;\n        Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class));\n        Integer[] ia = null;\n        Type caType = getClass().getField(\"intWildcardComparable\").getGenericType();\n        intWildcardComparable = ia;\n        Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType));\n        // int[] ina = ia;\n        Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class));\n        int[] ina = null;\n        Object[] oa;\n        // oa = ina;\n        Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class));\n        oa = new Integer[0];\n        Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class));\n        Type bClassType = AClass.class.getField(\"bClass\").getGenericType();\n        Type cClassType = AClass.class.getField(\"cClass\").getGenericType();\n        Type dClassType = AClass.class.getField(\"dClass\").getGenericType();\n        Type eClassType = AClass.class.getField(\"eClass\").getGenericType();\n        Type fClassType = AClass.class.getField(\"fClass\").getGenericType();\n        AClass aClass = new AClass(new AAClass<String>());\n        aClass.bClass = aClass.cClass;\n        Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType));\n        aClass.bClass = aClass.dClass;\n        Assert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType));\n        aClass.bClass = aClass.eClass;\n        Assert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType));\n        aClass.bClass = aClass.fClass;\n        Assert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType));\n        aClass.cClass = aClass.dClass;\n        Assert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType));\n        aClass.cClass = aClass.eClass;\n        Assert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType));\n        aClass.cClass = aClass.fClass;\n        Assert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType));\n        aClass.dClass = aClass.eClass;\n        Assert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType));\n        aClass.dClass = aClass.fClass;\n        Assert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType));\n        aClass.eClass = aClass.fClass;\n        Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType));\n    }\n", "    @Test\n    public void testGetTypeArguments() {\n        Map<TypeVariable<?>, Type> typeVarAssigns;\n        TypeVariable<?> treeSetTypeVar;\n        Type typeArg;\n\n        typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class);\n        treeSetTypeVar = Comparable.class.getTypeParameters()[0];\n        Assert.assertTrue(\"Type var assigns for Comparable from Integer: \" + typeVarAssigns,\n                typeVarAssigns.containsKey(treeSetTypeVar));\n        typeArg = typeVarAssigns.get(treeSetTypeVar);\n        Assert.assertEquals(\"Type argument of Comparable from Integer: \" + typeArg, Integer.class,\n                typeVarAssigns.get(treeSetTypeVar));\n\n        typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class);\n        treeSetTypeVar = Comparable.class.getTypeParameters()[0];\n        Assert.assertTrue(\"Type var assigns for Comparable from int: \" + typeVarAssigns,\n                typeVarAssigns.containsKey(treeSetTypeVar));\n        typeArg = typeVarAssigns.get(treeSetTypeVar);\n        Assert.assertEquals(\"Type argument of Comparable from int: \" + typeArg, Integer.class,\n                typeVarAssigns.get(treeSetTypeVar));\n\n        Collection<Integer> col = Arrays.asList(new Integer[0]);\n        typeVarAssigns = TypeUtils.getTypeArguments(List.class, Collection.class);\n        treeSetTypeVar = Comparable.class.getTypeParameters()[0];\n        Assert.assertFalse(\"Type var assigns for Collection from List: \" + typeVarAssigns,\n                typeVarAssigns.containsKey(treeSetTypeVar));\n\n        typeVarAssigns = TypeUtils.getTypeArguments(AAAClass.BBBClass.class, AAClass.BBClass.class);\n        Assert.assertTrue(typeVarAssigns.size() == 2);\n        Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.class.getTypeParameters()[0]));\n        Assert.assertEquals(String.class, typeVarAssigns.get(AAClass.BBClass.class.getTypeParameters()[0]));\n\n        typeVarAssigns = TypeUtils.getTypeArguments(Other.class, This.class);\n        Assert.assertEquals(2, typeVarAssigns.size());\n        Assert.assertEquals(String.class, typeVarAssigns.get(This.class.getTypeParameters()[0]));\n        Assert.assertEquals(Other.class.getTypeParameters()[0], typeVarAssigns.get(This.class.getTypeParameters()[1]));\n    }\n"], "Closure_60": ["  public void testIssue504() {\n    args.add(\"--compilation_level=ADVANCED_OPTIMIZATIONS\");\n    test(\"void function() { alert('hi'); }();\",\n         \"alert('hi');\", CheckSideEffects.USELESS_CODE_ERROR);\n  }\n", "  public void testGetBooleanValue() {\n    assertPureBooleanTrue(\"true\");\n    assertPureBooleanTrue(\"10\");\n    assertPureBooleanTrue(\"'0'\");\n    assertPureBooleanTrue(\"/a/\");\n    assertPureBooleanTrue(\"{}\");\n    assertPureBooleanTrue(\"[]\");\n    assertPureBooleanFalse(\"false\");\n    assertPureBooleanFalse(\"null\");\n    assertPureBooleanFalse(\"0\");\n    assertPureBooleanFalse(\"''\");\n    assertPureBooleanFalse(\"undefined\");\n    assertPureBooleanFalse(\"void 0\");\n    assertPureBooleanUnknown(\"void foo()\");\n    assertPureBooleanUnknown(\"b\");\n    assertPureBooleanUnknown(\"-'0.0'\");\n\n    // Known but getBooleanValue return false for expressions with side-effects\n    assertPureBooleanUnknown(\"{a:foo()}\");\n    assertPureBooleanUnknown(\"[foo()]\");\n  }\n"], "Time_23": ["    public void testForID_String_old() {\n        Map<String, String> map = new LinkedHashMap<String, String>();\n        map.put(\"GMT\", \"UTC\");\n        map.put(\"WET\", \"WET\");\n        map.put(\"CET\", \"CET\");\n        map.put(\"MET\", \"CET\");\n        map.put(\"ECT\", \"CET\");\n        map.put(\"EET\", \"EET\");\n        map.put(\"MIT\", \"Pacific/Apia\");\n        map.put(\"HST\", \"Pacific/Honolulu\");\n        map.put(\"AST\", \"America/Anchorage\");\n        map.put(\"PST\", \"America/Los_Angeles\");\n        map.put(\"MST\", \"America/Denver\");\n        map.put(\"PNT\", \"America/Phoenix\");\n        map.put(\"CST\", \"America/Chicago\");\n        map.put(\"EST\", \"America/New_York\");\n        map.put(\"IET\", \"America/Indiana/Indianapolis\");\n        map.put(\"PRT\", \"America/Puerto_Rico\");\n        map.put(\"CNT\", \"America/St_Johns\");\n        map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n        map.put(\"BET\", \"America/Sao_Paulo\");\n        map.put(\"ART\", \"Africa/Cairo\");\n        map.put(\"CAT\", \"Africa/Harare\");\n        map.put(\"EAT\", \"Africa/Addis_Ababa\");\n        map.put(\"NET\", \"Asia/Yerevan\");\n        map.put(\"PLT\", \"Asia/Karachi\");\n        map.put(\"IST\", \"Asia/Kolkata\");\n        map.put(\"BST\", \"Asia/Dhaka\");\n        map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n        map.put(\"CTT\", \"Asia/Shanghai\");\n        map.put(\"JST\", \"Asia/Tokyo\");\n        map.put(\"ACT\", \"Australia/Darwin\");\n        map.put(\"AET\", \"Australia/Sydney\");\n        map.put(\"SST\", \"Pacific/Guadalcanal\");\n        map.put(\"NST\", \"Pacific/Auckland\");\n        for (String key : map.keySet()) {\n            String value = map.get(key);\n            TimeZone juZone = TimeZone.getTimeZone(key);\n            DateTimeZone zone = DateTimeZone.forTimeZone(juZone);\n            assertEquals(value, zone.getID());\n//            System.out.println(juZone);\n//            System.out.println(juZone.getDisplayName());\n//            System.out.println(zone);\n//            System.out.println(\"------\");\n        }\n    }\n"], "Closure_94": ["  public void testValidDefine() {\n    assertTrue(testValidDefineValue(\"1\"));\n    assertTrue(testValidDefineValue(\"-3\"));\n    assertTrue(testValidDefineValue(\"true\"));\n    assertTrue(testValidDefineValue(\"false\"));\n    assertTrue(testValidDefineValue(\"'foo'\"));\n    \n    assertFalse(testValidDefineValue(\"x\"));\n    assertFalse(testValidDefineValue(\"null\"));\n    assertFalse(testValidDefineValue(\"undefined\"));\n    assertFalse(testValidDefineValue(\"NaN\"));\n    \n    assertTrue(testValidDefineValue(\"!true\"));\n    assertTrue(testValidDefineValue(\"-true\"));\n    assertTrue(testValidDefineValue(\"1 & 8\"));\n    assertTrue(testValidDefineValue(\"1 + 8\"));\n    assertTrue(testValidDefineValue(\"'a' + 'b'\"));\n\n    assertFalse(testValidDefineValue(\"1 & foo\"));\n  }\n", "  private boolean testValidDefineValue(String js) {\n    Node script = parse(\"var test = \" + js +\";\");\n    Node var = script.getFirstChild();\n    Node name = var.getFirstChild();\n    Node value = name.getFirstChild();\n\n    ImmutableSet<String> defines = ImmutableSet.of();\n    return NodeUtil.isValidDefineValue(value, defines);   \n  }\n", "  public void testOverridingString1() {\n    test(\n        \"/** @define {string} */ var DEF_OVERRIDE_STRING = 'x' + 'y';\",\n        \"var DEF_OVERRIDE_STRING=\\\"x\\\" + \\\"y\\\"\");\n  }  \n", "  public void testOverridingString3() {\n    overrides.put(\"DEF_OVERRIDE_STRING\", Node.newString(\"foo\"));\n    test(\n        \"/** @define {string} */ var DEF_OVERRIDE_STRING = 'x' + 'y';\",\n        \"var DEF_OVERRIDE_STRING=\\\"foo\\\"\");\n  }\n"], "Closure_113": ["  public void testNoUndeclaredVarWhenUsingClosurePass() {\n    enableClosurePass();\n    // We don't want to get goog as an undeclared var here.\n    test(\"goog.require('namespace.Class1');\\n\", null,\n        ProcessClosurePrimitives.MISSING_PROVIDE_ERROR);\n  }\n"], "Closure_69": ["  public void testThisTypeOfFunction2() throws Exception {\n    testTypes(\n        \"/** @constructor */ function F() {}\" +\n        \"/** @type {function(this:F)} */ function f() {}\" +\n        \"f();\",\n        \"\\\"function (this:F): ?\\\" must be called with a \\\"this\\\" type\");\n  }\n", "  public void testThisTypeOfFunction3() throws Exception {\n    testTypes(\n        \"/** @constructor */ function F() {}\" +\n        \"F.prototype.bar = function() {};\" +\n        \"var f = (new F()).bar; f();\",\n        \"\\\"function (this:F): undefined\\\" must be called with a \\\"this\\\" type\");\n  }\n", "  public void testThisTypeOfFunction4() throws Exception {\n    testTypes(\n        \"/** @constructor */ function F() {}\" +\n        \"F.prototype.moveTo = function(x, y) {};\" +\n        \"F.prototype.lineTo = function(x, y) {};\" +\n        \"function demo() {\" +\n        \"  var path = new F();\" +\n        \"  var points = [[1,1], [2,2]];\" +\n        \"  for (var i = 0; i < points.length; i++) {\" +\n        \"    (i == 0 ? path.moveTo : path.lineTo)(\" +\n        \"       points[i][0], points[i][1]);\" +\n        \"  }\" +\n        \"}\",\n        \"\\\"function (this:F, ?, ?): undefined\\\" \" +\n        \"must be called with a \\\"this\\\" type\");\n  }\n"], "Closure_56": ["  public void testExceptNoNewLine() throws Exception {\n    assertEquals(\"foo2:first line\", provider.getSourceLine(\"foo2\", 1));\n    assertEquals(\"foo2:second line\", provider.getSourceLine(\"foo2\", 2));\n    assertEquals(\"foo2:third line\", provider.getSourceLine(\"foo2\", 3));\n    assertEquals(null, provider.getSourceLine(\"foo2\", 4));\n  }\n", "  public void testSyntaxError1() {\n    try {\n      extractMessage(\"if (true) {}}\");\n      fail(\"Expected exception\");\n    } catch (RuntimeException e) {\n      assertTrue(e.getMessage().contains(\"JSCompiler errors\\n\"));\n      assertTrue(e.getMessage().contains(\n          \"testcode:1: ERROR - Parse error. syntax error\\n\"));\n      assertTrue(e.getMessage().contains(\"if (true) {}}\\n\"));\n    }\n  }\n", "  public void testSyntaxError2() {\n    try {\n      extractMessage(\"\", \"if (true) {}}\");\n      fail(\"Expected exception\");\n    } catch (RuntimeException e) {\n      assertTrue(e.getMessage().contains(\"JSCompiler errors\\n\"));\n      assertTrue(e.getMessage().contains(\n          \"testcode:2: ERROR - Parse error. syntax error\\n\"));\n      assertTrue(e.getMessage().contains(\"if (true) {}}\\n\"));\n    }\n  }\n"], "Closure_125": ["  public void testIssue1002() throws Exception {\n    testTypes(\n        \"/** @interface */\" +\n        \"var I = function() {};\" +\n        \"/** @constructor @implements {I} */\" +\n        \"var A = function() {};\" +\n        \"/** @constructor @implements {I} */\" +\n        \"var B = function() {};\" +\n        \"var f = function() {\" +\n        \"  if (A === B) {\" +\n        \"    new B();\" +\n        \"  }\" +\n        \"};\");\n  }\n"], "Time_15": ["    public void testSafeMultiplyLongInt() {\n        assertEquals(0L, FieldUtils.safeMultiply(0L, 0));\n        \n        assertEquals(1L, FieldUtils.safeMultiply(1L, 1));\n        assertEquals(3L, FieldUtils.safeMultiply(1L, 3));\n        assertEquals(3L, FieldUtils.safeMultiply(3L, 1));\n        \n        assertEquals(6L, FieldUtils.safeMultiply(2L, 3));\n        assertEquals(-6L, FieldUtils.safeMultiply(2L, -3));\n        assertEquals(-6L, FieldUtils.safeMultiply(-2L, 3));\n        assertEquals(6L, FieldUtils.safeMultiply(-2L, -3));\n        \n        assertEquals(-1L * Integer.MIN_VALUE, FieldUtils.safeMultiply(-1L, Integer.MIN_VALUE));\n        \n        assertEquals(Long.MAX_VALUE, FieldUtils.safeMultiply(Long.MAX_VALUE, 1));\n        assertEquals(Long.MIN_VALUE, FieldUtils.safeMultiply(Long.MIN_VALUE, 1));\n        assertEquals(-Long.MAX_VALUE, FieldUtils.safeMultiply(Long.MAX_VALUE, -1));\n        \n        try {\n            FieldUtils.safeMultiply(Long.MIN_VALUE, -1);\n            fail();\n        } catch (ArithmeticException e) {\n        }\n        \n        try {\n            FieldUtils.safeMultiply(Long.MIN_VALUE, 100);\n            fail();\n        } catch (ArithmeticException e) {\n        }\n        \n        try {\n            FieldUtils.safeMultiply(Long.MIN_VALUE, Integer.MAX_VALUE);\n            fail();\n        } catch (ArithmeticException e) {\n        }\n        \n        try {\n            FieldUtils.safeMultiply(Long.MAX_VALUE, Integer.MIN_VALUE);\n            fail();\n        } catch (ArithmeticException e) {\n        }\n    }\n"], "Lang_24": ["    public void testIsNumber() {\n        String val = \"12345\";\n        assertTrue(\"isNumber(String) 1 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 1 failed\", checkCreateNumber(val));\n        val = \"1234.5\";\n        assertTrue(\"isNumber(String) 2 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 2 failed\", checkCreateNumber(val));\n        val = \".12345\";\n        assertTrue(\"isNumber(String) 3 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 3 failed\", checkCreateNumber(val));\n        val = \"1234E5\";\n        assertTrue(\"isNumber(String) 4 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 4 failed\", checkCreateNumber(val));\n        val = \"1234E+5\";\n        assertTrue(\"isNumber(String) 5 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 5 failed\", checkCreateNumber(val));\n        val = \"1234E-5\";\n        assertTrue(\"isNumber(String) 6 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 6 failed\", checkCreateNumber(val));\n        val = \"123.4E5\";\n        assertTrue(\"isNumber(String) 7 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 7 failed\", checkCreateNumber(val));\n        val = \"-1234\";\n        assertTrue(\"isNumber(String) 8 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 8 failed\", checkCreateNumber(val));\n        val = \"-1234.5\";\n        assertTrue(\"isNumber(String) 9 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 9 failed\", checkCreateNumber(val));\n        val = \"-.12345\";\n        assertTrue(\"isNumber(String) 10 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 10 failed\", checkCreateNumber(val));\n        val = \"-1234E5\";\n        assertTrue(\"isNumber(String) 11 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 11 failed\", checkCreateNumber(val));\n        val = \"0\";\n        assertTrue(\"isNumber(String) 12 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 12 failed\", checkCreateNumber(val));\n        val = \"-0\";\n        assertTrue(\"isNumber(String) 13 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 13 failed\", checkCreateNumber(val));\n        val = \"01234\";\n        assertTrue(\"isNumber(String) 14 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 14 failed\", checkCreateNumber(val));\n        val = \"-01234\";\n        assertTrue(\"isNumber(String) 15 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 15 failed\", checkCreateNumber(val));\n        val = \"0xABC123\";\n        assertTrue(\"isNumber(String) 16 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 16 failed\", checkCreateNumber(val));\n        val = \"0x0\";\n        assertTrue(\"isNumber(String) 17 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 17 failed\", checkCreateNumber(val));\n        val = \"123.4E21D\";\n        assertTrue(\"isNumber(String) 19 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 19 failed\", checkCreateNumber(val));\n        val = \"-221.23F\";\n        assertTrue(\"isNumber(String) 20 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 20 failed\", checkCreateNumber(val));\n        val = \"22338L\";\n        assertTrue(\"isNumber(String) 21 failed\", NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 21 failed\", checkCreateNumber(val));\n        val = null;\n        assertTrue(\"isNumber(String) 1 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 1 Neg failed\", !checkCreateNumber(val));\n        val = \"\";\n        assertTrue(\"isNumber(String) 2 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 2 Neg failed\", !checkCreateNumber(val));\n        val = \"--2.3\";\n        assertTrue(\"isNumber(String) 3 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 3 Neg failed\", !checkCreateNumber(val));\n        val = \".12.3\";\n        assertTrue(\"isNumber(String) 4 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 4 Neg failed\", !checkCreateNumber(val));\n        val = \"-123E\";\n        assertTrue(\"isNumber(String) 5 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 5 Neg failed\", !checkCreateNumber(val));\n        val = \"-123E+-212\";\n        assertTrue(\"isNumber(String) 6 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 6 Neg failed\", !checkCreateNumber(val));\n        val = \"-123E2.12\";\n        assertTrue(\"isNumber(String) 7 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 7 Neg failed\", !checkCreateNumber(val));\n        val = \"0xGF\";\n        assertTrue(\"isNumber(String) 8 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 8 Neg failed\", !checkCreateNumber(val));\n        val = \"0xFAE-1\";\n        assertTrue(\"isNumber(String) 9 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 9 Neg failed\", !checkCreateNumber(val));\n        val = \".\";\n        assertTrue(\"isNumber(String) 10 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 10 Neg failed\", !checkCreateNumber(val));\n        val = \"-0ABC123\";\n        assertTrue(\"isNumber(String) 11 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 11 Neg failed\", !checkCreateNumber(val));\n        val = \"123.4E-D\";\n        assertTrue(\"isNumber(String) 12 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 12 Neg failed\", !checkCreateNumber(val));\n        val = \"123.4ED\";\n        assertTrue(\"isNumber(String) 13 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 13 Neg failed\", !checkCreateNumber(val));\n        val = \"1234E5l\";\n        assertTrue(\"isNumber(String) 14 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 14 Neg failed\", !checkCreateNumber(val));\n        val = \"11a\";\n        assertTrue(\"isNumber(String) 15 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 15 Neg failed\", !checkCreateNumber(val)); \n        val = \"1a\";\n        assertTrue(\"isNumber(String) 16 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 16 Neg failed\", !checkCreateNumber(val)); \n        val = \"a\";\n        assertTrue(\"isNumber(String) 17 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 17 Neg failed\", !checkCreateNumber(val)); \n        val = \"11g\";\n        assertTrue(\"isNumber(String) 18 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 18 Neg failed\", !checkCreateNumber(val)); \n        val = \"11z\";\n        assertTrue(\"isNumber(String) 19 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 19 Neg failed\", !checkCreateNumber(val)); \n        val = \"11def\";\n        assertTrue(\"isNumber(String) 20 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 20 Neg failed\", !checkCreateNumber(val)); \n        val = \"11d11\";\n        assertTrue(\"isNumber(String) 21 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 21 Neg failed\", !checkCreateNumber(val)); \n        val = \"11 11\";\n        assertTrue(\"isNumber(String) 22 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 22 Neg failed\", !checkCreateNumber(val));\n        val = \" 1111\";\n        assertTrue(\"isNumber(String) 23 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 23 Neg failed\", !checkCreateNumber(val));\n        val = \"1111 \";\n        assertTrue(\"isNumber(String) 24 Neg failed\", !NumberUtils.isNumber(val));\n        assertTrue(\"isNumber(String)/createNumber(String) 24 Neg failed\", !checkCreateNumber(val));\n\n        // LANG-521\n        val = \"2.\";\n        assertTrue(\"isNumber(String) LANG-521 failed\", NumberUtils.isNumber(val));\n\n        // LANG-664\n        val = \"1.1L\";\n        assertFalse(\"isNumber(String) LANG-664 failed\", NumberUtils.isNumber(val));\n    }\n"], "Time_12": ["    public void testFactory_fromCalendarFields_beforeYearZero1() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDateTime expected = new LocalDateTime(0, 2, 3, 4, 5, 6, 7);\n        assertEquals(expected, LocalDateTime.fromCalendarFields(cal));\n    }\n", "    public void testFactory_fromCalendarFields_beforeYearZero3() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDateTime expected = new LocalDateTime(-2, 2, 3, 4, 5, 6, 7);\n        assertEquals(expected, LocalDateTime.fromCalendarFields(cal));\n    }\n", "    public void testFactory_fromDateFields_beforeYearZero1() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDateTime expected = new LocalDateTime(0, 2, 3, 4, 5, 6, 7);\n        assertEquals(expected, LocalDateTime.fromDateFields(cal.getTime()));\n    }\n", "    public void testFactory_fromDateFields_beforeYearZero3() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDateTime expected = new LocalDateTime(-2, 2, 3, 4, 5, 6, 7);\n        assertEquals(expected, LocalDateTime.fromDateFields(cal.getTime()));\n    }\n", "    public void testFactory_fromCalendarFields_beforeYearZero1() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(0, 2, 3);\n        assertEquals(expected, LocalDate.fromCalendarFields(cal));\n    }\n", "    public void testFactory_fromCalendarFields_beforeYearZero3() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(-2, 2, 3);\n        assertEquals(expected, LocalDate.fromCalendarFields(cal));\n    }\n", "    public void testFactory_fromDateFields_beforeYearZero1() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(0, 2, 3);\n        assertEquals(expected, LocalDate.fromDateFields(cal.getTime()));\n    }\n", "    public void testFactory_fromDateFields_beforeYearZero3() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(-2, 2, 3);\n        assertEquals(expected, LocalDate.fromDateFields(cal.getTime()));\n    }\n"], "Closure_122": ["  public void testSuspiciousBlockCommentWarning3() {\n    parse(\"/* \\n *@type {number} */ var x = 3;\", SUSPICIOUS_COMMENT_WARNING);\n  }\n", "  public void testSuspiciousBlockCommentWarning4() {\n    parse(\n        \"  /*\\n\" +\n        \"   * @type {number}\\n\" +\n        \"   */\\n\" +\n        \"  var x = 3;\",\n        SUSPICIOUS_COMMENT_WARNING);\n  }\n", "  public void testSuspiciousBlockCommentWarning5() {\n    parse(\n        \"  /*\\n\" +\n        \"   * some random text here\\n\" +\n        \"   * @type {number}\\n\" +\n        \"   */\\n\" +\n        \"  var x = 3;\",\n        SUSPICIOUS_COMMENT_WARNING);\n  }\n"], "Closure_51": ["  public void testIssue582() {\n    assertPrint(\"var x = -0.0;\", \"var x=-0.0\");\n  }\n"], "Closure_32": ["  public void testIssue701() {\n    // Check ASCII art in license comments.\n    String ascii = \"/**\\n\" +\n        \" * @preserve\\n\" +\n        \"   This\\n\" +\n        \"     is\\n\" +\n        \"       ASCII    ART\\n\" +\n        \"*/\";\n    String result = \"/*\\n\\n\" +\n        \"   This\\n\" +\n        \"     is\\n\" +\n        \"       ASCII    ART\\n\" +\n        \"*/\\n\";\n    testSame(createCompilerOptions(), ascii);\n    assertEquals(result, lastCompiler.toSource());\n  }\n", "  public void testParsePreserve() throws Exception {\n    Node node = new Node(1);\n    this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode();\n    String comment = \"@preserve Foo\\nBar\\n\\nBaz*/\";\n    parse(comment);\n    assertEquals(\" Foo\\nBar\\n\\nBaz\", node.getJSDocInfo().getLicense());\n  }\n", "  public void testParseLicense() throws Exception {\n    Node node = new Node(1);\n    this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode();\n    String comment = \"@license Foo\\nBar\\n\\nBaz*/\";\n    parse(comment);\n    assertEquals(\" Foo\\nBar\\n\\nBaz\", node.getJSDocInfo().getLicense());\n  }\n", "  public void testParseLicenseAscii() throws Exception {\n    Node node = new Node(1);\n    this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode();\n    String comment = \"@license Foo\\n *   Bar\\n\\n  Baz*/\";\n    parse(comment);\n    assertEquals(\" Foo\\n   Bar\\n\\n  Baz\", node.getJSDocInfo().getLicense());\n  }\n", "  public void testParseLicenseWithAnnotation() throws Exception {\n    Node node = new Node(1);\n    this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode();\n    String comment = \"@license Foo \\n * @author Charlie Brown */\";\n    parse(comment);\n    assertEquals(\" Foo \\n @author Charlie Brown \",\n        node.getJSDocInfo().getLicense());\n  }\n"], "Lang_47": ["    public void testLang412Right() {\n        StrBuilder sb = new StrBuilder();\n        sb.appendFixedWidthPadRight(null, 10, '*');\n        assertEquals( \"Failed to invoke appendFixedWidthPadRight correctly\", \"**********\", sb.toString());\n    }\n", "    public void testLang412Left() {\n        StrBuilder sb = new StrBuilder();\n        sb.appendFixedWidthPadLeft(null, 10, '*');\n        assertEquals( \"Failed to invoke appendFixedWidthPadLeft correctly\", \"**********\", sb.toString());\n    }\n"], "Closure_35": ["  public void testIssue669() throws Exception {\n    testTypes(\n        \"/** @return {{prop1: (Object|undefined)}} */\" +\n         \"function f(a) {\" +\n         \"  var results;\" +\n         \"  if (a) {\" +\n         \"    results = {};\" +\n         \"    results.prop1 = {a: 3};\" +\n         \"  } else {\" +\n         \"    results = {prop2: 3};\" +\n         \"  }\" +\n         \"  return results;\" +\n         \"}\");\n  }\n"], "Lang_40": ["    public void testContainsIgnoreCase_LocaleIndependence() {\n        Locale orig = Locale.getDefault();\n\n        Locale[] locales = { Locale.ENGLISH, new Locale(\"tr\"), Locale.getDefault() };\n\n        String[][] tdata = { \n            { \"i\", \"I\" },\n            { \"I\", \"i\" },\n            { \"\\u03C2\", \"\\u03C3\" },\n            { \"\\u03A3\", \"\\u03C2\" },\n            { \"\\u03A3\", \"\\u03C3\" },\n        };\n\n        String[][] fdata = { \n            { \"\\u00DF\", \"SS\" },\n        };\n\n        try {\n            for (int i = 0; i < locales.length; i++) {\n                Locale.setDefault(locales[i]);\n                for (int j = 0; j < tdata.length; j++) {\n                    assertTrue(Locale.getDefault() + \": \" + j + \" \" + tdata[j][0] + \" \" + tdata[j][1], StringUtils\n                            .containsIgnoreCase(tdata[j][0], tdata[j][1]));\n                }\n                for (int j = 0; j < fdata.length; j++) {\n                    assertFalse(Locale.getDefault() + \": \" + j + \" \" + fdata[j][0] + \" \" + fdata[j][1], StringUtils\n                            .containsIgnoreCase(fdata[j][0], fdata[j][1]));\n                }\n            }\n        } finally {\n            Locale.setDefault(orig);\n        }\n    }\n"], "Lang_49": ["    public void testReducedFactory_int_int() {\n        Fraction f = null;\n        \n        // zero\n        f = Fraction.getReducedFraction(0, 1);\n        assertEquals(0, f.getNumerator());\n        assertEquals(1, f.getDenominator());\n        \n        // normal\n        f = Fraction.getReducedFraction(1, 1);\n        assertEquals(1, f.getNumerator());\n        assertEquals(1, f.getDenominator());\n        \n        f = Fraction.getReducedFraction(2, 1);\n        assertEquals(2, f.getNumerator());\n        assertEquals(1, f.getDenominator());\n        \n        // improper\n        f = Fraction.getReducedFraction(22, 7);\n        assertEquals(22, f.getNumerator());\n        assertEquals(7, f.getDenominator());\n        \n        // negatives\n        f = Fraction.getReducedFraction(-6, 10);\n        assertEquals(-3, f.getNumerator());\n        assertEquals(5, f.getDenominator());\n        \n        f = Fraction.getReducedFraction(6, -10);\n        assertEquals(-3, f.getNumerator());\n        assertEquals(5, f.getDenominator());\n        \n        f = Fraction.getReducedFraction(-6, -10);\n        assertEquals(3, f.getNumerator());\n        assertEquals(5, f.getDenominator());\n        \n        // zero denominator\n        try {\n            f = Fraction.getReducedFraction(1, 0);\n            fail(\"expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {}\n        \n        try {\n            f = Fraction.getReducedFraction(2, 0);\n            fail(\"expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {}\n        \n        try {\n            f = Fraction.getReducedFraction(-3, 0);\n            fail(\"expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {}\n\n        // reduced        \n        f = Fraction.getReducedFraction(0, 2);\n        assertEquals(0, f.getNumerator());\n        assertEquals(1, f.getDenominator());\n        \n        f = Fraction.getReducedFraction(2, 2);\n        assertEquals(1, f.getNumerator());\n        assertEquals(1, f.getDenominator());\n        \n        f = Fraction.getReducedFraction(2, 4);\n        assertEquals(1, f.getNumerator());\n        assertEquals(2, f.getDenominator());\n        \n        f = Fraction.getReducedFraction(15, 10);\n        assertEquals(3, f.getNumerator());\n        assertEquals(2, f.getDenominator());\n        \n        f = Fraction.getReducedFraction(121, 22);\n        assertEquals(11, f.getNumerator());\n        assertEquals(2, f.getDenominator());\n        \n        // Extreme values \n        // OK, can reduce before negating\n        f = Fraction.getReducedFraction(-2, Integer.MIN_VALUE);\n        assertEquals(1, f.getNumerator());\n        assertEquals(-(Integer.MIN_VALUE / 2), f.getDenominator());\n        \n        // Can't reduce, negation will throw\n        try { \n            f = Fraction.getReducedFraction(-7, Integer.MIN_VALUE);  \n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {}      \n    }\n", "    public void testReduce() {\n        Fraction f = null;\n        \n        f = Fraction.getFraction(50, 75);\n        Fraction result = f.reduce();\n        assertEquals(2, result.getNumerator());\n        assertEquals(3, result.getDenominator());\n\n        f = Fraction.getFraction(-2, -3);\n        result = f.reduce();\n        assertEquals(2, result.getNumerator());\n        assertEquals(3, result.getDenominator());\n\n        f = Fraction.getFraction(2, -3);\n        result = f.reduce();\n        assertEquals(-2, result.getNumerator());\n        assertEquals(3, result.getDenominator());\n\n        f = Fraction.getFraction(-2, 3);\n        result = f.reduce();\n        assertEquals(-2, result.getNumerator());\n        assertEquals(3, result.getDenominator());\n        assertSame(f, result);\n\n        f = Fraction.getFraction(2, 3);\n        result = f.reduce();\n        assertEquals(2, result.getNumerator());\n        assertEquals(3, result.getDenominator());\n        assertSame(f, result);\n\n        f = Fraction.getFraction(0, 1);\n        result = f.reduce();\n        assertEquals(0, result.getNumerator());\n        assertEquals(1, result.getDenominator());\n        assertSame(f, result);\n\n        f = Fraction.getFraction(0, 100);\n        result = f.reduce();\n        assertEquals(0, result.getNumerator());\n        assertEquals(1, result.getDenominator());\n        assertSame(result, Fraction.ZERO);\n    }\n"], "Closure_50": ["  public void testStringJoinAddSparse() {\n    fold(\"x = [,,'a'].join(',')\", \"x = ',,a'\");\n  }\n", "  public void testNoStringJoin() {\n    foldSame(\"x = [].join(',',2)\");\n    foldSame(\"x = [].join(f)\");\n  }\n", "  public void testStringJoinAdd() {\n    fold(\"x = ['a', 'b', 'c'].join('')\", \"x = \\\"abc\\\"\");\n    fold(\"x = [].join(',')\", \"x = \\\"\\\"\");\n    fold(\"x = ['a'].join(',')\", \"x = \\\"a\\\"\");\n    fold(\"x = ['a', 'b', 'c'].join(',')\", \"x = \\\"a,b,c\\\"\");\n    fold(\"x = ['a', foo, 'b', 'c'].join(',')\",\n        \"x = [\\\"a\\\",foo,\\\"b,c\\\"].join()\");\n    fold(\"x = [foo, 'a', 'b', 'c'].join(',')\",\n        \"x = [foo,\\\"a,b,c\\\"].join()\");\n    fold(\"x = ['a', 'b', 'c', foo].join(',')\",\n        \"x = [\\\"a,b,c\\\",foo].join()\");\n\n    // Works with numbers\n    fold(\"x = ['a=', 5].join('')\", \"x = \\\"a=5\\\"\");\n    fold(\"x = ['a', '5'].join(7)\", \"x = \\\"a75\\\"\");\n\n    // Works on boolean\n    fold(\"x = ['a=', false].join('')\", \"x = \\\"a=false\\\"\");\n    fold(\"x = ['a', '5'].join(true)\", \"x = \\\"atrue5\\\"\");\n    fold(\"x = ['a', '5'].join(false)\", \"x = \\\"afalse5\\\"\");\n\n    // Only optimize if it's a size win.\n    fold(\"x = ['a', '5', 'c'].join('a very very very long chain')\",\n         \"x = [\\\"a\\\",\\\"5\\\",\\\"c\\\"].join(\\\"a very very very long chain\\\")\");\n\n    // TODO(user): Its possible to fold this better.\n    foldSame(\"x = ['', foo].join('-')\");\n    foldSame(\"x = ['', foo, ''].join()\");\n\n    fold(\"x = ['', '', foo, ''].join(',')\",\n         \"x = [',', foo, ''].join()\");\n    fold(\"x = ['', '', foo, '', ''].join(',')\",\n         \"x = [',', foo, ','].join()\");\n\n    fold(\"x = ['', '', foo, '', '', bar].join(',')\",\n         \"x = [',', foo, ',', bar].join()\");\n\n    fold(\"x = [1,2,3].join('abcdef')\",\n         \"x = '1abcdef2abcdef3'\");\n\n    fold(\"x = [1,2].join()\", \"x = '1,2'\");\n    fold(\"x = [null,undefined,''].join(',')\", \"x = ',,'\");\n    fold(\"x = [null,undefined,0].join(',')\", \"x = ',,0'\");\n    // This can be folded but we don't currently.\n    foldSame(\"x = [[1,2],[3,4]].join()\"); // would like: \"x = '1,2,3,4'\"\n  }\n", "  public void testStringJoinAdd_b1992789() {\n    fold(\"x = ['a'].join('')\", \"x = \\\"a\\\"\");\n    fold(\"x = [foo()].join('')\", \"x = '' + foo()\");\n    fold(\"[foo()].join('')\", \"'' + foo()\");\n  }\n"], "Time_13": ["    public void testFormatStandard_negative() {\n        Period p = new Period(-1, -2, -3, -4, -5, -6, -7, -8);\n        assertEquals(\"P-1Y-2M-3W-4DT-5H-6M-7.008S\", ISOPeriodFormat.standard().print(p));\n        \n        p = Period.years(-54);\n        assertEquals(\"P-54Y\", ISOPeriodFormat.standard().print(p));\n        \n        p = Period.seconds(4).withMillis(-8);\n        assertEquals(\"PT3.992S\", ISOPeriodFormat.standard().print(p));\n        \n        p = Period.seconds(-4).withMillis(8);\n        assertEquals(\"PT-3.992S\", ISOPeriodFormat.standard().print(p));\n        \n        p = Period.seconds(-23);\n        assertEquals(\"PT-23S\", ISOPeriodFormat.standard().print(p));\n        \n        p = Period.millis(-8);\n        assertEquals(\"PT-0.008S\", ISOPeriodFormat.standard().print(p));\n    }\n"], "Closure_123": ["  public void testPrintInOperatorInForLoop() {\n    // Check for in expression in for's init expression.\n    // Check alone, with + (higher precedence), with ?: (lower precedence),\n    // and with conditional.\n    assertPrint(\"var a={}; for (var i = (\\\"length\\\" in a); i;) {}\",\n        \"var a={};for(var i=(\\\"length\\\"in a);i;);\");\n    assertPrint(\"var a={}; for (var i = (\\\"length\\\" in a) ? 0 : 1; i;) {}\",\n        \"var a={};for(var i=(\\\"length\\\"in a)?0:1;i;);\");\n    assertPrint(\"var a={}; for (var i = (\\\"length\\\" in a) + 1; i;) {}\",\n        \"var a={};for(var i=(\\\"length\\\"in a)+1;i;);\");\n    assertPrint(\"var a={};for (var i = (\\\"length\\\" in a|| \\\"size\\\" in a);;);\",\n        \"var a={};for(var i=(\\\"length\\\"in a)||(\\\"size\\\"in a);;);\");\n    assertPrint(\"var a={};for (var i = a || a || (\\\"size\\\" in a);;);\",\n        \"var a={};for(var i=a||a||(\\\"size\\\"in a);;);\");\n\n    // Test works with unary operators and calls.\n    assertPrint(\"var a={}; for (var i = -(\\\"length\\\" in a); i;) {}\",\n        \"var a={};for(var i=-(\\\"length\\\"in a);i;);\");\n    assertPrint(\"var a={};function b_(p){ return p;};\" +\n        \"for(var i=1,j=b_(\\\"length\\\" in a);;) {}\",\n        \"var a={};function b_(p){return p}\" +\n            \"for(var i=1,j=b_(\\\"length\\\"in a);;);\");\n\n    // Test we correctly handle an in operator in the test clause.\n    assertPrint(\"var a={}; for (;(\\\"length\\\" in a);) {}\",\n        \"var a={};for(;\\\"length\\\"in a;);\");\n\n    // Test we correctly handle an in operator inside a comma.\n    assertPrintSame(\"for(x,(y in z);;)foo()\");\n    assertPrintSame(\"for(var x,w=(y in z);;)foo()\");\n\n    // And in operator inside a hook.\n    assertPrintSame(\"for(a=c?0:(0 in d);;)foo()\");\n  }\n"], "Lang_22": ["    public void testReducedFactory_int_int() {\n        Fraction f = null;\n        \n        // zero\n        f = Fraction.getReducedFraction(0, 1);\n        assertEquals(0, f.getNumerator());\n        assertEquals(1, f.getDenominator());\n        \n        // normal\n        f = Fraction.getReducedFraction(1, 1);\n        assertEquals(1, f.getNumerator());\n        assertEquals(1, f.getDenominator());\n        \n        f = Fraction.getReducedFraction(2, 1);\n        assertEquals(2, f.getNumerator());\n        assertEquals(1, f.getDenominator());\n        \n        // improper\n        f = Fraction.getReducedFraction(22, 7);\n        assertEquals(22, f.getNumerator());\n        assertEquals(7, f.getDenominator());\n        \n        // negatives\n        f = Fraction.getReducedFraction(-6, 10);\n        assertEquals(-3, f.getNumerator());\n        assertEquals(5, f.getDenominator());\n        \n        f = Fraction.getReducedFraction(6, -10);\n        assertEquals(-3, f.getNumerator());\n        assertEquals(5, f.getDenominator());\n        \n        f = Fraction.getReducedFraction(-6, -10);\n        assertEquals(3, f.getNumerator());\n        assertEquals(5, f.getDenominator());\n        \n        // zero denominator\n        try {\n            f = Fraction.getReducedFraction(1, 0);\n            fail(\"expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {}\n        \n        try {\n            f = Fraction.getReducedFraction(2, 0);\n            fail(\"expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {}\n        \n        try {\n            f = Fraction.getReducedFraction(-3, 0);\n            fail(\"expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {}\n\n        // reduced        \n        f = Fraction.getReducedFraction(0, 2);\n        assertEquals(0, f.getNumerator());\n        assertEquals(1, f.getDenominator());\n        \n        f = Fraction.getReducedFraction(2, 2);\n        assertEquals(1, f.getNumerator());\n        assertEquals(1, f.getDenominator());\n        \n        f = Fraction.getReducedFraction(2, 4);\n        assertEquals(1, f.getNumerator());\n        assertEquals(2, f.getDenominator());\n        \n        f = Fraction.getReducedFraction(15, 10);\n        assertEquals(3, f.getNumerator());\n        assertEquals(2, f.getDenominator());\n        \n        f = Fraction.getReducedFraction(121, 22);\n        assertEquals(11, f.getNumerator());\n        assertEquals(2, f.getDenominator());\n        \n        // Extreme values \n        // OK, can reduce before negating\n        f = Fraction.getReducedFraction(-2, Integer.MIN_VALUE);\n        assertEquals(1, f.getNumerator());\n        assertEquals(-(Integer.MIN_VALUE / 2), f.getDenominator());\n        \n        // Can't reduce, negation will throw\n        try { \n            f = Fraction.getReducedFraction(-7, Integer.MIN_VALUE);  \n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {}      \n\n        // LANG-662\n        f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2);\n        assertEquals(Integer.MIN_VALUE / 2, f.getNumerator());\n        assertEquals(1, f.getDenominator());\n    }\n", "    public void testReduce() {\n        Fraction f = null;\n        \n        f = Fraction.getFraction(50, 75);\n        Fraction result = f.reduce();\n        assertEquals(2, result.getNumerator());\n        assertEquals(3, result.getDenominator());\n\n        f = Fraction.getFraction(-2, -3);\n        result = f.reduce();\n        assertEquals(2, result.getNumerator());\n        assertEquals(3, result.getDenominator());\n\n        f = Fraction.getFraction(2, -3);\n        result = f.reduce();\n        assertEquals(-2, result.getNumerator());\n        assertEquals(3, result.getDenominator());\n\n        f = Fraction.getFraction(-2, 3);\n        result = f.reduce();\n        assertEquals(-2, result.getNumerator());\n        assertEquals(3, result.getDenominator());\n        assertSame(f, result);\n\n        f = Fraction.getFraction(2, 3);\n        result = f.reduce();\n        assertEquals(2, result.getNumerator());\n        assertEquals(3, result.getDenominator());\n        assertSame(f, result);\n\n        f = Fraction.getFraction(0, 1);\n        result = f.reduce();\n        assertEquals(0, result.getNumerator());\n        assertEquals(1, result.getDenominator());\n        assertSame(f, result);\n\n        f = Fraction.getFraction(0, 100);\n        result = f.reduce();\n        assertEquals(0, result.getNumerator());\n        assertEquals(1, result.getDenominator());\n        assertSame(result, Fraction.ZERO);\n\n        f = Fraction.getFraction(Integer.MIN_VALUE, 2);\n        result = f.reduce();\n        assertEquals(Integer.MIN_VALUE / 2, result.getNumerator());\n        assertEquals(1, result.getDenominator());\n    }\n"], "Closure_68": ["  public void testIssue477() throws Exception {\n    parse(\"@type function */\",\n        \"Bad type annotation. missing opening (\");\n  }\n"], "Closure_124": ["  public void testIssue1017() {\n    testSame(\"x = x.parentNode.parentNode; x = x.parentNode.parentNode;\");\n  }\n"], "Time_14": ["    public void testPlusMonths_int_fromLeap() {\n        MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC());\n        MonthDay result = test.plusMonths(1);\n        MonthDay expected = new MonthDay(3, 29, ISOChronology.getInstance());\n        assertEquals(expected, result);\n    }\n", "    public void testPlusMonths_int_negativeFromLeap() {\n        MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC());\n        MonthDay result = test.plusMonths(-1);\n        MonthDay expected = new MonthDay(1, 29, ISOChronology.getInstance());\n        assertEquals(expected, result);\n    }\n", "    public void testPlusMonths_int_negativeEndOfMonthAdjust() {\n        MonthDay test = new MonthDay(3, 31, ISOChronology.getInstanceUTC());\n        MonthDay result = test.plusMonths(-1);\n        MonthDay expected = new MonthDay(2, 29, ISOChronology.getInstance());\n        assertEquals(expected, result);\n    }\n", "    public void testPlusDays_int_fromLeap() {\n        MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC());\n        MonthDay result = test.plusDays(1);\n        MonthDay expected = new MonthDay(3, 1, ISOChronology.getInstance());\n        assertEquals(expected, result);\n    }\n", "    public void testMinusMonths_int_fromLeap() {\n        MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC());\n        MonthDay result = test.minusMonths(1);\n        MonthDay expected = new MonthDay(1, 29, ISOChronology.getInstance());\n        assertEquals(expected, result);\n    }\n", "    public void testMinusMonths_int_negativeFromLeap() {\n        MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC());\n        MonthDay result = test.minusMonths(-1);\n        MonthDay expected = new MonthDay(3, 29, ISOChronology.getInstance());\n        assertEquals(expected, result);\n    }\n", "    public void testMinusMonths_int_endOfMonthAdjust() {\n        MonthDay test = new MonthDay(3, 31, ISOChronology.getInstanceUTC());\n        MonthDay result = test.minusMonths(1);\n        MonthDay expected = new MonthDay(2, 29, ISOChronology.getInstance());\n        assertEquals(expected, result);\n    }\n", "    public void testMinusDays_int_negativeFromLeap() {\n        MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC());\n        MonthDay result = test.minusDays(-1);\n        MonthDay expected = new MonthDay(3, 1, ISOChronology.getInstance());\n        assertEquals(expected, result);\n    }\n"], "Closure_57": ["  public void testRequire() {\n    assertRequire(\"goog.require('foo')\");\n    assertNotRequire(\"goog.require(foo)\");\n    assertNotRequire(\"goog.require()\");\n    assertNotRequire(\"foo()\");\n  }\n"], "Lang_14": ["    public void testEquals() {\n        final CharSequence fooCs = FOO, barCs = BAR, foobarCs = FOOBAR;\n        assertTrue(StringUtils.equals(null, null));\n        assertTrue(StringUtils.equals(fooCs, fooCs));\n        assertTrue(StringUtils.equals(fooCs, (CharSequence) new StringBuilder(FOO)));\n        assertTrue(StringUtils.equals(fooCs, (CharSequence) new String(new char[] { 'f', 'o', 'o' })));\n        assertTrue(StringUtils.equals(fooCs, (CharSequence) new CustomCharSequence(FOO)));\n        assertTrue(StringUtils.equals((CharSequence) new CustomCharSequence(FOO), fooCs));\n        assertFalse(StringUtils.equals(fooCs, (CharSequence) new String(new char[] { 'f', 'O', 'O' })));\n        assertFalse(StringUtils.equals(fooCs, barCs));\n        assertFalse(StringUtils.equals(fooCs, null));\n        assertFalse(StringUtils.equals(null, fooCs));\n        assertFalse(StringUtils.equals(fooCs, foobarCs));\n        assertFalse(StringUtils.equals(foobarCs, fooCs));\n    }\n", "    public void testEqualsOnStrings() {\n        assertTrue(StringUtils.equals(null, null));\n        assertTrue(StringUtils.equals(FOO, FOO));\n        assertTrue(StringUtils.equals(FOO, new String(new char[] { 'f', 'o', 'o' })));\n        assertFalse(StringUtils.equals(FOO, new String(new char[] { 'f', 'O', 'O' })));\n        assertFalse(StringUtils.equals(FOO, BAR));\n        assertFalse(StringUtils.equals(FOO, null));\n        assertFalse(StringUtils.equals(null, FOO));\n        assertFalse(StringUtils.equals(FOO, FOOBAR));\n        assertFalse(StringUtils.equals(FOOBAR, FOO));\n    }\n", "    public void testEqualsIgnoreCase() {\n        assertEquals(true, StringUtils.equalsIgnoreCase(null, null));\n        assertEquals(true, StringUtils.equalsIgnoreCase(FOO, FOO));\n        assertEquals(true, StringUtils.equalsIgnoreCase(FOO, new String(new char[] { 'f', 'o', 'o' })));\n        assertEquals(true, StringUtils.equalsIgnoreCase(FOO, new String(new char[] { 'f', 'O', 'O' })));\n        assertEquals(false, StringUtils.equalsIgnoreCase(FOO, BAR));\n        assertEquals(false, StringUtils.equalsIgnoreCase(FOO, null));\n        assertEquals(false, StringUtils.equalsIgnoreCase(null, FOO));\n    }\n"], "Time_22": ["    public void testToPeriod_fixedZone() throws Throwable {\n        DateTimeZone zone = DateTimeZone.getDefault();\n        try {\n            DateTimeZone.setDefault(DateTimeZone.forOffsetHours(2));\n            long length =\n                (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n                5L * DateTimeConstants.MILLIS_PER_HOUR +\n                6L * DateTimeConstants.MILLIS_PER_MINUTE +\n                7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n            Duration dur = new Duration(length);\n            Period test = dur.toPeriod();\n            assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450\n            assertEquals(0, test.getMonths());\n            assertEquals(0, test.getWeeks());\n            assertEquals(0, test.getDays());\n            assertEquals((450 * 24) + 5, test.getHours());\n            assertEquals(6, test.getMinutes());\n            assertEquals(7, test.getSeconds());\n            assertEquals(8, test.getMillis());\n        } finally {\n            DateTimeZone.setDefault(zone);\n        }\n    }\n", "    public void testConstructor_long_fixedZone() throws Throwable {\n        DateTimeZone zone = DateTimeZone.getDefault();\n        try {\n            DateTimeZone.setDefault(DateTimeZone.forOffsetHours(2));\n            long length =\n                (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n                5L * DateTimeConstants.MILLIS_PER_HOUR +\n                6L * DateTimeConstants.MILLIS_PER_MINUTE +\n                7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n            Period test = new Period(length);\n            assertEquals(PeriodType.standard(), test.getPeriodType());\n            // only time fields are precise in AllType\n            assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450\n            assertEquals(0, test.getMonths());\n            assertEquals(0, test.getWeeks());\n            assertEquals(0, test.getDays());\n            assertEquals((450 * 24) + 5, test.getHours());\n            assertEquals(6, test.getMinutes());\n            assertEquals(7, test.getSeconds());\n            assertEquals(8, test.getMillis());\n        } finally {\n            DateTimeZone.setDefault(zone);\n        }\n    }\n"], "Closure_112": ["  public void testTemplatized11() throws Exception {\n    testTypes(\n        \"/** \\n\" +\n        \" * @template T\\n\" +\n        \" * @constructor\\n\" +\n        \" */\\n\" +\n        \"function C() {}\\n\" +\n        \"\\n\" +\n        \"/**\\n\" +\n        \" * @param {T|K} a\\n\" +\n        \" * @return {T}\\n\" +\n        \" * @template K\\n\" +\n        \" */\\n\" +\n        \"C.prototype.method = function (a) {};\\n\" +\n        \"\\n\" +\n        // method returns \"?\"\n        \"/** @type {void} */ var x = new C().method(1);\");\n  }\n", "  public void testIssue1058() throws Exception {\n    testTypes(\n        \"/**\\n\" +\n        \"  * @constructor\\n\" +\n        \"  * @template CLASS\\n\" +\n        \"  */\\n\" +\n        \"var Class = function() {};\\n\" +\n        \"\\n\" +\n        \"/**\\n\" +\n        \"  * @param {function(CLASS):CLASS} a\\n\" +\n        \"  * @template T\\n\" +\n        \"  */\\n\" +\n        \"Class.prototype.foo = function(a) {\\n\" +\n        \"  return 'string';\\n\" +\n        \"};\\n\" +\n        \"\\n\" +\n        \"/** @param {number} a\\n\" +\n        \"  * @return {string} */\\n\" +\n        \"var a = function(a) { return '' };\\n\" +\n        \"\\n\" +\n        \"new Class().foo(a);\");\n  }\n"], "Closure_95": ["  public void testQualifiedNameInference5() throws Exception {\n    testTypes(\n        \"var ns = {}; \" +\n        \"(function() { \" +\n        \"    /** @param {number} x */ ns.foo = function(x) {}; })();\" +\n        \"(function() { ns.foo(true); })();\",\n        \"actual parameter 1 of ns.foo does not match formal parameter\\n\" +\n        \"found   : boolean\\n\" +\n        \"required: number\");\n  }\n", "  public void testGlobalQualifiedNameInLocalScope() {\n    testSame(\n        \"var ns = {}; \" +\n        \"(function() { \" +\n        \"    /** @param {number} x */ ns.foo = function(x) {}; })();\" +\n        \"(function() { ns.foo(3); })();\");\n    assertNotNull(globalScope.getVar(\"ns.foo\"));\n    assertEquals(\n        \"function (number): undefined\",\n        globalScope.getVar(\"ns.foo\").getType().toString());\n  }\n"], "Closure_61": ["  public void testRemoveUselessOps() {\n    // There are four place where expression results are discarded:\n    //  - a top level expression EXPR_RESULT\n    //  - the LHS of a COMMA\n    //  - the FOR init expression\n    //  - the FOR increment expression\n\n\n    // Known side-effect free functions calls are removed.\n    fold(\"Math.random()\", \"\");\n    fold(\"Math.random(f() + g())\", \"f(),g();\");\n    fold(\"Math.random(f(),g(),h())\", \"f(),g(),h();\");\n\n    // Calls to functions with unknown side-effects are are left.\n    foldSame(\"f();\");\n    foldSame(\"(function () {})();\");\n\n    // Uncalled function expressions are removed\n    fold(\"(function () {});\", \"\");\n    fold(\"(function f() {});\", \"\");\n    // ... including any code they contain.\n    fold(\"(function () {foo();});\", \"\");\n\n    // Useless operators are removed.\n    fold(\"+f()\", \"f()\");\n    fold(\"a=(+f(),g())\", \"a=(f(),g())\");\n    fold(\"a=(true,g())\", \"a=g()\");\n    fold(\"f(),true\", \"f()\");\n    fold(\"f() + g()\", \"f(),g()\");\n\n    fold(\"for(;;+f()){}\", \"for(;;f()){}\");\n    fold(\"for(+f();;g()){}\", \"for(f();;g()){}\");\n    fold(\"for(;;Math.random(f(),g(),h())){}\", \"for(;;f(),g(),h()){}\");\n\n    // The optimization cascades into conditional expressions:\n    fold(\"g() && +f()\", \"g() && f()\");\n    fold(\"g() || +f()\", \"g() || f()\");\n    fold(\"x ? g() : +f()\", \"x ? g() : f()\");\n\n    fold(\"+x()\", \"x()\");\n    fold(\"+x() * 2\", \"x()\");\n    fold(\"-(+x() * 2)\", \"x()\");\n    fold(\"2 -(+x() * 2)\", \"x()\");\n    fold(\"x().foo\", \"x()\");\n    foldSame(\"x().foo()\");\n\n    foldSame(\"x++\");\n    foldSame(\"++x\");\n    foldSame(\"x--\");\n    foldSame(\"--x\");\n    foldSame(\"x = 2\");\n    foldSame(\"x *= 2\");\n\n    // Sanity check, other expression are left alone.\n    foldSame(\"function f() {}\");\n    foldSame(\"var x;\");\n  }\n", "  public void testCall1() {\n    test(\"Math.sin(0);\", \"\");\n  }\n", "  public void testCall2() {\n    test(\"1 + Math.sin(0);\", \"\");\n  }\n"], "Closure_59": ["  public void testCheckGlobalThisOffByDefault() {\n    testSame(\"function f() { this.a = 3; }\");\n  }\n", "  public void testCheckGlobalThisOff() {\n    args.add(\"--warning_level=VERBOSE\");\n    args.add(\"--jscomp_off=globalThis\");\n    testSame(\"function f() { this.a = 3; }\");\n  }\n"], "Lang_13": ["    public void testPrimitiveTypeClassSerialization() {\n        Class<?>[] primitiveTypes = { byte.class, short.class, int.class, long.class, float.class, double.class,\n                boolean.class, char.class, void.class };\n\n        for (Class<?> primitiveType : primitiveTypes) {\n            Class<?> clone = SerializationUtils.clone(primitiveType);\n            assertEquals(primitiveType, clone);\n        }\n    }\n"], "Closure_66": ["  public void testGetTypedPercent5() throws Exception {\n    String js = \"/** @enum {number} */ keys = {A: 1,B: 2,C: 3};\";\n    assertEquals(100.0, getTypedPercent(js), 0.1);\n  }\n", "  public void testGetTypedPercent6() throws Exception {\n    String js = \"a = {TRUE: 1, FALSE: 0};\";\n    assertEquals(100.0, getTypedPercent(js), 0.1);\n  }\n"], "Closure_115": ["  public void testInlineFunctions6() {\n    // more complex inlines\n    test(\"function BAR_FN(x, y, z) { return z(foo(x + y)) }\" +\n         \"alert(BAR_FN(1, 2, baz))\",\n\n         \"alert(baz(foo(1+2)))\");\n  }\n", "  public void testNoInlineIfParametersModified8() {\n    // OK, object parameter modified.\n    test(\"function f(a){return a.x=2}f(o)\", \"o.x=2\");\n  }\n", "  public void testNoInlineIfParametersModified9() {\n    // OK, array parameter modified.\n    test(\"function f(a){return a[2]=2}f(o)\", \"o[2]=2\");\n  }\n", "  public void testDoubleInlining1() {\n    allowBlockInlining = false;\n    test(\"var foo = function(a) { return getWindow(a); };\" +\n         \"var bar = function(b) { return b; };\" +\n         \"foo(bar(x));\",\n         \"getWindow(x)\");\n  }\n", "  public void testBug4944818() {\n    test(\n        \"var getDomServices_ = function(self) {\\n\" +\n        \"  if (!self.domServices_) {\\n\" +\n        \"    self.domServices_ = goog$component$DomServices.get(\" +\n        \"        self.appContext_);\\n\" +\n        \"  }\\n\" +\n        \"\\n\" +\n        \"  return self.domServices_;\\n\" +\n        \"};\\n\" +\n        \"\\n\" +\n        \"var getOwnerWin_ = function(self) {\\n\" +\n        \"  return getDomServices_(self).getDomHelper().getWindow();\\n\" +\n        \"};\\n\" +\n        \"\\n\" +\n        \"HangoutStarter.prototype.launchHangout = function() {\\n\" +\n        \"  var self = a.b;\\n\" +\n        \"  var myUrl = new goog.Uri(getOwnerWin_(self).location.href);\\n\" +\n        \"};\",\n        \"HangoutStarter.prototype.launchHangout = function() { \" +\n        \"  var self$$2 = a.b;\" +\n        \"  var JSCompiler_temp_const$$0 = goog.Uri;\" +\n        \"  var JSCompiler_inline_result$$1;\" +\n        \"  {\" +\n        \"  var self$$inline_2 = self$$2;\" +\n        \"  if (!self$$inline_2.domServices_) {\" +\n        \"    self$$inline_2.domServices_ = goog$component$DomServices.get(\" +\n        \"        self$$inline_2.appContext_);\" +\n        \"  }\" +\n        \"  JSCompiler_inline_result$$1=self$$inline_2.domServices_;\" +\n        \"  }\" +\n        \"  var myUrl = new JSCompiler_temp_const$$0(\" +\n        \"      JSCompiler_inline_result$$1.getDomHelper().\" +\n        \"          getWindow().location.href)\" +\n        \"}\");\n  }\n"], "Closure_92": ["  public void testProvideInIndependentModules4() {\n    // Regression test for bug 261:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=261\n    test(\n        createModuleStar(\n            \"goog.provide('apps');\",\n            \"goog.provide('apps.foo.bar.B');\",\n            \"goog.provide('apps.foo.bar.C');\"),\n        new String[] {\n            \"var apps = {};apps.foo = {};apps.foo.bar = {}\",\n            \"apps.foo.bar.B = {};\",\n            \"apps.foo.bar.C = {};\",\n        });\n  }\n"], "Time_25": ["    public void test_getOffsetFromLocal_Moscow_Autumn() {\n        doTest_getOffsetFromLocal(10, 28, 0, 0, \"2007-10-28T00:00:00.000+04:00\", ZONE_MOSCOW);\n        doTest_getOffsetFromLocal(10, 28, 0,30, \"2007-10-28T00:30:00.000+04:00\", ZONE_MOSCOW);\n        doTest_getOffsetFromLocal(10, 28, 1, 0, \"2007-10-28T01:00:00.000+04:00\", ZONE_MOSCOW);\n        doTest_getOffsetFromLocal(10, 28, 1,30, \"2007-10-28T01:30:00.000+04:00\", ZONE_MOSCOW);\n        \n        doTest_getOffsetFromLocal(10, 28, 2, 0, \"2007-10-28T02:00:00.000+04:00\", ZONE_MOSCOW);\n        doTest_getOffsetFromLocal(10, 28, 2,30, \"2007-10-28T02:30:00.000+04:00\", ZONE_MOSCOW);\n        doTest_getOffsetFromLocal(10, 28, 2,30,59,999, \"2007-10-28T02:30:59.999+04:00\", ZONE_MOSCOW);\n        doTest_getOffsetFromLocal(10, 28, 2,59,59,998, \"2007-10-28T02:59:59.998+04:00\", ZONE_MOSCOW);\n        doTest_getOffsetFromLocal(10, 28, 2,59,59,999, \"2007-10-28T02:59:59.999+04:00\", ZONE_MOSCOW);\n        \n        doTest_getOffsetFromLocal(10, 28, 3, 0, \"2007-10-28T03:00:00.000+03:00\", ZONE_MOSCOW);\n        doTest_getOffsetFromLocal(10, 28, 3,30, \"2007-10-28T03:30:00.000+03:00\", ZONE_MOSCOW);\n        doTest_getOffsetFromLocal(10, 28, 4, 0, \"2007-10-28T04:00:00.000+03:00\", ZONE_MOSCOW);\n        doTest_getOffsetFromLocal(10, 28, 5, 0, \"2007-10-28T05:00:00.000+03:00\", ZONE_MOSCOW);\n        doTest_getOffsetFromLocal(10, 28, 6, 0, \"2007-10-28T06:00:00.000+03:00\", ZONE_MOSCOW);\n        doTest_getOffsetFromLocal(10, 28, 7, 0, \"2007-10-28T07:00:00.000+03:00\", ZONE_MOSCOW);\n        doTest_getOffsetFromLocal(10, 28, 8, 0, \"2007-10-28T08:00:00.000+03:00\", ZONE_MOSCOW);\n    }\n", "    public void test_getOffsetFromLocal_Moscow_Autumn_overlap_mins() {\n        for (int min = 0; min < 60; min++) {\n            if (min < 10) {\n                doTest_getOffsetFromLocal(10, 28, 2, min, \"2007-10-28T02:0\" + min + \":00.000+04:00\", ZONE_MOSCOW);\n            } else {\n                doTest_getOffsetFromLocal(10, 28, 2, min, \"2007-10-28T02:\" + min + \":00.000+04:00\", ZONE_MOSCOW);\n            }\n        }\n    }\n", "    public void test_DateTime_constructor_Moscow_Autumn() {\n        DateTime dt = new DateTime(2007, 10, 28, 2, 30, ZONE_MOSCOW);\n        assertEquals(\"2007-10-28T02:30:00.000+04:00\", dt.toString());\n    }\n"], "Math_32": ["    @Test\n    public void testIssue780() {\n        float[] coords = {\n            1.000000f, -1.000000f, -1.000000f, \n            1.000000f, -1.000000f, 1.000000f, \n            -1.000000f, -1.000000f, 1.000000f, \n            -1.000000f, -1.000000f, -1.000000f, \n            1.000000f, 1.000000f, -1f, \n            0.999999f, 1.000000f, 1.000000f,   // 1.000000f, 1.000000f, 1.000000f, \n            -1.000000f, 1.000000f, 1.000000f, \n            -1.000000f, 1.000000f, -1.000000f};\n        int[] indices = {\n            0, 1, 2, 0, 2, 3, \n            4, 7, 6, 4, 6, 5, \n            0, 4, 5, 0, 5, 1, \n            1, 5, 6, 1, 6, 2, \n            2, 6, 7, 2, 7, 3, \n            4, 0, 3, 4, 3, 7};\n        ArrayList<SubHyperplane<Euclidean3D>> subHyperplaneList = new ArrayList<SubHyperplane<Euclidean3D>>();\n        for (int idx = 0; idx < indices.length; idx += 3) {\n            int idxA = indices[idx] * 3;\n            int idxB = indices[idx + 1] * 3;\n            int idxC = indices[idx + 2] * 3;\n            Vector3D v_1 = new Vector3D(coords[idxA], coords[idxA + 1], coords[idxA + 2]);\n            Vector3D v_2 = new Vector3D(coords[idxB], coords[idxB + 1], coords[idxB + 2]);\n            Vector3D v_3 = new Vector3D(coords[idxC], coords[idxC + 1], coords[idxC + 2]);\n            Vector3D[] vertices = {v_1, v_2, v_3};\n            Plane polyPlane = new Plane(v_1, v_2, v_3);\n            ArrayList<SubHyperplane<Euclidean2D>> lines = new ArrayList<SubHyperplane<Euclidean2D>>();\n\n            Vector2D[] projPts = new Vector2D[vertices.length];\n            for (int ptIdx = 0; ptIdx < projPts.length; ptIdx++) {\n                projPts[ptIdx] = polyPlane.toSubSpace(vertices[ptIdx]);\n            }\n\n            SubLine lineInPlane = null;\n            for (int ptIdx = 0; ptIdx < projPts.length; ptIdx++) {\n                lineInPlane = new SubLine(projPts[ptIdx], projPts[(ptIdx + 1) % projPts.length]);\n                lines.add(lineInPlane);\n            }\n            Region<Euclidean2D> polyRegion = new PolygonsSet(lines);\n            SubPlane polygon = new SubPlane(polyPlane, polyRegion);\n            subHyperplaneList.add(polygon);\n        }\n        PolyhedronsSet polyhedronsSet = new PolyhedronsSet(subHyperplaneList);\n        Assert.assertEquals( 8.0, polyhedronsSet.getSize(), 3.0e-6);\n        Assert.assertEquals(24.0, polyhedronsSet.getBoundarySize(), 5.0e-6);\n    }\n"], "Math_35": ["    @Test(expected = OutOfRangeException.class)\n    public void testConstructorTooLow() {\n        final double rate = -0.25;\n        new ElitisticListPopulation(100, rate);\n    }\n", "    @Test(expected = OutOfRangeException.class)\n    public void testConstructorTooHigh() {\n        final double rate = 1.25;\n        new ElitisticListPopulation(100, rate);\n    }\n", "    @Test(expected = OutOfRangeException.class)\n    public void testChromosomeListConstructorTooLow() {\n        final List<Chromosome> chromosomes = Collections.emptyList();\n        final double rate = -0.25;\n        new ElitisticListPopulation(chromosomes, 100, rate);\n    }\n", "    @Test(expected = OutOfRangeException.class)\n    public void testChromosomeListConstructorTooHigh() {\n        final List<Chromosome> chromosomes = Collections.emptyList();\n        final double rate = 1.25;\n        new ElitisticListPopulation(chromosomes, 100, rate);\n    }\n"], "Math_95": ["    public void testSmallDegreesOfFreedom() throws Exception {\n        org.apache.commons.math.distribution.FDistributionImpl fd =\n            new org.apache.commons.math.distribution.FDistributionImpl(\n                1.0, 1.0);\n        double p = fd.cumulativeProbability(0.975);\n        double x = fd.inverseCumulativeProbability(p);\n        assertEquals(0.975, x, 1.0e-5);\n\n        fd.setDenominatorDegreesOfFreedom(2.0);\n        p = fd.cumulativeProbability(0.975);\n        x = fd.inverseCumulativeProbability(p);\n        assertEquals(0.975, x, 1.0e-5);\n    }\n"], "Math_61": ["    public void testMean() {\n        PoissonDistribution dist;\n        try {\n            dist = new PoissonDistributionImpl(-1);\n            fail(\"negative mean: NotStrictlyPositiveException expected\");\n        } catch(NotStrictlyPositiveException ex) {\n            // Expected.\n        }\n\n        dist = new PoissonDistributionImpl(10.0);\n        assertEquals(10.0, dist.getMean(), 0.0);\n    }\n"], "Chart_1": ["    public void test2947660() {\n        AbstractCategoryItemRenderer r = new LineAndShapeRenderer();\n        assertNotNull(r.getLegendItems());\n        assertEquals(0, r.getLegendItems().getItemCount());\n\n        DefaultCategoryDataset dataset = new DefaultCategoryDataset();\n        CategoryPlot plot = new CategoryPlot();\n        plot.setDataset(dataset);\n        plot.setRenderer(r);\n        assertEquals(0, r.getLegendItems().getItemCount());\n\n        dataset.addValue(1.0, \"S1\", \"C1\");\n        LegendItemCollection lic = r.getLegendItems();\n        assertEquals(1, lic.getItemCount());\n        assertEquals(\"S1\", lic.get(0).getLabel());\n    }\n"], "Math_66": ["    @Test\n    public void testSinMin() throws MathException {\n        UnivariateRealFunction f = new SinFunction();\n        UnivariateRealOptimizer underlying = new BrentOptimizer();\n        JDKRandomGenerator g = new JDKRandomGenerator();\n        g.setSeed(44428400075l);\n        MultiStartUnivariateRealOptimizer minimizer =\n            new MultiStartUnivariateRealOptimizer(underlying, 10, g);\n        minimizer.optimize(f, GoalType.MINIMIZE, -100.0, 100.0);\n        double[] optima = minimizer.getOptima();\n        double[] optimaValues = minimizer.getOptimaValues();\n        for (int i = 1; i < optima.length; ++i) {\n            double d = (optima[i] - optima[i-1]) / (2 * Math.PI);\n            assertTrue (Math.abs(d - Math.rint(d)) < 1.0e-8);\n            assertEquals(-1.0, f.value(optima[i]), 1.0e-10);\n            assertEquals(f.value(optima[i]), optimaValues[i], 1.0e-10);\n        }\n        assertTrue(minimizer.getEvaluations() > 150);\n        assertTrue(minimizer.getEvaluations() < 250);\n    }\n", "    @Test\n    public void testQuinticMin() throws MathException {\n        // The quintic function has zeros at 0, +-0.5 and +-1.\n        // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,\n        UnivariateRealFunction f = new QuinticFunction();\n        UnivariateRealOptimizer underlying = new BrentOptimizer();\n        underlying.setRelativeAccuracy(1e-15);\n        JDKRandomGenerator g = new JDKRandomGenerator();\n        g.setSeed(4312000053L);\n        MultiStartUnivariateRealOptimizer minimizer =\n            new MultiStartUnivariateRealOptimizer(underlying, 5, g);\n        minimizer.setAbsoluteAccuracy(10 * minimizer.getAbsoluteAccuracy());\n        minimizer.setRelativeAccuracy(10 * minimizer.getRelativeAccuracy());\n\n        try {\n            minimizer.getOptima();\n            fail(\"an exception should have been thrown\");\n        } catch (IllegalStateException ise) {\n            // expected\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n        try {\n            minimizer.getOptimaValues();\n            fail(\"an exception should have been thrown\");\n        } catch (IllegalStateException ise) {\n            // expected\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n\n        double result = minimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2);\n        assertEquals(-0.2719561270319131, result, 1.0e-13);\n        assertEquals(-0.2719561270319131, minimizer.getResult(), 1.0e-13);\n        assertEquals(-0.04433426954946637, minimizer.getFunctionValue(), 1.0e-13);\n\n        double[] optima = minimizer.getOptima();\n        double[] optimaValues = minimizer.getOptimaValues();\n        for (int i = 0; i < optima.length; ++i) {\n            assertEquals(f.value(optima[i]), optimaValues[i], 1.0e-10);\n        }\n        assertTrue(minimizer.getEvaluations()    >= 120);\n        assertTrue(minimizer.getEvaluations()    <= 170);\n        assertTrue(minimizer.getIterationCount() >= 120);\n        assertTrue(minimizer.getIterationCount() <= 170);\n    }\n", "    @Test\n    public void testSinMin() throws MathException {\n        UnivariateRealFunction f = new SinFunction();\n        UnivariateRealOptimizer minimizer = new BrentOptimizer();\n        minimizer.setMaxEvaluations(200);\n        assertEquals(200, minimizer.getMaxEvaluations());\n        try {\n            minimizer.getResult();\n            fail(\"an exception should have been thrown\");\n        } catch (NoDataException ise) {\n            // expected\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n        assertEquals(3 * Math.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 4, 5), 10 * minimizer.getRelativeAccuracy());\n        assertTrue(minimizer.getIterationCount() <= 50);\n        assertEquals(3 * Math.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 1, 5), 10 * minimizer.getRelativeAccuracy());\n        assertTrue(minimizer.getIterationCount() <= 50);\n        assertTrue(minimizer.getEvaluations()    <= 100);\n        assertTrue(minimizer.getEvaluations()    >=  15);\n        minimizer.setMaxEvaluations(10);\n        try {\n            minimizer.optimize(f, GoalType.MINIMIZE, 4, 5);\n            fail(\"an exception should have been thrown\");\n        } catch (FunctionEvaluationException fee) {\n            // expected\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n    }\n", "    @Test\n    public void testQuinticMin() throws MathException {\n        // The function has local minima at -0.27195613 and 0.82221643.\n        UnivariateRealFunction f = new QuinticFunction();\n        UnivariateRealOptimizer minimizer = new BrentOptimizer();\n        assertEquals(-0.27195613, minimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2), 1.0e-8);\n        assertEquals( 0.82221643, minimizer.optimize(f, GoalType.MINIMIZE,  0.3,  0.9), 1.0e-8);\n        assertTrue(minimizer.getIterationCount() <= 50);\n\n        // search in a large interval\n        assertEquals(-0.27195613, minimizer.optimize(f, GoalType.MINIMIZE, -1.0, 0.2), 1.0e-8);\n        assertTrue(minimizer.getIterationCount() <= 50);\n    }\n", "    @Test\n    public void testQuinticMinStatistics() throws MathException {\n        // The function has local minima at -0.27195613 and 0.82221643.\n        UnivariateRealFunction f = new QuinticFunction();\n        UnivariateRealOptimizer minimizer = new BrentOptimizer();\n        minimizer.setRelativeAccuracy(1e-10);\n        minimizer.setAbsoluteAccuracy(1e-11);\n\n        final DescriptiveStatistics[] stat = new DescriptiveStatistics[3];\n        for (int i = 0; i < stat.length; i++) {\n            stat[i] = new DescriptiveStatistics();\n        }\n\n        final double min = -0.75;\n        final double max = 0.25;\n        final int nSamples = 200;\n        final double delta = (max - min) / nSamples;\n        for (int i = 0; i < nSamples; i++) {\n            final double start = min + i * delta;\n            stat[0].addValue(minimizer.optimize(f, GoalType.MINIMIZE, min, max, start));\n            stat[1].addValue(minimizer.getIterationCount());\n            stat[2].addValue(minimizer.getEvaluations());\n        }\n\n        final double meanOptValue = stat[0].getMean();\n        final double medianIter = stat[1].getPercentile(50);\n        final double medianEval = stat[2].getPercentile(50);\n        assertTrue(meanOptValue > -0.27195612812 && meanOptValue < -0.27195612811);\n        assertEquals(medianIter, 17, Math.ulp(1d));\n        assertEquals(medianEval, 18, Math.ulp(1d));\n    }\n"], "Math_92": ["    public void testBinomialCoefficientLarge() throws Exception {\n        // This tests all legal and illegal values for n <= 200.\n        for (int n = 0; n <= 200; n++) {\n            for (int k = 0; k <= n; k++) {\n                long ourResult = -1;\n                long exactResult = -1;\n                boolean shouldThrow = false;\n                boolean didThrow = false;\n                try {\n                    ourResult = MathUtils.binomialCoefficient(n, k);\n                } catch (ArithmeticException ex) {\n                    didThrow = true;\n                }\n                try {\n                    exactResult = binomialCoefficient(n, k);\n                } catch (ArithmeticException ex) {\n                    shouldThrow = true;\n                }\n                assertEquals(n+\",\"+k, shouldThrow, didThrow);\n                assertEquals(n+\",\"+k, exactResult, ourResult);\n                assertTrue(n+\",\"+k, (n > 66 || !didThrow));\n            }\n        }\n\n        long ourResult = MathUtils.binomialCoefficient(300, 3);\n        long exactResult = binomialCoefficient(300, 3);\n        assertEquals(exactResult, ourResult);\n\n        ourResult = MathUtils.binomialCoefficient(700, 697);\n        exactResult = binomialCoefficient(700, 697);\n        assertEquals(exactResult, ourResult);\n\n        // This one should throw\n        try {\n            MathUtils.binomialCoefficient(700, 300);\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            // Expected\n        }\n\n        // Larger values cannot be computed directly by our\n        // test implementation because of stack limitations,\n        // so we make little jumps to fill the cache.\n        for (int i = 2000; i <= 10000; i += 2000) {\n            ourResult = MathUtils.binomialCoefficient(i, 3);\n            exactResult = binomialCoefficient(i, 3);\n            assertEquals(exactResult, ourResult);\n        }\n\n    }\n"], "Chart_6": ["    public void testEquals() {\n        ShapeList l1 = new ShapeList();\n        l1.setShape(0, new Rectangle(1, 2, 3, 4));\n        l1.setShape(1, new Line2D.Double(1.0, 2.0, 3.0, 4.0));\n        l1.setShape(2, null);\n\n        ShapeList l2 = new ShapeList();\n        l2.setShape(0, new Rectangle(1, 2, 3, 4));\n        l2.setShape(1, new Line2D.Double(1.0, 2.0, 3.0, 4.0));\n        l2.setShape(2, null);\n\n        assertTrue(l1.equals(l2));\n        assertTrue(l2.equals(l2));\n    }\n", "    public void testSerialization() {\n\n        ShapeList l1 = new ShapeList();\n        l1.setShape(0, new Rectangle(1, 2, 3, 4));\n        l1.setShape(1, new Line2D.Double(1.0, 2.0, 3.0, 4.0));\n        l1.setShape(2, null);\n\n        ShapeList l2 = null;\n\n        try {\n            ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n            ObjectOutput out = new ObjectOutputStream(buffer);\n            out.writeObject(l1);\n            out.close();\n\n            ObjectInput in = new ObjectInputStream(new ByteArrayInputStream(\n            \t\tbuffer.toByteArray()));\n            l2 = (ShapeList) in.readObject();\n            in.close();\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n        }\n        assertEquals(l1, l2);\n\n    }\n"], "Math_59": ["    @Test\n    public void testMinMaxFloat() {\n        float[][] pairs = {\n            { -50.0f, 50.0f },\n            {  Float.POSITIVE_INFINITY, 1.0f },\n            {  Float.NEGATIVE_INFINITY, 1.0f },\n            {  Float.NaN, 1.0f },\n            {  Float.POSITIVE_INFINITY, 0.0f },\n            {  Float.NEGATIVE_INFINITY, 0.0f },\n            {  Float.NaN, 0.0f },\n            {  Float.NaN, Float.NEGATIVE_INFINITY },\n            {  Float.NaN, Float.POSITIVE_INFINITY }\n        };\n        for (float[] pair : pairs) {\n            Assert.assertEquals(\"min(\" + pair[0] + \", \" + pair[1] + \")\",\n                                Math.min(pair[0], pair[1]),\n                                FastMath.min(pair[0], pair[1]),\n                                MathUtils.EPSILON);\n            Assert.assertEquals(\"min(\" + pair[1] + \", \" + pair[0] + \")\",\n                                Math.min(pair[1], pair[0]),\n                                FastMath.min(pair[1], pair[0]),\n                                MathUtils.EPSILON);\n            Assert.assertEquals(\"max(\" + pair[0] + \", \" + pair[1] + \")\",\n                                Math.max(pair[0], pair[1]),\n                                FastMath.max(pair[0], pair[1]),\n                                MathUtils.EPSILON);\n            Assert.assertEquals(\"max(\" + pair[1] + \", \" + pair[0] + \")\",\n                                Math.max(pair[1], pair[0]),\n                                FastMath.max(pair[1], pair[0]),\n                                MathUtils.EPSILON);\n        }\n    }\n"], "Closure_5": ["  public void testNoInlineDeletedProperties() {\n    testSameLocal(\n        \"var foo = {bar:1};\" +\n        \"delete foo.bar;\" +\n        \"return foo.bar;\");\n  }\n"], "Math_50": ["    @Test(expected=TooManyEvaluationsException.class)\n    public void testIssue631() {\n        final UnivariateRealFunction f = new UnivariateRealFunction() {\n                /** {@inheritDoc} */\n                public double value(double x) {\n                    return Math.exp(x) - Math.pow(Math.PI, 3.0);\n                }\n            };\n\n        final UnivariateRealSolver solver = new RegulaFalsiSolver();\n        final double root = solver.solve(3624, f, 1, 10);\n        Assert.assertEquals(3.4341896575482003, root, 1e-15);\n\t}\n"], "Math_57": ["    @Test\n    public void testSmallDistances() {\n        // Create a bunch of CloseIntegerPoints. Most are identical, but one is different by a\n        // small distance.\n        int[] repeatedArray = { 0 };\n        int[] uniqueArray = { 1 };\n        CloseIntegerPoint repeatedPoint =\n            new CloseIntegerPoint(new EuclideanIntegerPoint(repeatedArray));\n        CloseIntegerPoint uniquePoint =\n            new CloseIntegerPoint(new EuclideanIntegerPoint(uniqueArray));\n\n        Collection<CloseIntegerPoint> points = new ArrayList<CloseIntegerPoint>();\n        final int NUM_REPEATED_POINTS = 10 * 1000;\n        for (int i = 0; i < NUM_REPEATED_POINTS; ++i) {\n            points.add(repeatedPoint);\n        }\n        points.add(uniquePoint);\n\n        // Ask a KMeansPlusPlusClusterer to run zero iterations (i.e., to simply choose initial\n        // cluster centers).\n        final long RANDOM_SEED = 0;\n        final int NUM_CLUSTERS = 2;\n        final int NUM_ITERATIONS = 0;\n        KMeansPlusPlusClusterer<CloseIntegerPoint> clusterer =\n            new KMeansPlusPlusClusterer<CloseIntegerPoint>(new Random(RANDOM_SEED));\n        List<Cluster<CloseIntegerPoint>> clusters =\n            clusterer.cluster(points, NUM_CLUSTERS, NUM_ITERATIONS);\n\n        // Check that one of the chosen centers is the unique point.\n        boolean uniquePointIsCenter = false;\n        for (Cluster<CloseIntegerPoint> cluster : clusters) {\n            if (cluster.getCenter().equals(uniquePoint)) {\n                uniquePointIsCenter = true;\n            }\n        }\n        assertTrue(uniquePointIsCenter);\n    }\n"], "Chart_8": ["    public void testConstructor() {\n        Locale savedLocale = Locale.getDefault();\n        TimeZone savedZone = TimeZone.getDefault();\n        Locale.setDefault(new Locale(\"da\", \"DK\"));\n        TimeZone.setDefault(TimeZone.getTimeZone(\"Europe/Copenhagen\"));\n        GregorianCalendar cal = (GregorianCalendar) Calendar.getInstance(\n                TimeZone.getDefault(), Locale.getDefault());\n\n        // first day of week is monday\n        assertEquals(Calendar.MONDAY, cal.getFirstDayOfWeek());\n        cal.set(2007, Calendar.AUGUST, 26, 1, 0, 0);\n        cal.set(Calendar.MILLISECOND, 0);\n        Date t = cal.getTime();\n        Week w = new Week(t, TimeZone.getTimeZone(\"Europe/Copenhagen\"));\n        assertEquals(34, w.getWeek());\n\n        Locale.setDefault(Locale.US);\n        TimeZone.setDefault(TimeZone.getTimeZone(\"US/Detroit\"));\n        cal = (GregorianCalendar) Calendar.getInstance(TimeZone.getDefault());\n        // first day of week is Sunday\n        assertEquals(Calendar.SUNDAY, cal.getFirstDayOfWeek());\n        cal.set(2007, Calendar.AUGUST, 26, 1, 0, 0);\n        cal.set(Calendar.MILLISECOND, 0);\n\n        t = cal.getTime();\n        w = new Week(t, TimeZone.getTimeZone(\"Europe/Copenhagen\"));\n        assertEquals(35, w.getWeek());\n        w = new Week(t, TimeZone.getTimeZone(\"Europe/Copenhagen\"),\n                new Locale(\"da\", \"DK\"));\n        assertEquals(34, w.getWeek());\n\n        Locale.setDefault(savedLocale);\n        TimeZone.setDefault(savedZone);\n    }\n"], "Closure_2": ["  public void testBadInterfaceExtendsNonExistentInterfaces() throws Exception {\n    String js = \"/** @interface \\n\" +\n        \" * @extends {nonExistent1} \\n\" +\n        \" * @extends {nonExistent2} \\n\" +\n        \" */function A() {}\";\n    String[] expectedWarnings = {\n      \"Bad type annotation. Unknown type nonExistent1\",\n      \"Bad type annotation. Unknown type nonExistent2\"\n    };\n    testTypes(js, expectedWarnings);\n  }\n"], "Math_68": ["  public void testMinpackFreudensteinRoth() {\n    minpackTest(new FreudensteinRothFunction(new double[] { 0.5, -2.0 },\n                                             20.0124960961895, 6.99887517584575,\n                                             new double[] {\n                                               11.4124844654993,\n                                               -0.896827913731509\n                                             }), false);\n    minpackTest(new FreudensteinRothFunction(new double[] { 5.0, -20.0 },\n                                             12432.833948863, 6.9988751744895,\n                                             new double[] {\n                                               11.4121122022341,\n                                               -0.8968550851268697\n                                             }), false);\n    minpackTest(new FreudensteinRothFunction(new double[] { 50.0, -200.0 },\n                                             11426454.595762, 6.99887517242903,\n                                             new double[] {\n                                               11.412069435091231,\n                                               -0.8968582807605691\n                                             }), false);\n  }\n", "  public void testMinpackJennrichSampson() {\n    minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 },\n                                            64.5856498144943, 11.1517793413499,\n                                            new double[] {\n                                             0.2578330049, 0.257829976764542\n                                            }), false);\n  }\n"], "Math_34": ["    @Test(expected = UnsupportedOperationException.class)\n    public void testIterator() {\n        final ArrayList<Chromosome> chromosomes = new ArrayList<Chromosome>();\n        chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3)));\n        chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3)));\n        chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3)));\n\n        final ListPopulation population = new ListPopulation(10) {\n            public Population nextGeneration() {\n                // not important\n                return null;\n            }\n        };\n\n        population.addChromosomes(chromosomes);\n\n        final Iterator<Chromosome> iter = population.iterator();\n        while (iter.hasNext()) {\n            iter.next();\n            iter.remove();\n        }\n    }\n"], "Math_33": ["    @Test\n    public void testMath781() {\n        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 2, 6, 7 }, 0);\n\n        ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n        constraints.add(new LinearConstraint(new double[] { 1, 2, 1 }, Relationship.LEQ, 2));\n        constraints.add(new LinearConstraint(new double[] { -1, 1, 1 }, Relationship.LEQ, -1));\n        constraints.add(new LinearConstraint(new double[] { 2, -3, 1 }, Relationship.LEQ, -1));\n\n        double epsilon = 1e-6;\n        SimplexSolver solver = new SimplexSolver();\n        PointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);\n\n        Assert.assertTrue(Precision.compareTo(solution.getPoint()[0], 0.0d, epsilon) > 0);\n        Assert.assertTrue(Precision.compareTo(solution.getPoint()[1], 0.0d, epsilon) > 0);\n        Assert.assertTrue(Precision.compareTo(solution.getPoint()[2], 0.0d, epsilon) < 0);\n        Assert.assertEquals(2.0d, solution.getValue(), epsilon);\n    }\n"], "Math_56": ["    @Test\n    public void testIterationConsistency() {\n        final MultidimensionalCounter c = new MultidimensionalCounter(2, 3, 4);\n        final int[][] expected = new int[][] {\n            { 0, 0, 0 },\n            { 0, 0, 1 },\n            { 0, 0, 2 },\n            { 0, 0, 3 },\n            { 0, 1, 0 },\n            { 0, 1, 1 },\n            { 0, 1, 2 },\n            { 0, 1, 3 },\n            { 0, 2, 0 },\n            { 0, 2, 1 },\n            { 0, 2, 2 },\n            { 0, 2, 3 },\n            { 1, 0, 0 },\n            { 1, 0, 1 },\n            { 1, 0, 2 },\n            { 1, 0, 3 },\n            { 1, 1, 0 },\n            { 1, 1, 1 },\n            { 1, 1, 2 },\n            { 1, 1, 3 },\n            { 1, 2, 0 },\n            { 1, 2, 1 },\n            { 1, 2, 2 },\n            { 1, 2, 3 }\n        };\n\n        final int totalSize = c.getSize();\n        final int nDim = c.getDimension();\n        final MultidimensionalCounter.Iterator iter = c.iterator();\n        for (int i = 0; i < totalSize; i++) {\n            if (!iter.hasNext()) {\n                Assert.fail(\"Too short\");\n            }\n            final int uniDimIndex = iter.next();\n            Assert.assertEquals(\"Wrong iteration at \" + i, i, uniDimIndex);\n\n            for (int dimIndex = 0; dimIndex < nDim; dimIndex++) {\n                Assert.assertEquals(\"Wrong multidimensional index for [\" + i + \"][\" + dimIndex + \"]\",\n                                    expected[i][dimIndex], iter.getCount(dimIndex));\n            }\n\n            Assert.assertEquals(\"Wrong unidimensional index for [\" + i + \"]\",\n                                c.getCount(expected[i]), uniDimIndex);\n\n            final int[] indices = c.getCounts(uniDimIndex);\n            for (int dimIndex = 0; dimIndex < nDim; dimIndex++) {\n                Assert.assertEquals(\"Wrong multidimensional index for [\" + i + \"][\" + dimIndex + \"]\",\n                                    expected[i][dimIndex], indices[dimIndex]);\n            }\n        }\n\n        if (iter.hasNext()) {\n            Assert.fail(\"Too long\");\n        }\n    }\n"], "Closure_3": ["  public void testDoNotInlineCatchExpression1() {\n    noInline(\n        \"var a;\\n\" +\n        \"try {\\n\" +\n        \"  throw Error(\\\"\\\");\\n\" +\n        \"}catch(err) {\" +\n        \"   a = err;\\n\" +\n        \"}\\n\" +\n        \"return a.stack\\n\");\n  }\n", "  public void testDoNotInlineCatchExpression1a() {\n    noInline(\n        \"var a;\\n\" +\n        \"try {\\n\" +\n        \"  throw Error(\\\"\\\");\\n\" +\n        \"}catch(err) {\" +\n        \"   a = err + 1;\\n\" +\n        \"}\\n\" +\n        \"return a.stack\\n\");\n  }\n", "  public void testDoNotInlineCatchExpression3() {\n    noInline(\n        \"var a;\\n\" +\n        \"try {\\n\" +\n        \"  throw Error(\\\"\\\");\\n\" +\n        \"} catch(err) {\" +\n        \"  err = x;\\n\" +\n        \"  a = err;\\n\" +\n        \"}\\n\" +\n        \"return a.stack\\n\");\n  }\n"], "Chart_9": ["    public void testBug1864222() {\n        TimeSeries s = new TimeSeries(\"S\");\n        s.add(new Day(19, 8, 2005), 1);\n        s.add(new Day(31, 1, 2006), 1);\n        boolean pass = true;\n        try {\n            s.createCopy(new Day(1, 12, 2005), new Day(18, 1, 2006));\n        }\n        catch (CloneNotSupportedException e) {\n            pass = false;\n        }\n        assertTrue(pass);\n    }\n"], "Math_69": ["    public void testPValueNearZero() throws Exception {\n        /*\n         * Create a dataset that has r -> 1, p -> 0 as dimension increases.\n         * Prior to the fix for MATH-371, p vanished for dimension >= 14.\n         * Post fix, p-values diminish smoothly, vanishing at dimension = 127.\n         * Tested value is ~1E-303.\n         */\n        int dimension = 120; \n        double[][] data = new double[dimension][2];\n        for (int i = 0; i < dimension; i++) {\n            data[i][0] = i;\n            data[i][1] = i + 1/((double)i + 1);\n        }\n        PearsonsCorrelation corrInstance = new PearsonsCorrelation(data);\n        assertTrue(corrInstance.getCorrelationPValues().getEntry(0, 1) > 0);\n    }\n"], "Closure_4": ["  public void testImplementsLoop() throws Exception {\n    testClosureTypesMultipleWarnings(\n        suppressMissingProperty(\"foo\") +\n        \"/** @constructor \\n * @implements {T} */var T = function() {};\" +\n        \"alert((new T).foo);\",\n        Lists.newArrayList(\n            \"Parse error. Cycle detected in inheritance chain of type T\"));\n  }\n", "  public void testImplementsExtendsLoop() throws Exception {\n    testClosureTypesMultipleWarnings(\n        suppressMissingProperty(\"foo\") +\n            \"/** @constructor \\n * @implements {F} */var G = function() {};\" +\n            \"/** @constructor \\n * @extends {G} */var F = function() {};\" +\n        \"alert((new F).foo);\",\n        Lists.newArrayList(\n            \"Parse error. Cycle detected in inheritance chain of type F\"));\n  }\n", "  public void testConversionFromInterfaceToRecursiveConstructor()\n      throws Exception {\n    testClosureTypesMultipleWarnings(\n        suppressMissingProperty(\"foo\") +\n            \"/** @interface */ var OtherType = function() {}\\n\" +\n            \"/** @implements {MyType} \\n * @constructor */\\n\" +\n            \"var MyType = function() {}\\n\" +\n            \"/** @type {MyType} */\\n\" +\n            \"var x = /** @type {!OtherType} */ (new Object());\",\n        Lists.newArrayList(\n            \"Parse error. Cycle detected in inheritance chain of type MyType\",\n            \"initializing variable\\n\" +\n            \"found   : OtherType\\n\" +\n            \"required: (MyType|null)\"));\n  }\n"], "Math_51": ["    @Test\n    public void testIssue631() {\n        final UnivariateRealFunction f = new UnivariateRealFunction() {\n                @Override\n                public double value(double x) {\n                    return Math.exp(x) - Math.pow(Math.PI, 3.0);\n                }\n            };\n\n        final UnivariateRealSolver solver = new RegulaFalsiSolver();\n        final double root = solver.solve(3624, f, 1, 10);\n        Assert.assertEquals(3.4341896575482003, root, 1e-15);\n\t}\n"], "Math_93": ["    public void testFactorial() {\n        for (int i = 1; i < 21; i++) {\n            assertEquals(i + \"! \", factorial(i), MathUtils.factorial(i));\n            assertEquals(i + \"! \", (double)factorial(i), MathUtils.factorialDouble(i), Double.MIN_VALUE);\n            assertEquals(i + \"! \", Math.log((double)factorial(i)), MathUtils.factorialLog(i), 10E-12);\n        }\n        \n        assertEquals(\"0\", 1, MathUtils.factorial(0));\n        assertEquals(\"0\", 1.0d, MathUtils.factorialDouble(0), 1E-14);\n        assertEquals(\"0\", 0.0d, MathUtils.factorialLog(0), 1E-14);\n    }\n", "    public void testFactorialFail() {\n        try {\n            MathUtils.factorial(-1);\n            fail(\"expecting IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            ;\n        }\n        try {\n            MathUtils.factorialDouble(-1);\n            fail(\"expecting IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            ;\n        }\n        try {\n            MathUtils.factorialLog(-1);\n            fail(\"expecting IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            ;\n        }\n        try {\n            MathUtils.factorial(21);\n            fail(\"expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            ;\n        }\n        assertTrue(\"expecting infinite factorial value\", Double.isInfinite(MathUtils.factorialDouble(171)));\n    }\n"], "Math_67": ["    @Test\n    public void testQuinticMin() throws MathException {\n        // The quintic function has zeros at 0, +-0.5 and +-1.\n        // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,\n        UnivariateRealFunction f = new QuinticFunction();\n        UnivariateRealOptimizer underlying = new BrentOptimizer();\n        JDKRandomGenerator g = new JDKRandomGenerator();\n        g.setSeed(4312000053l);\n        MultiStartUnivariateRealOptimizer minimizer =\n            new MultiStartUnivariateRealOptimizer(underlying, 5, g);\n        minimizer.setAbsoluteAccuracy(10 * minimizer.getAbsoluteAccuracy());\n        minimizer.setRelativeAccuracy(10 * minimizer.getRelativeAccuracy());\n\n        try {\n            minimizer.getOptima();\n            fail(\"an exception should have been thrown\");\n        } catch (IllegalStateException ise) {\n            // expected\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n        try {\n            minimizer.getOptimaValues();\n            fail(\"an exception should have been thrown\");\n        } catch (IllegalStateException ise) {\n            // expected\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n\n        assertEquals(-0.27195612846834, minimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2), 1.0e-13);\n        assertEquals(-0.27195612846834, minimizer.getResult(), 1.0e-13);\n        assertEquals(-0.04433426954946, minimizer.getFunctionValue(), 1.0e-13);\n\n        double[] optima = minimizer.getOptima();\n        double[] optimaValues = minimizer.getOptimaValues();\n        for (int i = 0; i < optima.length; ++i) {\n            assertEquals(f.value(optima[i]), optimaValues[i], 1.0e-10);\n        }\n\n        assertTrue(minimizer.getEvaluations()    >= 510);\n        assertTrue(minimizer.getEvaluations()    <= 530);\n        assertTrue(minimizer.getIterationCount() >= 150);\n        assertTrue(minimizer.getIterationCount() <= 170);\n\n    }\n"], "Chart_7": ["    public void testGetMaxMiddleIndex() {\n        TimePeriodValues s = new TimePeriodValues(\"Test\");\n        assertEquals(-1, s.getMaxMiddleIndex());\n        s.add(new SimpleTimePeriod(100L, 200L), 1.0);\n        assertEquals(0, s.getMaxMiddleIndex());\n        s.add(new SimpleTimePeriod(300L, 400L), 2.0);\n        assertEquals(1, s.getMaxMiddleIndex());\n        s.add(new SimpleTimePeriod(0L, 50L), 3.0);\n        assertEquals(1, s.getMaxMiddleIndex());\n        s.add(new SimpleTimePeriod(150L, 200L), 4.0);\n        assertEquals(1, s.getMaxMiddleIndex());\n    }\n"], "Math_58": ["    @Test\n    public void testMath519() {\n        // The optimizer will try negative sigma values but \"GaussianFitter\"\n        // will catch the raised exceptions and return NaN values instead.\n\n        final double[] data = { \n            1.1143831578403364E-29,\n            4.95281403484594E-28,\n            1.1171347211930288E-26,\n            1.7044813962636277E-25,\n            1.9784716574832164E-24,\n            1.8630236407866774E-23,\n            1.4820532905097742E-22,\n            1.0241963854632831E-21,\n            6.275077366673128E-21,\n            3.461808994532493E-20,\n            1.7407124684715706E-19,\n            8.056687953553974E-19,\n            3.460193945992071E-18,\n            1.3883326374011525E-17,\n            5.233894983671116E-17,\n            1.8630791465263745E-16,\n            6.288759227922111E-16,\n            2.0204433920597856E-15,\n            6.198768938576155E-15,\n            1.821419346860626E-14,\n            5.139176445538471E-14,\n            1.3956427429045787E-13,\n            3.655705706448139E-13,\n            9.253753324779779E-13,\n            2.267636001476696E-12,\n            5.3880460095836855E-12,\n            1.2431632654852931E-11\n        };\n\n        GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n        for (int i = 0; i < data.length; i++) {\n            fitter.addObservedPoint(i, data[i]);\n        }\n        final double[] p = fitter.fit();\n\n        Assert.assertEquals(53.1572792, p[1], 1e-7);\n        Assert.assertEquals(5.75214622, p[2], 1e-8);\n    }\n"], "Math_60": ["    public void testExtremeValues() throws Exception {\n        NormalDistribution distribution = new NormalDistributionImpl(0, 1);\n        for (int i = 0; i < 100; i++) { // make sure no convergence exception\n            double lowerTail = distribution.cumulativeProbability(-i);\n            double upperTail = distribution.cumulativeProbability(i);\n            if (i < 9) { // make sure not top-coded \n                // For i = 10, due to bad tail precision in erf (MATH-364), 1 is returned\n                // TODO: once MATH-364 is resolved, replace 9 with 30\n                assertTrue(lowerTail > 0.0d);\n                assertTrue(upperTail < 1.0d);\n            }\n            else { // make sure top coding not reversed\n                assertTrue(lowerTail < 0.00001);\n                assertTrue(upperTail > 0.99999);\n            }\n        }\n        \n        assertEquals(distribution.cumulativeProbability(Double.MAX_VALUE), 1, 0);\n        assertEquals(distribution.cumulativeProbability(-Double.MAX_VALUE), 0, 0);\n        assertEquals(distribution.cumulativeProbability(Double.POSITIVE_INFINITY), 1, 0);\n        assertEquals(distribution.cumulativeProbability(Double.NEGATIVE_INFINITY), 0, 0);\n        \n   }\n"], "Math_94": ["    public void testGcd() {\n        int a = 30;\n        int b = 50;\n        int c = 77;\n\n        assertEquals(0, MathUtils.gcd(0, 0));\n\n        assertEquals(b, MathUtils.gcd(0, b));\n        assertEquals(a, MathUtils.gcd(a, 0));\n        assertEquals(b, MathUtils.gcd(0, -b));\n        assertEquals(a, MathUtils.gcd(-a, 0));\n\n        assertEquals(10, MathUtils.gcd(a, b));\n        assertEquals(10, MathUtils.gcd(-a, b));\n        assertEquals(10, MathUtils.gcd(a, -b));\n        assertEquals(10, MathUtils.gcd(-a, -b));\n\n        assertEquals(1, MathUtils.gcd(a, c));\n        assertEquals(1, MathUtils.gcd(-a, c));\n        assertEquals(1, MathUtils.gcd(a, -c));\n        assertEquals(1, MathUtils.gcd(-a, -c));\n\n        assertEquals(3 * (1<<15), MathUtils.gcd(3 * (1<<20), 9 * (1<<15)));\n\n    }\n"], "Math_24": ["    @Test\n    public void testMath855() {\n        final double minSin = 3 * Math.PI / 2;\n        final double offset = 1e-8;\n        final double delta = 1e-7;\n        final UnivariateFunction f1 = new Sin();\n        final UnivariateFunction f2 = new StepFunction(new double[] { minSin, minSin + offset, minSin + 5 * offset },\n                                                       new double[] { 0, -1, 0 });\n        final UnivariateFunction f = FunctionUtils.add(f1, f2);\n        final UnivariateOptimizer optimizer = new BrentOptimizer(1e-8, 1e-100);\n        final UnivariatePointValuePair result\n            = optimizer.optimize(200, f, GoalType.MINIMIZE, minSin - 6.789 * delta, minSin + 9.876 * delta);\n        final int numEval = optimizer.getEvaluations();\n\n        final double sol = result.getPoint();\n        final double expected = 4.712389027602411;\n\n        // System.out.println(\"min=\" + (minSin + offset) + \" f=\" + f.value(minSin + offset));\n        // System.out.println(\"sol=\" + sol + \" f=\" + f.value(sol));\n        // System.out.println(\"exp=\" + expected + \" f=\" + f.value(expected));\n\n        Assert.assertTrue(\"Best point not reported\", f.value(sol) <= f.value(expected));\n    }\n"], "Math_23": ["    @Test\n    public void testKeepInitIfBest() {\n        final double minSin = 3 * Math.PI / 2;\n        final double offset = 1e-8;\n        final double delta = 1e-7;\n        final UnivariateFunction f1 = new Sin();\n        final UnivariateFunction f2 = new StepFunction(new double[] { minSin, minSin + offset, minSin + 2 * offset},\n                                                       new double[] { 0, -1, 0 });\n        final UnivariateFunction f = FunctionUtils.add(f1, f2);\n        // A slightly less stringent tolerance would make the test pass\n        // even with the previous implementation.\n        final double relTol = 1e-8;\n        final UnivariateOptimizer optimizer = new BrentOptimizer(relTol, 1e-100);\n        final double init = minSin + 1.5 * offset;\n        final UnivariatePointValuePair result\n            = optimizer.optimize(200, f, GoalType.MINIMIZE,\n                                 minSin - 6.789 * delta,\n                                 minSin + 9.876 * delta,\n                                 init);\n        final int numEval = optimizer.getEvaluations();\n\n        final double sol = result.getPoint();\n        final double expected = init;\n\n//         System.out.println(\"numEval=\" + numEval);\n//         System.out.println(\"min=\" + init + \" f=\" + f.value(init));\n//         System.out.println(\"sol=\" + sol + \" f=\" + f.value(sol));\n//         System.out.println(\"exp=\" + expected + \" f=\" + f.value(expected));\n\n        Assert.assertTrue(\"Best point not reported\", f.value(sol) <= f.value(expected));\n    }\n"], "Math_15": ["    @Test\n    public void testMath904() {\n        final double x = -1;\n        final double y = (5 + 1e-15) * 1e15;\n        Assert.assertEquals(Math.pow(x, y),\n                            FastMath.pow(x, y), 0);\n        Assert.assertEquals(Math.pow(x, -y),\n                            FastMath.pow(x, -y), 0);\n    }\n"], "Math_9": ["    @Test\n    public void testRevert() {\n        \n        // setup\n        Line line = new Line(new Vector3D(1653345.6696423641, 6170370.041579291, 90000),\n                             new Vector3D(1650757.5050732433, 6160710.879908984, 0.9));\n        Vector3D expected = line.getDirection().negate();\n\n        // action\n        Line reverted = line.revert();\n\n        // verify\n        Assert.assertArrayEquals(expected.toArray(), reverted.getDirection().toArray(), 0);\n\n    }\n"], "Math_79": ["    @Test\n    public void testPerformClusterAnalysisDegenerate() {\n        KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(\n                new Random(1746432956321l));\n        EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] {\n                new EuclideanIntegerPoint(new int[] { 1959, 325100 }),\n                new EuclideanIntegerPoint(new int[] { 1960, 373200 }), };\n        List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points), 1, 1);\n        assertEquals(1, clusters.size());\n        assertEquals(2, (clusters.get(0).getPoints().size()));\n        EuclideanIntegerPoint pt1 = new EuclideanIntegerPoint(new int[] { 1959, 325100 });\n        EuclideanIntegerPoint pt2 = new EuclideanIntegerPoint(new int[] { 1960, 373200 });\n        assertTrue(clusters.get(0).getPoints().contains(pt1));\n        assertTrue(clusters.get(0).getPoints().contains(pt2));\n\n    } \n"], "Math_106": ["    public void testParseProperInvalidMinus() {\n        String source = \"2 -2 / 3\";\n        try {\n            Fraction c = properFormat.parse(source);\n            fail(\"invalid minus in improper fraction.\");\n        } catch (ParseException ex) {\n            // expected\n        }\n        source = \"2 2 / -3\";\n        try {\n            Fraction c = properFormat.parse(source);\n            fail(\"invalid minus in improper fraction.\");\n        } catch (ParseException ex) {\n            // expected\n        }\n    }\n"], "Math_46": ["    @Test\n    public void testDivideZero() {\n        Complex x = new Complex(3.0, 4.0);\n        Complex z = x.divide(Complex.ZERO);\n        // Assert.assertEquals(z, Complex.INF); // See MATH-657\n        Assert.assertEquals(z, Complex.NaN);\n    }\n", "    @Test\n    public void testDivideZeroZero() {\n        Complex x = new Complex(0.0, 0.0);\n        Complex z = x.divide(Complex.ZERO);\n        Assert.assertEquals(z, Complex.NaN);\n    }\n", "    @Test\n    public void testAtanInf() {\n        TestUtils.assertSame(Complex.NaN, oneInf.atan());\n        TestUtils.assertSame(Complex.NaN, oneNegInf.atan());\n        TestUtils.assertSame(Complex.NaN, infOne.atan());\n        TestUtils.assertSame(Complex.NaN, negInfOne.atan());\n        TestUtils.assertSame(Complex.NaN, infInf.atan());\n        TestUtils.assertSame(Complex.NaN, infNegInf.atan());\n        TestUtils.assertSame(Complex.NaN, negInfInf.atan());\n        TestUtils.assertSame(Complex.NaN, negInfNegInf.atan());\n    }\n", "    @Test\n    public void testAtanI() {\n        Assert.assertTrue(Complex.I.atan().isNaN());\n    }\n"], "Math_41": ["    @Test\n    public void testEvaluateArraySegmentWeighted() {\n        // See if this statistic computes weighted statistics\n        // If not, skip this test\n        UnivariateStatistic statistic = getUnivariateStatistic();\n        if (!(statistic instanceof WeightedEvaluation)) {\n            return;\n        }\n        final WeightedEvaluation stat = (WeightedEvaluation) getUnivariateStatistic();\n        final double[] arrayZero = new double[5];\n        final double[] weightZero = new double[5];\n        System.arraycopy(testArray, 0, arrayZero, 0, 5);\n        System.arraycopy(testWeightsArray, 0, weightZero, 0, 5);\n        Assert.assertEquals(stat.evaluate(arrayZero, weightZero),\n                stat.evaluate(testArray, testWeightsArray, 0, 5), 0);\n        final double[] arrayOne = new double[5];\n        final double[] weightOne = new double[5];\n        System.arraycopy(testArray, 5, arrayOne, 0, 5);\n        System.arraycopy(testWeightsArray, 5, weightOne, 0, 5);\n        Assert.assertEquals(stat.evaluate(arrayOne, weightOne),\n                stat.evaluate(testArray, testWeightsArray, 5, 5), 0);\n        final double[] arrayEnd = new double[5];\n        final double[] weightEnd = new double[5];\n        System.arraycopy(testArray, testArray.length - 5, arrayEnd, 0, 5);\n        System.arraycopy(testWeightsArray, testArray.length - 5, weightEnd, 0, 5);\n        Assert.assertEquals(stat.evaluate(arrayEnd, weightEnd),\n                stat.evaluate(testArray, testWeightsArray, testArray.length - 5, 5), 0);\n    }\n"], "Math_101": ["    public void testForgottenImaginaryCharacter() {\n        ParsePosition pos = new ParsePosition(0);\n        assertNull(new ComplexFormat().parse(\"1 + 1\", pos));\n        assertEquals(5, pos.getErrorIndex());\n    }\n"], "Math_48": ["    @Test(expected=ConvergenceException.class)\n    public void testIssue631() {\n        final UnivariateRealFunction f = new UnivariateRealFunction() {\n                /** {@inheritDoc} */\n                public double value(double x) {\n                    return Math.exp(x) - Math.pow(Math.PI, 3.0);\n                }\n            };\n\n        final UnivariateRealSolver solver = new RegulaFalsiSolver();\n        final double root = solver.solve(3624, f, 1, 10);\n        Assert.assertEquals(3.4341896575482003, root, 1e-15);\n\t}\n"], "Math_77": ["    public void testBasicFunctions() {\n        ArrayRealVector v1 = new ArrayRealVector(vec1);\n        ArrayRealVector v2 = new ArrayRealVector(vec2);\n        ArrayRealVector v5 = new ArrayRealVector(vec5);\n        ArrayRealVector v_null = new ArrayRealVector(vec_null);\n\n        RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2);\n\n        // emacs calc: [-4, 0, 3, 1, -6, 3] A --> 8.4261497731763586307\n        double d_getNorm = v5.getNorm();\n        assertEquals(\"compare values  \", 8.4261497731763586307, d_getNorm);\n\n        // emacs calc: [-4, 0, 3, 1, -6, 3] vN --> 17\n        double d_getL1Norm = v5.getL1Norm();\n        assertEquals(\"compare values  \", 17.0, d_getL1Norm);\n\n        // emacs calc: [-4, 0, 3, 1, -6, 3] vn --> 6\n        double d_getLInfNorm = v5.getLInfNorm();\n        assertEquals(\"compare values  \", 6.0, d_getLInfNorm);\n\n\n        //octave =  sqrt(sumsq(v1-v2))\n        double dist = v1.getDistance(v2);\n        assertEquals(\"compare values  \",v1.subtract(v2).getNorm(), dist );\n\n        //octave =  sqrt(sumsq(v1-v2))\n        double dist_2 = v1.getDistance(v2_t);\n        assertEquals(\"compare values  \", v1.subtract(v2).getNorm(),dist_2 );\n\n        //octave =  sqrt(sumsq(v1-v2))\n        double dist_3 = v1.getDistance((RealVector) v2);\n        assertEquals(\"compare values  \", v1.subtract(v2).getNorm(),dist_3 );\n\n        //octave =  ???\n        double d_getL1Distance = v1. getL1Distance(v2);\n        assertEquals(\"compare values  \",9d, d_getL1Distance );\n\n        double d_getL1Distance_2 = v1. getL1Distance(v2_t);\n        assertEquals(\"compare values  \",9d, d_getL1Distance_2 );\n\n        double d_getL1Distance_3 = v1. getL1Distance((RealVector) v2);\n        assertEquals(\"compare values  \",9d, d_getL1Distance_3 );\n\n        //octave =  ???\n        double d_getLInfDistance = v1. getLInfDistance(v2);\n        assertEquals(\"compare values  \",3d, d_getLInfDistance );\n\n        double d_getLInfDistance_2 = v1. getLInfDistance(v2_t);\n        assertEquals(\"compare values  \",3d, d_getLInfDistance_2 );\n\n        double d_getLInfDistance_3 = v1. getLInfDistance((RealVector) v2);\n        assertEquals(\"compare values  \",3d, d_getLInfDistance_3 );\n\n        //octave =  v1 + v2\n        ArrayRealVector v_add = v1.add(v2);\n        double[] result_add = {5d, 7d, 9d};\n        assertClose(\"compare vect\" ,v_add.getData(),result_add,normTolerance);\n\n        RealVectorTestImpl vt2 = new RealVectorTestImpl(vec2);\n        RealVector v_add_i = v1.add(vt2);\n        double[] result_add_i = {5d, 7d, 9d};\n        assertClose(\"compare vect\" ,v_add_i.getData(),result_add_i,normTolerance);\n\n        //octave =  v1 - v2\n        ArrayRealVector v_subtract = v1.subtract(v2);\n        double[] result_subtract = {-3d, -3d, -3d};\n        assertClose(\"compare vect\" ,v_subtract.getData(),result_subtract,normTolerance);\n\n        RealVector v_subtract_i = v1.subtract(vt2);\n        double[] result_subtract_i = {-3d, -3d, -3d};\n        assertClose(\"compare vect\" ,v_subtract_i.getData(),result_subtract_i,normTolerance);\n\n        // octave v1 .* v2\n        ArrayRealVector  v_ebeMultiply = v1.ebeMultiply(v2);\n        double[] result_ebeMultiply = {4d, 10d, 18d};\n        assertClose(\"compare vect\" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);\n\n        RealVector  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);\n        double[] result_ebeMultiply_2 = {4d, 10d, 18d};\n        assertClose(\"compare vect\" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);\n\n        RealVector  v_ebeMultiply_3 = v1.ebeMultiply((RealVector) v2);\n        double[] result_ebeMultiply_3 = {4d, 10d, 18d};\n        assertClose(\"compare vect\" ,v_ebeMultiply_3.getData(),result_ebeMultiply_3,normTolerance);\n\n        // octave v1 ./ v2\n        ArrayRealVector  v_ebeDivide = v1.ebeDivide(v2);\n        double[] result_ebeDivide = {0.25d, 0.4d, 0.5d};\n        assertClose(\"compare vect\" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);\n\n        RealVector  v_ebeDivide_2 = v1.ebeDivide(v2_t);\n        double[] result_ebeDivide_2 = {0.25d, 0.4d, 0.5d};\n        assertClose(\"compare vect\" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);\n\n        RealVector  v_ebeDivide_3 = v1.ebeDivide((RealVector) v2);\n        double[] result_ebeDivide_3 = {0.25d, 0.4d, 0.5d};\n        assertClose(\"compare vect\" ,v_ebeDivide_3.getData(),result_ebeDivide_3,normTolerance);\n\n        // octave  dot(v1,v2)\n        double dot =  v1.dotProduct(v2);\n        assertEquals(\"compare val \",32d, dot);\n\n        // octave  dot(v1,v2_t)\n        double dot_2 =  v1.dotProduct(v2_t);\n        assertEquals(\"compare val \",32d, dot_2);\n\n        RealMatrix m_outerProduct = v1.outerProduct(v2);\n        assertEquals(\"compare val \",4d, m_outerProduct.getEntry(0,0));\n\n        RealMatrix m_outerProduct_2 = v1.outerProduct(v2_t);\n        assertEquals(\"compare val \",4d, m_outerProduct_2.getEntry(0,0));\n\n        RealMatrix m_outerProduct_3 = v1.outerProduct((RealVector) v2);\n        assertEquals(\"compare val \",4d, m_outerProduct_3.getEntry(0,0));\n\n        RealVector v_unitVector = v1.unitVector();\n        RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm());\n        assertClose(\"compare vect\" ,v_unitVector.getData(),v_unitVector_2.getData(),normTolerance);\n\n        try {\n            v_null.unitVector();\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            // expected behavior\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n\n        ArrayRealVector v_unitize = (ArrayRealVector)v1.copy();\n        v_unitize.unitize();\n        assertClose(\"compare vect\" ,v_unitVector_2.getData(),v_unitize.getData(),normTolerance);\n        try {\n            v_null.unitize();\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            // expected behavior\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n\n        ArrayRealVector v_projection = v1.projection(v2);\n        double[] result_projection = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n        assertClose(\"compare vect\", v_projection.getData(), result_projection, normTolerance);\n\n        RealVector v_projection_2 = v1.projection(v2_t);\n        double[] result_projection_2 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n        assertClose(\"compare vect\", v_projection_2.getData(), result_projection_2, normTolerance);\n\n        RealVector v_projection_3 = v1.projection(v2.getData());\n        double[] result_projection_3 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n        assertClose(\"compare vect\", v_projection_3.getData(), result_projection_3, normTolerance);\n\n    }\n", "    public void testBasicFunctions() {\n        OpenMapRealVector v1 = new OpenMapRealVector(vec1);\n        OpenMapRealVector v2 = new OpenMapRealVector(vec2);\n        OpenMapRealVector v5 = new OpenMapRealVector(vec5);\n        OpenMapRealVector v_null = new OpenMapRealVector(vec_null);\n\n        SparseRealVectorTestImpl v2_t = new SparseRealVectorTestImpl(vec2);\n\n        // emacs calc: [-4, 0, 3, 1, -6, 3] A --> 8.4261497731763586307\n        double d_getNorm = v5.getNorm();\n        assertEquals(\"compare values  \", 8.4261497731763586307, d_getNorm);\n\n        // emacs calc: [-4, 0, 3, 1, -6, 3] vN --> 17\n        double d_getL1Norm = v5.getL1Norm();\n        assertEquals(\"compare values  \", 17.0, d_getL1Norm);\n\n        // emacs calc: [-4, 0, 3, 1, -6, 3] vn --> 6\n        double d_getLInfNorm = v5.getLInfNorm();\n        assertEquals(\"compare values  \", 6.0, d_getLInfNorm);\n\n        //octave =  sqrt(sumsq(v1-v2))\n        double dist = v1.getDistance(v2);\n        assertEquals(\"compare values  \",v1.subtract(v2).getNorm(), dist );\n\n        //octave =  sqrt(sumsq(v1-v2))\n        double dist_2 = v1.getDistance(v2_t);\n        assertEquals(\"compare values  \", v1.subtract(v2).getNorm(),dist_2 );\n\n        //octave =  ???\n        double d_getL1Distance = v1. getL1Distance(v2);\n        assertEquals(\"compare values  \",9d, d_getL1Distance );\n\n        double d_getL1Distance_2 = v1. getL1Distance(v2_t);\n        assertEquals(\"compare values  \",9d, d_getL1Distance_2 );\n\n        //octave =  ???\n        double d_getLInfDistance = v1. getLInfDistance(v2);\n        assertEquals(\"compare values  \",3d, d_getLInfDistance );\n\n        double d_getLInfDistance_2 = v1. getLInfDistance(v2_t);\n        assertEquals(\"compare values  \",3d, d_getLInfDistance_2 );\n\n        //octave =  v1 + v2\n        OpenMapRealVector v_add = v1.add(v2);\n        double[] result_add = {5d, 7d, 9d};\n        assertClose(\"compare vect\" ,v_add.getData(),result_add,normTolerance);\n\n        SparseRealVectorTestImpl vt2 = new SparseRealVectorTestImpl(vec2);\n        RealVector v_add_i = v1.add(vt2);\n        double[] result_add_i = {5d, 7d, 9d};\n        assertClose(\"compare vect\" ,v_add_i.getData(),result_add_i,normTolerance);\n\n        //octave =  v1 - v2\n        OpenMapRealVector v_subtract = v1.subtract(v2);\n        double[] result_subtract = {-3d, -3d, -3d};\n        assertClose(\"compare vect\" ,v_subtract.getData(),result_subtract,normTolerance);\n\n        RealVector v_subtract_i = v1.subtract(vt2);\n        double[] result_subtract_i = {-3d, -3d, -3d};\n        assertClose(\"compare vect\" ,v_subtract_i.getData(),result_subtract_i,normTolerance);\n\n        // octave v1 .* v2\n        RealVector  v_ebeMultiply = v1.ebeMultiply(v2);\n        double[] result_ebeMultiply = {4d, 10d, 18d};\n        assertClose(\"compare vect\" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);\n\n        RealVector  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);\n        double[] result_ebeMultiply_2 = {4d, 10d, 18d};\n        assertClose(\"compare vect\" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);\n\n        // octave v1 ./ v2\n        RealVector  v_ebeDivide = v1.ebeDivide(v2);\n        double[] result_ebeDivide = {0.25d, 0.4d, 0.5d};\n        assertClose(\"compare vect\" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);\n\n        RealVector  v_ebeDivide_2 = v1.ebeDivide(v2_t);\n        double[] result_ebeDivide_2 = {0.25d, 0.4d, 0.5d};\n        assertClose(\"compare vect\" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);\n\n        // octave  dot(v1,v2)\n        double dot =  v1.dotProduct(v2);\n        assertEquals(\"compare val \",32d, dot);\n\n        // octave  dot(v1,v2_t)\n        double dot_2 =  v1.dotProduct(v2_t);\n        assertEquals(\"compare val \",32d, dot_2);\n\n        RealMatrix m_outerProduct = v1.outerProduct(v2);\n        assertEquals(\"compare val \",4d, m_outerProduct.getEntry(0,0));\n\n        RealMatrix m_outerProduct_2 = v1.outerProduct(v2_t);\n        assertEquals(\"compare val \",4d, m_outerProduct_2.getEntry(0,0));\n\n        RealVector v_unitVector = v1.unitVector();\n        RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm());\n        assertClose(\"compare vect\" ,v_unitVector.getData(),v_unitVector_2.getData(),normTolerance);\n\n        try {\n            v_null.unitVector();\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            // expected behavior\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n\n        OpenMapRealVector v_unitize = v1.copy();\n        v_unitize.unitize();\n        assertClose(\"compare vect\" ,v_unitVector_2.getData(),v_unitize.getData(),normTolerance);\n        try {\n            v_null.unitize();\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            // expected behavior\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n\n        RealVector v_projection = v1.projection(v2);\n        double[] result_projection = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n        assertClose(\"compare vect\", v_projection.getData(), result_projection, normTolerance);\n\n        RealVector v_projection_2 = v1.projection(v2_t);\n        double[] result_projection_2 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n        assertClose(\"compare vect\", v_projection_2.getData(), result_projection_2, normTolerance);\n\n    }\n"], "Math_7": ["  @Test\n  public void testEventsScheduling() {\n\n      FirstOrderDifferentialEquations sincos = new FirstOrderDifferentialEquations() {\n\n          public int getDimension() {\n              return 2;\n          }\n\n          public void computeDerivatives(double t, double[] y, double[] yDot) {\n              yDot[0] =  y[1];\n              yDot[1] = -y[0];\n          }\n\n      };\n\n      SchedulingChecker sinChecker = new SchedulingChecker(0); // events at 0, PI, 2PI ...\n      SchedulingChecker cosChecker = new SchedulingChecker(1); // events at PI/2, 3PI/2, 5PI/2 ...\n\n      FirstOrderIntegrator integ =\n              new DormandPrince853Integrator(0.001, 1.0, 1.0e-12, 0.0);\n      integ.addEventHandler(sinChecker, 0.01, 1.0e-7, 100);\n      integ.addStepHandler(sinChecker);\n      integ.addEventHandler(cosChecker, 0.01, 1.0e-7, 100);\n      integ.addStepHandler(cosChecker);\n      double   t0 = 0.5;\n      double[] y0 = new double[] { FastMath.sin(t0), FastMath.cos(t0) };\n      double   t  = 10.0;\n      double[] y  = new double[2];\n      integ.integrate(sincos, t0, y0, t, y);\n\n  }\n"], "Math_83": ["    @Test\n    public void testMath286() throws OptimizationException {\n      LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 0.2, 0.3 }, 0 );\n      Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n      constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.EQ, 23.0));\n\n      RealPointValuePair solution = new SimplexSolver().optimize(f, constraints, GoalType.MAXIMIZE, true);\n      assertEquals(6.9, solution.getValue(), .0000001);\n    }\n"], "Math_84": ["  @Test\n  public void testMinimizeMaximize()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);\n      Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);\n      Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);\n      Assert.assertTrue(optimizer.getEvaluations() > 120);\n      Assert.assertTrue(optimizer.getEvaluations() < 150);\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);\n      Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);\n      Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);              \n      Assert.assertTrue(optimizer.getEvaluations() > 120);\n      Assert.assertTrue(optimizer.getEvaluations() < 150);\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);\n      Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);\n      Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);\n      Assert.assertTrue(optimizer.getEvaluations() > 120);\n      Assert.assertTrue(optimizer.getEvaluations() < 150);\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);\n      Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);\n      Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);\n      Assert.assertTrue(optimizer.getEvaluations() > 180);\n      Assert.assertTrue(optimizer.getEvaluations() < 220);\n\n  }\n", "  @Test\n  public void testMath283()\n      throws FunctionEvaluationException, OptimizationException {\n      // fails because MultiDirectional.iterateSimplex is looping forever\n      // the while(true) should be replaced with a convergence check\n      MultiDirectional multiDirectional = new MultiDirectional();\n      multiDirectional.setMaxIterations(100);\n      multiDirectional.setMaxEvaluations(1000);\n\n      final Gaussian2D function = new Gaussian2D(0.0, 0.0, 1.0);\n\n      RealPointValuePair estimate = multiDirectional.optimize(function,\n                                    GoalType.MAXIMIZE, function.getMaximumPosition());\n\n      final double EPSILON = 1e-5;\n\n      final double expectedMaximum = function.getMaximum();\n      final double actualMaximum = estimate.getValue();\n      Assert.assertEquals(expectedMaximum, actualMaximum, EPSILON);\n\n      final double[] expectedPosition = function.getMaximumPosition();\n      final double[] actualPosition = estimate.getPoint();\n      Assert.assertEquals(expectedPosition[0], actualPosition[0], EPSILON );\n      Assert.assertEquals(expectedPosition[1], actualPosition[1], EPSILON );\n      \n  }\n"], "Math_70": ["    public void testMath369() throws Exception {\n        UnivariateRealFunction f = new SinFunction();\n        UnivariateRealSolver solver = new BisectionSolver();\n        assertEquals(Math.PI, solver.solve(f, 3.0, 3.2, 3.1), solver.getAbsoluteAccuracy());\n    }\n"], "Math_13": ["    @Test\n    public void testLargeSample() {\n        Random randomizer = new Random(0x5551480dca5b369bl);\n        double maxError = 0;\n        for (int degree = 0; degree < 10; ++degree) {\n            PolynomialFunction p = buildRandomPolynomial(degree, randomizer);\n\n            PolynomialFitter fitter = new PolynomialFitter(new LevenbergMarquardtOptimizer());\n            for (int i = 0; i < 40000; ++i) {\n                double x = -1.0 + i / 20000.0;\n                fitter.addObservedPoint(1.0, x,\n                                        p.value(x) + 0.1 * randomizer.nextGaussian());\n            }\n\n            final double[] init = new double[degree + 1];\n            PolynomialFunction fitted = new PolynomialFunction(fitter.fit(init));\n\n            for (double x = -1.0; x < 1.0; x += 0.01) {\n                double error = FastMath.abs(p.value(x) - fitted.value(x)) /\n                              (1.0 + FastMath.abs(p.value(x)));\n                maxError = FastMath.max(maxError, error);\n                Assert.assertTrue(FastMath.abs(error) < 0.01);\n            }\n        }\n        Assert.assertTrue(maxError > 0.001);\n    }\n"], "Math_14": ["    @Test\n    public void testLargeSample() {\n        Random randomizer = new Random(0x5551480dca5b369bl);\n        double maxError = 0;\n        for (int degree = 0; degree < 10; ++degree) {\n            PolynomialFunction p = buildRandomPolynomial(degree, randomizer);\n\n            PolynomialFitter fitter = new PolynomialFitter(new LevenbergMarquardtOptimizer());\n            for (int i = 0; i < 40000; ++i) {\n                double x = -1.0 + i / 20000.0;\n                fitter.addObservedPoint(1.0, x,\n                                        p.value(x) + 0.1 * randomizer.nextGaussian());\n            }\n\n            final double[] init = new double[degree + 1];\n            PolynomialFunction fitted = new PolynomialFunction(fitter.fit(init));\n\n            for (double x = -1.0; x < 1.0; x += 0.01) {\n                double error = FastMath.abs(p.value(x) - fitted.value(x)) /\n                              (1.0 + FastMath.abs(p.value(x)));\n                maxError = FastMath.max(maxError, error);\n                Assert.assertTrue(FastMath.abs(error) < 0.01);\n            }\n        }\n        Assert.assertTrue(maxError > 0.001);\n    }\n"], "Math_22": ["    @Test\n    public void testIsSupportLowerBoundInclusive() {\n        final double lowerBound = distribution.getSupportLowerBound();\n        double result = Double.NaN;\n        result = distribution.density(lowerBound);\n        Assert.assertEquals(\n                !Double.isInfinite(lowerBound) && !Double.isNaN(result) &&\n                !Double.isInfinite(result),\n                distribution.isSupportLowerBoundInclusive());\n         \n    }\n", "    @Test\n    public void testIsSupportUpperBoundInclusive() {\n        final double upperBound = distribution.getSupportUpperBound();\n        double result = Double.NaN;\n        result = distribution.density(upperBound);\n        Assert.assertEquals(\n                !Double.isInfinite(upperBound) && !Double.isNaN(result) &&\n                !Double.isInfinite(result),\n                distribution.isSupportUpperBoundInclusive());\n         \n    }\n"], "Math_25": ["    @Test(expected=MathIllegalStateException.class)\n    public void testMath844() {\n        final double[] y = { 0, 1, 2, 3, 2, 1,\n                             0, -1, -2, -3, -2, -1,\n                             0, 1, 2, 3, 2, 1,\n                             0, -1, -2, -3, -2, -1,\n                             0, 1, 2, 3, 2, 1, 0 };\n        final int len = y.length;\n        final WeightedObservedPoint[] points = new WeightedObservedPoint[len];\n        for (int i = 0; i < len; i++) {\n            points[i] = new WeightedObservedPoint(1, i, y[i]);\n        }\n\n        final HarmonicFitter.ParameterGuesser guesser\n            = new HarmonicFitter.ParameterGuesser(points);\n\n        // The guesser fails because the function is far from an harmonic\n        // function: It is a triangular periodic function with amplitude 3\n        // and period 12, and all sample points are taken at integer abscissae\n        // so function values all belong to the integer subset {-3, -2, -1, 0,\n        // 1, 2, 3}.\n        guesser.guess();\n    }\n"], "Math_71": ["  public void testMissedEndEvent() throws IntegratorException, DerivativeException {\n      final double   t0     = 1878250320.0000029;\n      final double   tEvent = 1878250379.9999986;\n      final double[] k      = { 1.0e-4, 1.0e-5, 1.0e-6 };\n      FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations() {\n\n          public int getDimension() {\n              return k.length;\n          }\n\n          public void computeDerivatives(double t, double[] y, double[] yDot) {\n              for (int i = 0; i < y.length; ++i) {\n                  yDot[i] = k[i] * y[i];\n              }\n          }\n      };\n\n      ClassicalRungeKuttaIntegrator integrator = new ClassicalRungeKuttaIntegrator(60.0);\n\n      double[] y0   = new double[k.length];\n      for (int i = 0; i < y0.length; ++i) {\n          y0[i] = i + 1;\n      }\n      double[] y    = new double[k.length];\n\n      double finalT = integrator.integrate(ode, t0, y0, tEvent, y);\n      Assert.assertEquals(tEvent, finalT, 5.0e-6);\n      for (int i = 0; i < y.length; ++i) {\n          Assert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n      }\n\n      integrator.addEventHandler(new EventHandler() {\n\n          public void resetState(double t, double[] y) {\n          }\n\n          public double g(double t, double[] y) {\n              return t - tEvent;\n          }\n\n          public int eventOccurred(double t, double[] y, boolean increasing) {\n              Assert.assertEquals(tEvent, t, 5.0e-6);\n              return CONTINUE;\n          }\n      }, Double.POSITIVE_INFINITY, 1.0e-20, 100);\n      finalT = integrator.integrate(ode, t0, y0, tEvent + 120, y);\n      Assert.assertEquals(tEvent + 120, finalT, 5.0e-6);\n      for (int i = 0; i < y.length; ++i) {\n          Assert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n      }\n\n  }\n", "  public void testMissedEndEvent() throws IntegratorException, DerivativeException {\n      final double   t0     = 1878250320.0000029;\n      final double   tEvent = 1878250379.9999986;\n      final double[] k  = { 1.0e-4, 1.0e-5, 1.0e-6 };\n      FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations() {\n\n          public int getDimension() {\n              return k.length;\n          }\n\n          public void computeDerivatives(double t, double[] y, double[] yDot) {\n              for (int i = 0; i < y.length; ++i) {\n                  yDot[i] = k[i] * y[i];\n              }\n          }\n      };\n\n      DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 100.0,\n                                                                             1.0e-10, 1.0e-10);\n\n      double[] y0   = new double[k.length];\n      for (int i = 0; i < y0.length; ++i) {\n          y0[i] = i + 1;\n      }\n      double[] y    = new double[k.length];\n\n      integrator.setInitialStepSize(60.0);\n      double finalT = integrator.integrate(ode, t0, y0, tEvent, y);\n      Assert.assertEquals(tEvent, finalT, 5.0e-6);\n      for (int i = 0; i < y.length; ++i) {\n          Assert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n      }\n\n      integrator.setInitialStepSize(60.0);\n      integrator.addEventHandler(new EventHandler() {\n\n          public void resetState(double t, double[] y) {\n          }\n\n          public double g(double t, double[] y) {\n              return t - tEvent;\n          }\n\n          public int eventOccurred(double t, double[] y, boolean increasing) {\n              Assert.assertEquals(tEvent, t, 5.0e-6);\n              return CONTINUE;\n          }\n      }, Double.POSITIVE_INFINITY, 1.0e-20, 100);\n      finalT = integrator.integrate(ode, t0, y0, tEvent + 120, y);\n      Assert.assertEquals(tEvent + 120, finalT, 5.0e-6);\n      for (int i = 0; i < y.length; ++i) {\n          Assert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n      }\n\n  }\n"], "Math_1": ["    @Test\n    public void testDigitLimitConstructor() throws ConvergenceException {\n        assertFraction(2, 5, new BigFraction(0.4, 9));\n        assertFraction(2, 5, new BigFraction(0.4, 99));\n        assertFraction(2, 5, new BigFraction(0.4, 999));\n\n        assertFraction(3, 5, new BigFraction(0.6152, 9));\n        assertFraction(8, 13, new BigFraction(0.6152, 99));\n        assertFraction(510, 829, new BigFraction(0.6152, 999));\n        assertFraction(769, 1250, new BigFraction(0.6152, 9999));\n        \n        // MATH-996\n        assertFraction(1, 2, new BigFraction(0.5000000001, 10));\n    }\n", "    @Test\n    public void testDigitLimitConstructor() throws ConvergenceException  {\n        assertFraction(2, 5, new Fraction(0.4,   9));\n        assertFraction(2, 5, new Fraction(0.4,  99));\n        assertFraction(2, 5, new Fraction(0.4, 999));\n\n        assertFraction(3, 5,      new Fraction(0.6152,    9));\n        assertFraction(8, 13,     new Fraction(0.6152,   99));\n        assertFraction(510, 829,  new Fraction(0.6152,  999));\n        assertFraction(769, 1250, new Fraction(0.6152, 9999));\n\n        // MATH-996\n        assertFraction(1, 2, new Fraction(0.5000000001, 10));\n    }\n"], "Math_85": ["    public void testMath280() throws MathException {\n        NormalDistribution normal = new NormalDistributionImpl(0,1);\n        double result = normal.inverseCumulativeProbability(0.9772498680518209);\n        assertEquals(2.0, result, 1.0e-12);\n    }\n"], "Math_49": ["    @Test\n    public void testConcurrentModification() {\n        final RealVector u = new OpenMapRealVector(3, 1e-6);\n        u.setEntry(0, 1);\n        u.setEntry(1, 0);\n        u.setEntry(2, 2);\n\n        final RealVector v1 = new OpenMapRealVector(3, 1e-6);\n        final double[] v2 = new double[3];\n        v1.setEntry(0, 0);\n        v2[0] = 0;\n        v1.setEntry(1, 3);\n        v2[1] = 3;\n        v1.setEntry(2, 0);\n        v2[2] = 0;\n\n        RealVector w;\n\n        w = u.ebeMultiply(v1);\n        w = u.ebeMultiply(v2);\n\n        w = u.ebeDivide(v1);\n        w = u.ebeDivide(v2);\n    }\n"], "Math_6": ["    @Test\n    public void testTrivial() {\n        LinearProblem problem\n            = new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n        NonLinearConjugateGradientOptimizer optimizer\n            = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE,\n                                                      new SimpleValueChecker(1e-6, 1e-6));\n        PointValuePair optimum\n            = optimizer.optimize(new MaxEval(100),\n                                 problem.getObjectiveFunction(),\n                                 problem.getObjectiveFunctionGradient(),\n                                 GoalType.MINIMIZE,\n                                 new InitialGuess(new double[] { 0 }));\n        Assert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\n        Assert.assertEquals(0.0, optimum.getValue(), 1.0e-10);\n\n        // Check that the number of iterations is updated (MATH-949).\n        Assert.assertTrue(optimizer.getIterations() > 0);\n    }\n", "    @Test\n    @Retry(3)\n    public void testRosen() {\n        double[] startPoint = point(DIM,0.1);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,1.0),0.0);\n        doTest(new Rosen(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n        doTest(new Rosen(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n    }\n", "    @Test\n    @Retry(3)\n    public void testMaximize() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),1.0);\n        doTest(new MinusElli(), startPoint, insigma, boundaries,\n                GoalType.MAXIMIZE, LAMBDA, true, 0, 1.0-1e-13,\n                2e-10, 5e-6, 100000, expected);\n        doTest(new MinusElli(), startPoint, insigma, boundaries,\n                GoalType.MAXIMIZE, LAMBDA, false, 0, 1.0-1e-13,\n                2e-10, 5e-6, 100000, expected);\n        boundaries = boundaries(DIM,-0.3,0.3); \n        startPoint = point(DIM,0.1);\n        doTest(new MinusElli(), startPoint, insigma, boundaries,\n                GoalType.MAXIMIZE, LAMBDA, true, 0, 1.0-1e-13,\n                2e-10, 5e-6, 100000, expected);\n    }\n", "    @Test\n    public void testEllipse() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new Elli(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n        doTest(new Elli(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n    }\n", "    @Test\n    public void testElliRotated() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new ElliRotated(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n        doTest(new ElliRotated(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n    }\n", "    @Test\n    public void testCigar() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new Cigar(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                1e-13, 1e-6, 200000, expected);\n        doTest(new Cigar(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n    }\n", "    @Test\n    public void testCigarWithBoundaries() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = boundaries(DIM, -1e100, Double.POSITIVE_INFINITY);\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new Cigar(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                1e-13, 1e-6, 200000, expected);\n        doTest(new Cigar(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n    }\n", "    @Test\n    public void testTwoAxes() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new TwoAxes(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, 2*LAMBDA, true, 0, 1e-13,\n                1e-13, 1e-6, 200000, expected);\n        doTest(new TwoAxes(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, 2*LAMBDA, false, 0, 1e-13,\n                1e-8, 1e-3, 200000, expected);\n    }\n", "    @Test\n    public void testCigTab() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,0.3);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new CigTab(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                1e-13, 5e-5, 100000, expected);\n        doTest(new CigTab(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,\n                1e-13, 5e-5, 100000, expected);\n    }\n", "    @Test\n    public void testSphere() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new Sphere(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n        doTest(new Sphere(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n    }\n", "    @Test\n    public void testTablet() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new Tablet(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n        doTest(new Tablet(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n    }\n", "    @Test\n    public void testDiffPow() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new DiffPow(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, 10, true, 0, 1e-13,\n                1e-8, 1e-1, 100000, expected);\n        doTest(new DiffPow(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, 10, false, 0, 1e-13,\n                1e-8, 2e-1, 100000, expected);\n    }\n", "    @Test\n    public void testSsDiffPow() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new SsDiffPow(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, 10, true, 0, 1e-13,\n                1e-4, 1e-1, 200000, expected);\n        doTest(new SsDiffPow(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, 10, false, 0, 1e-13,\n                1e-4, 1e-1, 200000, expected);\n    }\n", "    @Test\n    public void testAckley() {\n        double[] startPoint = point(DIM,1.0);\n        double[] insigma = point(DIM,1.0);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new Ackley(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, 2*LAMBDA, true, 0, 1e-13,\n                1e-9, 1e-5, 100000, expected);\n        doTest(new Ackley(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, 2*LAMBDA, false, 0, 1e-13,\n                1e-9, 1e-5, 100000, expected);\n    }\n", "    @Test\n    public void testRastrigin() {\n        double[] startPoint = point(DIM,0.1);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,0.0),0.0);\n        doTest(new Rastrigin(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, (int)(200*Math.sqrt(DIM)), true, 0, 1e-13,\n                1e-13, 1e-6, 200000, expected);\n        doTest(new Rastrigin(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, (int)(200*Math.sqrt(DIM)), false, 0, 1e-13,\n                1e-13, 1e-6, 200000, expected);\n    }\n", "    @Test\n    public void testConstrainedRosen() {\n        double[] startPoint = point(DIM, 0.1);\n        double[] insigma = point(DIM, 0.1);\n        double[][] boundaries = boundaries(DIM, -1, 2);\n        PointValuePair expected =\n            new PointValuePair(point(DIM,1.0),0.0);\n        doTest(new Rosen(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, 2*LAMBDA, true, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n        doTest(new Rosen(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, 2*LAMBDA, false, 0, 1e-13,\n                1e-13, 1e-6, 100000, expected);\n    }\n", "    @Test\n    public void testDiagonalRosen() {\n        double[] startPoint = point(DIM,0.1);\n        double[] insigma = point(DIM,0.1);\n        double[][] boundaries = null;\n        PointValuePair expected =\n            new PointValuePair(point(DIM,1.0),0.0);\n        doTest(new Rosen(), startPoint, insigma, boundaries,\n                GoalType.MINIMIZE, LAMBDA, false, 1, 1e-13,\n                1e-10, 1e-4, 1000000, expected);\n     }\n", "    @Test\n    public void testSumSinc() {\n        final MultivariateFunction func = new SumSincFunction(-1);\n\n        int dim = 2;\n        final double[] minPoint = new double[dim];\n        for (int i = 0; i < dim; i++) {\n            minPoint[i] = 0;\n        }\n\n        double[] init = new double[dim];\n\n        // Initial is minimum.\n        for (int i = 0; i < dim; i++) {\n            init[i] = minPoint[i];\n        }\n        doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-9);\n\n        // Initial is far from minimum.\n        for (int i = 0; i < dim; i++) {\n            init[i] = minPoint[i] + 3;\n        }\n        doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-5);\n        // More stringent line search tolerance enhances the precision\n        // of the result.\n        doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-9, 1e-7);\n    }\n", "    @Test\n    public void testMaximizeQuadratic() {\n        final MultivariateFunction func = new MultivariateFunction() {\n                public double value(double[] x) {\n                    final double a = x[0] - 1;\n                    final double b = x[1] - 1;\n                    return -a * a - b * b + 1;\n                }\n            };\n\n        int dim = 2;\n        final double[] maxPoint = new double[dim];\n        for (int i = 0; i < dim; i++) {\n            maxPoint[i] = 1;\n        }\n\n        double[] init = new double[dim];\n\n        // Initial is minimum.\n        for (int i = 0; i < dim; i++) {\n            init[i] = maxPoint[i];\n        }\n        doTest(func, maxPoint, init,  GoalType.MAXIMIZE, 1e-9, 1e-8);\n\n        // Initial is far from minimum.\n        for (int i = 0; i < dim; i++) {\n            init[i] = maxPoint[i] - 20;\n        }\n        doTest(func, maxPoint, init, GoalType.MAXIMIZE, 1e-9, 1e-8);\n    }\n", "    @Test\n    public void testMinimize1() {\n        SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30);\n        final FourExtrema fourExtrema = new FourExtrema();\n\n        final PointValuePair optimum\n            = optimizer.optimize(new MaxEval(200),\n                                 new ObjectiveFunction(fourExtrema),\n                                 GoalType.MINIMIZE,\n                                 new InitialGuess(new double[] { -3, 0 }),\n                                 new MultiDirectionalSimplex(new double[] { 0.2, 0.2 }));\n        Assert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 4e-6);\n        Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 3e-6);\n        Assert.assertEquals(fourExtrema.valueXmYp, optimum.getValue(), 8e-13);\n        Assert.assertTrue(optimizer.getEvaluations() > 120);\n        Assert.assertTrue(optimizer.getEvaluations() < 150);\n\n        // Check that the number of iterations is updated (MATH-949).\n        Assert.assertTrue(optimizer.getIterations() > 0);\n    }\n", "    @Test\n    public void testMinimize2() {\n        SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30);\n        final FourExtrema fourExtrema = new FourExtrema();\n\n        final PointValuePair optimum\n            = optimizer.optimize(new MaxEval(200),\n                                 new ObjectiveFunction(fourExtrema),\n                                 GoalType.MINIMIZE,\n                                 new InitialGuess(new double[] { 1, 0 }),\n                                 new MultiDirectionalSimplex(new double[] { 0.2, 0.2 }));\n        Assert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 2e-8);\n        Assert.assertEquals(fourExtrema.yM, optimum.getPoint()[1], 3e-6);\n        Assert.assertEquals(fourExtrema.valueXpYm, optimum.getValue(), 2e-12);\n        Assert.assertTrue(optimizer.getEvaluations() > 120);\n        Assert.assertTrue(optimizer.getEvaluations() < 150);\n\n        // Check that the number of iterations is updated (MATH-949).\n        Assert.assertTrue(optimizer.getIterations() > 0);\n    }\n", "    @Test\n    public void testMaximize1() {\n        SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30);\n        final FourExtrema fourExtrema = new FourExtrema();\n\n        final PointValuePair optimum\n            = optimizer.optimize(new MaxEval(200),\n                                 new ObjectiveFunction(fourExtrema),\n                                 GoalType.MAXIMIZE,\n                                 new InitialGuess(new double[] { -3.0, 0.0 }),\n                                 new MultiDirectionalSimplex(new double[] { 0.2, 0.2 }));\n        Assert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 7e-7);\n        Assert.assertEquals(fourExtrema.yM, optimum.getPoint()[1], 3e-7);\n        Assert.assertEquals(fourExtrema.valueXmYm, optimum.getValue(), 2e-14);\n        Assert.assertTrue(optimizer.getEvaluations() > 120);\n        Assert.assertTrue(optimizer.getEvaluations() < 150);\n\n        // Check that the number of iterations is updated (MATH-949).\n        Assert.assertTrue(optimizer.getIterations() > 0);\n    }\n", "    @Test\n    public void testMaximize2() {\n        SimplexOptimizer optimizer = new SimplexOptimizer(new SimpleValueChecker(1e-15, 1e-30));\n        final FourExtrema fourExtrema = new FourExtrema();\n\n        final PointValuePair optimum\n            = optimizer.optimize(new MaxEval(200),\n                                 new ObjectiveFunction(fourExtrema),\n                                 GoalType.MAXIMIZE,\n                                 new InitialGuess(new double[] { 1, 0 }),\n                                 new MultiDirectionalSimplex(new double[] { 0.2, 0.2 }));\n        Assert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 2e-8);\n        Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 3e-6);\n        Assert.assertEquals(fourExtrema.valueXpYp, optimum.getValue(), 2e-12);\n        Assert.assertTrue(optimizer.getEvaluations() > 180);\n        Assert.assertTrue(optimizer.getEvaluations() < 220);\n\n        // Check that the number of iterations is updated (MATH-949).\n        Assert.assertTrue(optimizer.getIterations() > 0);\n    }\n", "    @Test\n    public void testRosenbrock() {\n        MultivariateFunction rosenbrock\n            = new MultivariateFunction() {\n                    public double value(double[] x) {\n                        ++count;\n                        double a = x[1] - x[0] * x[0];\n                        double b = 1.0 - x[0];\n                        return 100 * a * a + b * b;\n                    }\n                };\n\n        count = 0;\n        SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3);\n        PointValuePair optimum\n           = optimizer.optimize(new MaxEval(100),\n                                new ObjectiveFunction(rosenbrock),\n                                GoalType.MINIMIZE,\n                                new InitialGuess(new double[] { -1.2, 1 }),\n                                new MultiDirectionalSimplex(new double[][] {\n                                        { -1.2,  1.0 },\n                                        { 0.9, 1.2 },\n                                        {  3.5, -2.3 } }));\n\n        Assert.assertEquals(count, optimizer.getEvaluations());\n        Assert.assertTrue(optimizer.getEvaluations() > 50);\n        Assert.assertTrue(optimizer.getEvaluations() < 100);\n        Assert.assertTrue(optimum.getValue() > 1e-2);\n    }\n", "    @Test\n    public void testMinimize1() {\n        SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);\n        final FourExtrema fourExtrema = new FourExtrema();\n\n        final PointValuePair optimum\n            = optimizer.optimize(new MaxEval(100),\n                                 new ObjectiveFunction(fourExtrema),\n                                 GoalType.MINIMIZE,\n                                 new InitialGuess(new double[] { -3, 0 }),\n                                 new NelderMeadSimplex(new double[] { 0.2, 0.2 }));\n        Assert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 2e-7);\n        Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 2e-5);\n        Assert.assertEquals(fourExtrema.valueXmYp, optimum.getValue(), 6e-12);\n        Assert.assertTrue(optimizer.getEvaluations() > 60);\n        Assert.assertTrue(optimizer.getEvaluations() < 90);\n\n        // Check that the number of iterations is updated (MATH-949).\n        Assert.assertTrue(optimizer.getIterations() > 0);\n    }\n", "    @Test\n    public void testMinimize2() {\n        SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);\n        final FourExtrema fourExtrema = new FourExtrema();\n\n        final PointValuePair optimum\n            = optimizer.optimize(new MaxEval(100),\n                                 new ObjectiveFunction(fourExtrema),\n                                 GoalType.MINIMIZE,\n                                 new InitialGuess(new double[] { 1, 0 }),\n                                 new NelderMeadSimplex(new double[] { 0.2, 0.2 }));\n        Assert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 5e-6);\n        Assert.assertEquals(fourExtrema.yM, optimum.getPoint()[1], 6e-6);\n        Assert.assertEquals(fourExtrema.valueXpYm, optimum.getValue(), 1e-11);\n        Assert.assertTrue(optimizer.getEvaluations() > 60);\n        Assert.assertTrue(optimizer.getEvaluations() < 90);\n\n        // Check that the number of iterations is updated (MATH-949).\n        Assert.assertTrue(optimizer.getIterations() > 0);\n    }\n", "    @Test\n    public void testMaximize1() {\n        SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);\n        final FourExtrema fourExtrema = new FourExtrema();\n\n        final PointValuePair optimum\n            = optimizer.optimize(new MaxEval(100),\n                                 new ObjectiveFunction(fourExtrema),\n                                 GoalType.MAXIMIZE,\n                                 new InitialGuess(new double[] { -3, 0 }),\n                                 new NelderMeadSimplex(new double[] { 0.2, 0.2 }));\n        Assert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 1e-5);\n        Assert.assertEquals(fourExtrema.yM, optimum.getPoint()[1], 3e-6);\n        Assert.assertEquals(fourExtrema.valueXmYm, optimum.getValue(), 3e-12);\n        Assert.assertTrue(optimizer.getEvaluations() > 60);\n        Assert.assertTrue(optimizer.getEvaluations() < 90);\n\n        // Check that the number of iterations is updated (MATH-949).\n        Assert.assertTrue(optimizer.getIterations() > 0);\n    }\n", "    @Test\n    public void testMaximize2() {\n        SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);\n        final FourExtrema fourExtrema = new FourExtrema();\n\n        final PointValuePair optimum\n            = optimizer.optimize(new MaxEval(100),\n                                 new ObjectiveFunction(fourExtrema),\n                                 GoalType.MAXIMIZE,\n                                 new InitialGuess(new double[] { 1, 0 }),\n                                 new NelderMeadSimplex(new double[] { 0.2, 0.2 }));\n        Assert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 4e-6);\n        Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 5e-6);\n        Assert.assertEquals(fourExtrema.valueXpYp, optimum.getValue(), 7e-12);\n        Assert.assertTrue(optimizer.getEvaluations() > 60);\n        Assert.assertTrue(optimizer.getEvaluations() < 90);\n\n        // Check that the number of iterations is updated (MATH-949).\n        Assert.assertTrue(optimizer.getIterations() > 0);\n    }\n", "    @Test\n    public void testRosenbrock() {\n\n        Rosenbrock rosenbrock = new Rosenbrock();\n        SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3);\n        PointValuePair optimum\n        = optimizer.optimize(new MaxEval(100),\n                             new ObjectiveFunction(rosenbrock),\n                             GoalType.MINIMIZE,\n                             new InitialGuess(new double[] { -1.2, 1 }),\n                                new NelderMeadSimplex(new double[][] {\n                                        { -1.2,  1 },\n                                        { 0.9, 1.2 },\n                                        {  3.5, -2.3 } }));\n\n        Assert.assertEquals(rosenbrock.getCount(), optimizer.getEvaluations());\n        Assert.assertTrue(optimizer.getEvaluations() > 40);\n        Assert.assertTrue(optimizer.getEvaluations() < 50);\n        Assert.assertTrue(optimum.getValue() < 8e-4);\n    }\n", "    @Test\n    public void testTrivial() {\n        LinearProblem problem =\n            new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n        AbstractLeastSquaresOptimizer optimizer = createOptimizer();\n        PointVectorValuePair optimum =\n            optimizer.optimize(100, problem, problem.target, new double[] { 1 }, new double[] { 0 });\n        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);\n        Assert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\n        Assert.assertEquals(3.0, optimum.getValue()[0], 1.0e-10);\n        try {\n            optimizer.guessParametersErrors();\n            Assert.fail(\"an exception should have been thrown\");\n        } catch (NumberIsTooSmallException ee) {\n            // expected behavior\n        }\n    }\n", "    @Test\n    public void testGetIterations() {\n        AbstractLeastSquaresOptimizer optim = createOptimizer();\n        optim.optimize(new MaxEval(100), new Target(new double[] { 1 }),\n                       new Weight(new double[] { 1 }),\n                       new InitialGuess(new double[] { 3 }),\n                       new ModelFunction(new MultivariateVectorFunction() {\n                               @Override\n                               public double[] value(double[] point) {\n                                   return new double[] {\n                                       FastMath.pow(point[0], 4)\n                                   };\n                               }\n                           }),\n                       new ModelFunctionJacobian(new MultivariateMatrixFunction() {\n                               @Override\n                               public double[][] value(double[] point) {\n                                   return new double[][] {\n                                       { 0.25 * FastMath.pow(point[0], 3) }\n                                   };\n                               }\n                           }));\n\n        Assert.assertTrue(optim.getIterations() > 0);\n    }\n", "    @Test\n    public void testTrivial() {\n        LinearProblem problem\n            = new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n        AbstractLeastSquaresOptimizer optimizer = createOptimizer();\n        PointVectorValuePair optimum =\n            optimizer.optimize(new MaxEval(100),\n                               problem.getModelFunction(),\n                               problem.getModelFunctionJacobian(),\n                               problem.getTarget(),\n                               new Weight(new double[] { 1 }),\n                               new InitialGuess(new double[] { 0 }));\n        Assert.assertEquals(0, optimizer.getRMS(), 1e-10);\n        Assert.assertEquals(1.5, optimum.getPoint()[0], 1e-10);\n        Assert.assertEquals(3.0, optimum.getValue()[0], 1e-10);\n    }\n"], "Math_82": ["    @Test\n    public void testMath288() throws OptimizationException {\n        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 7, 3, 0, 0 }, 0 );\n        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n        constraints.add(new LinearConstraint(new double[] { 3, 0, -5, 0 }, Relationship.LEQ, 0.0));\n        constraints.add(new LinearConstraint(new double[] { 2, 0, 0, -5 }, Relationship.LEQ, 0.0));\n        constraints.add(new LinearConstraint(new double[] { 0, 3, 0, -5 }, Relationship.LEQ, 0.0));\n        constraints.add(new LinearConstraint(new double[] { 1, 0, 0, 0 }, Relationship.LEQ, 1.0));\n        constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 0 }, Relationship.LEQ, 1.0));\n\n        SimplexSolver solver = new SimplexSolver();\n        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);\n        assertEquals(10.0, solution.getValue(), .0000001);\n    }\n"], "Math_76": ["    @Test\n    public void testMath320A() {\n        RealMatrix rm = new Array2DRowRealMatrix(new double[][] {\n            { 1.0, 2.0, 3.0 }, { 2.0, 3.0, 4.0 }, { 3.0, 5.0, 7.0 }\n        });\n        double s439  = Math.sqrt(439.0);\n        double[] reference = new double[] {\n            Math.sqrt(3.0 * (21.0 + s439)), Math.sqrt(3.0 * (21.0 - s439))\n        };\n        SingularValueDecomposition svd =\n            new SingularValueDecompositionImpl(rm);\n\n        // check we get the expected theoretical singular values\n        double[] singularValues = svd.getSingularValues();\n        Assert.assertEquals(reference.length, singularValues.length);\n        for (int i = 0; i < reference.length; ++i) {\n            Assert.assertEquals(reference[i], singularValues[i], 4.0e-13);\n        }\n\n        // check the decomposition allows to recover the original matrix\n        RealMatrix recomposed = svd.getU().multiply(svd.getS()).multiply(svd.getVT());\n        Assert.assertEquals(0.0, recomposed.subtract(rm).getNorm(), 5.0e-13);\n\n        // check we can solve a singular system\n        double[] b = new double[] { 5.0, 6.0, 7.0 };\n        double[] resSVD = svd.getSolver().solve(b);\n        Assert.assertEquals(rm.getColumnDimension(), resSVD.length);\n\n        // check the solution really minimizes the residuals\n        double svdMinResidual = residual(rm, resSVD, b);\n        double epsilon = 2 * Math.ulp(svdMinResidual);\n        double h = 0.1;\n        int    k = 3;\n        for (double d0 = -k * h; d0 <= k * h; d0 += h) {\n            for (double d1 = -k * h ; d1 <= k * h; d1 += h) {\n                for (double d2 = -k * h; d2 <= k * h; d2 += h) {\n                    double[] x = new double[] { resSVD[0] + d0, resSVD[1] + d1, resSVD[2] + d2 };\n                    Assert.assertTrue((residual(rm, x, b) - svdMinResidual) > -epsilon);\n                }\n            }\n        }\n\n    }\n", "    @Test\n    public void testMath320B() {\n        RealMatrix rm = new Array2DRowRealMatrix(new double[][] {\n            { 1.0, 2.0 }, { 1.0, 2.0 }\n        });\n        SingularValueDecomposition svd =\n            new SingularValueDecompositionImpl(rm);\n        RealMatrix recomposed = svd.getU().multiply(svd.getS()).multiply(svd.getVT());\n        Assert.assertEquals(0.0, recomposed.subtract(rm).getNorm(), 2.0e-15);\n    }\n"], "Math_100": ["  public void testBoundParameters() throws EstimationException {\n      EstimatedParameter[] p = {\n        new EstimatedParameter(\"unbound0\", 2, false),\n        new EstimatedParameter(\"unbound1\", 2, false),\n        new EstimatedParameter(\"bound\",    2, true)\n      };\n      LinearProblem problem = new LinearProblem(new LinearMeasurement[] {\n        new LinearMeasurement(new double[] { 1.0, 1.0, 1.0 },\n                              new EstimatedParameter[] { p[0], p[1], p[2] },\n                              3.0),\n        new LinearMeasurement(new double[] { 1.0, -1.0, 1.0 },\n                              new EstimatedParameter[] { p[0], p[1], p[2] },\n                              1.0),\n        new LinearMeasurement(new double[] { 1.0, 3.0, 2.0 },\n                              new EstimatedParameter[] { p[0], p[1], p[2] },\n                              7.0)\n      });\n\n      GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);\n      estimator.estimate(problem);\n      assertTrue(estimator.getRMS(problem) < 1.0e-10);\n      double[][] covariances = estimator.getCovariances(problem);\n      int i0 = 0, i1 = 1;\n      if (problem.getUnboundParameters()[0].getName().endsWith(\"1\")) {\n          i0 = 1;\n          i1 = 0;\n      }\n      assertEquals(11.0 / 24, covariances[i0][i0], 1.0e-10);\n      assertEquals(-3.0 / 24, covariances[i0][i1], 1.0e-10);\n      assertEquals(-3.0 / 24, covariances[i1][i0], 1.0e-10);\n      assertEquals( 3.0 / 24, covariances[i1][i1], 1.0e-10);\n\n      double[] errors = estimator.guessParametersErrors(problem);\n      assertEquals(0, errors[i0], 1.0e-10);\n      assertEquals(0, errors[i1], 1.0e-10);\n\n  }\n"], "Math_40": ["    @Test\n    public void testIssue716() {\n        BracketingNthOrderBrentSolver solver =\n                new BracketingNthOrderBrentSolver(1.0e-12, 1.0e-10, 1.0e-22, 5);\n        UnivariateFunction sharpTurn = new UnivariateFunction() {\n            public double value(double x) {\n                return (2 * x + 1) / (1.0e9 * (x + 1));\n            }\n        };\n        double result = solver.solve(100, sharpTurn, -0.9999999, 30, 15, AllowedSolution.RIGHT_SIDE);\n        Assert.assertEquals(0, sharpTurn.value(result), solver.getFunctionValueAccuracy());\n        Assert.assertTrue(sharpTurn.value(result) >= 0);\n        Assert.assertEquals(-0.5, result, 1.0e-10);\n    }\n"], "Math_78": ["    @Test\n    public void closeEvents()\n        throws EventException, ConvergenceException, DerivativeException {\n\n        final double r1  = 90.0;\n        final double r2  = 135.0;\n        final double gap = r2 - r1;\n        EventHandler closeEventsGenerator = new EventHandler() {\n            public void resetState(double t, double[] y) {\n            }\n            public double g(double t, double[] y) {\n                return (t - r1) * (r2 - t);\n            }\n            public int eventOccurred(double t, double[] y, boolean increasing) {\n                return CONTINUE;\n            }\n        };\n\n        final double tolerance = 0.1;\n        EventState es = new EventState(closeEventsGenerator, 1.5 * gap, tolerance, 10);\n\n        double t0 = r1 - 0.5 * gap;\n        es.reinitializeBegin(t0, new double[0]);\n        AbstractStepInterpolator interpolator =\n            new DummyStepInterpolator(new double[0], true);\n        interpolator.storeTime(t0);\n\n        interpolator.shift();\n        interpolator.storeTime(0.5 * (r1 + r2));\n        Assert.assertTrue(es.evaluateStep(interpolator));\n        Assert.assertEquals(r1, es.getEventTime(), tolerance);\n        es.stepAccepted(es.getEventTime(), new double[0]);\n\n        interpolator.shift();\n        interpolator.storeTime(r2 + 0.4 * gap);\n        Assert.assertTrue(es.evaluateStep(interpolator));\n        Assert.assertEquals(r2, es.getEventTime(), tolerance);\n\n    }\n"], "Math_8": ["    @Test\n    public void testIssue942() {\n        List<Pair<Object,Double>> list = new ArrayList<Pair<Object, Double>>();\n        list.add(new Pair<Object, Double>(new Object() {}, new Double(0)));\n        list.add(new Pair<Object, Double>(new Object() {}, new Double(1)));\n        Assert.assertEquals(1, new DiscreteDistribution<Object>(list).sample(1).length);\n    }\n"], "Math_47": ["    @Test\n    public void testDivideZero() {\n        Complex x = new Complex(3.0, 4.0);\n        Complex z = x.divide(Complex.ZERO);\n        Assert.assertEquals(z, Complex.INF);\n    }\n", "    @Test\n    public void testDivideZeroZero() {\n        Complex x = new Complex(0.0, 0.0);\n        Complex z = x.divide(Complex.ZERO);\n        Assert.assertEquals(z, Complex.NaN);\n    }\n", "    @Test\n    public void testAtanInf() {\n        TestUtils.assertSame(Complex.NaN, oneInf.atan());\n        TestUtils.assertSame(Complex.NaN, oneNegInf.atan());\n        TestUtils.assertSame(Complex.NaN, infOne.atan());\n        TestUtils.assertSame(Complex.NaN, negInfOne.atan());\n        TestUtils.assertSame(Complex.NaN, infInf.atan());\n        TestUtils.assertSame(Complex.NaN, infNegInf.atan());\n        TestUtils.assertSame(Complex.NaN, negInfInf.atan());\n        TestUtils.assertSame(Complex.NaN, negInfNegInf.atan());\n    }\n", "    @Test\n    public void testAtanI() {\n        for (int i = -10; i < 10; i++) {\n            System.out.println(new Complex(0, 1 - 0.1 * i).atan());\n        }\n        Assert.assertTrue(Complex.I.atan().isInfinite());\n    }\n"], "Lang_57": ["    public void testConstructor() {\n        assertNotNull(new LocaleUtils());\n        Constructor[] cons = LocaleUtils.class.getDeclaredConstructors();\n        assertEquals(1, cons.length);\n        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n        assertEquals(true, Modifier.isPublic(LocaleUtils.class.getModifiers()));\n        assertEquals(false, Modifier.isFinal(LocaleUtils.class.getModifiers()));\n    }\n", "    public void testToLocale_1Part() {\n        assertEquals(null, LocaleUtils.toLocale((String) null));\n        \n        assertValidToLocale(\"us\");\n        assertValidToLocale(\"fr\");\n        assertValidToLocale(\"de\");\n        assertValidToLocale(\"zh\");\n        // Valid format but lang doesnt exist, should make instance anyway\n        assertValidToLocale(\"qq\");\n        \n        try {\n            LocaleUtils.toLocale(\"Us\");\n            fail(\"Should fail if not lowercase\");\n        } catch (IllegalArgumentException iae) {}\n        try {\n            LocaleUtils.toLocale(\"US\");\n            fail(\"Should fail if not lowercase\");\n        } catch (IllegalArgumentException iae) {}\n        try {\n            LocaleUtils.toLocale(\"uS\");\n            fail(\"Should fail if not lowercase\");\n        } catch (IllegalArgumentException iae) {}\n        try {\n            LocaleUtils.toLocale(\"u#\");\n            fail(\"Should fail if not lowercase\");\n        } catch (IllegalArgumentException iae) {}\n        \n        try {\n            LocaleUtils.toLocale(\"u\");\n            fail(\"Must be 2 chars if less than 5\");\n        } catch (IllegalArgumentException iae) {}\n       \n        try {\n            LocaleUtils.toLocale(\"uuu\");\n            fail(\"Must be 2 chars if less than 5\");\n        } catch (IllegalArgumentException iae) {}\n\n        try {\n            LocaleUtils.toLocale(\"uu_U\");\n            fail(\"Must be 2 chars if less than 5\");\n        } catch (IllegalArgumentException iae) {}\n    }        \n", "    public void testToLocale_2Part() {\n        assertValidToLocale(\"us_EN\", \"us\", \"EN\");\n        //valid though doesnt exist\n        assertValidToLocale(\"us_ZH\", \"us\", \"ZH\");\n        \n        try {\n            LocaleUtils.toLocale(\"us-EN\");\n            fail(\"Should fail as not underscore\");\n        } catch (IllegalArgumentException iae) {}\n        try {\n            LocaleUtils.toLocale(\"us_En\");\n            fail(\"Should fail second part not uppercase\");\n        } catch (IllegalArgumentException iae) {}\n        try {\n            LocaleUtils.toLocale(\"us_en\");\n            fail(\"Should fail second part not uppercase\");\n        } catch (IllegalArgumentException iae) {}\n        try {\n            LocaleUtils.toLocale(\"us_eN\");\n            fail(\"Should fail second part not uppercase\");\n        } catch (IllegalArgumentException iae) {}\n        try {\n            LocaleUtils.toLocale(\"uS_EN\");\n            fail(\"Should fail first part not lowercase\");\n        } catch (IllegalArgumentException iae) {}\n        try {\n            LocaleUtils.toLocale(\"us_E3\");\n            fail(\"Should fail second part not uppercase\");\n        } catch (IllegalArgumentException iae) {}\n    }        \n", "    public void testToLocale_3Part() {\n        assertValidToLocale(\"us_EN_A\", \"us\", \"EN\", \"A\");\n        // this isn't pretty, but was caused by a jdk bug it seems\n        // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4210525\n        if (SystemUtils.isJavaVersionAtLeast(1.4f)) {\n            assertValidToLocale(\"us_EN_a\", \"us\", \"EN\", \"a\");\n            assertValidToLocale(\"us_EN_SFsafdFDsdfF\", \"us\", \"EN\", \"SFsafdFDsdfF\");\n        } else {\n            assertValidToLocale(\"us_EN_a\", \"us\", \"EN\", \"A\");\n            assertValidToLocale(\"us_EN_SFsafdFDsdfF\", \"us\", \"EN\", \"SFSAFDFDSDFF\");\n        }\n        \n        try {\n            LocaleUtils.toLocale(\"us_EN-a\");\n            fail(\"Should fail as not underscore\");\n        } catch (IllegalArgumentException iae) {}\n        try {\n            LocaleUtils.toLocale(\"uu_UU_\");\n            fail(\"Must be 3, 5 or 7+ in length\");\n        } catch (IllegalArgumentException iae) {}\n    }\n", "    public void testLocaleLookupList_Locale() {\n        assertLocaleLookupList(null, null, new Locale[0]);\n        assertLocaleLookupList(LOCALE_QQ, null, new Locale[]{LOCALE_QQ});\n        assertLocaleLookupList(LOCALE_EN, null, new Locale[]{LOCALE_EN});\n        assertLocaleLookupList(LOCALE_EN, null, new Locale[]{LOCALE_EN});\n        assertLocaleLookupList(LOCALE_EN_US, null,\n            new Locale[] {\n                LOCALE_EN_US,\n                LOCALE_EN});\n        assertLocaleLookupList(LOCALE_EN_US_ZZZZ, null,\n            new Locale[] {\n                LOCALE_EN_US_ZZZZ,\n                LOCALE_EN_US,\n                LOCALE_EN});\n    }        \n", "    public void testLocaleLookupList_LocaleLocale() {\n        assertLocaleLookupList(LOCALE_QQ, LOCALE_QQ, \n                new Locale[]{LOCALE_QQ});\n        assertLocaleLookupList(LOCALE_EN, LOCALE_EN, \n                new Locale[]{LOCALE_EN});\n        \n        assertLocaleLookupList(LOCALE_EN_US, LOCALE_EN_US, \n            new Locale[]{\n                LOCALE_EN_US,\n                LOCALE_EN});\n        assertLocaleLookupList(LOCALE_EN_US, LOCALE_QQ,\n            new Locale[] {\n                LOCALE_EN_US,\n                LOCALE_EN,\n                LOCALE_QQ});\n        assertLocaleLookupList(LOCALE_EN_US, LOCALE_QQ_ZZ,\n            new Locale[] {\n                LOCALE_EN_US,\n                LOCALE_EN,\n                LOCALE_QQ_ZZ});\n        \n        assertLocaleLookupList(LOCALE_EN_US_ZZZZ, null,\n            new Locale[] {\n                LOCALE_EN_US_ZZZZ,\n                LOCALE_EN_US,\n                LOCALE_EN});\n        assertLocaleLookupList(LOCALE_EN_US_ZZZZ, LOCALE_EN_US_ZZZZ,\n            new Locale[] {\n                LOCALE_EN_US_ZZZZ,\n                LOCALE_EN_US,\n                LOCALE_EN});\n        assertLocaleLookupList(LOCALE_EN_US_ZZZZ, LOCALE_QQ,\n            new Locale[] {\n                LOCALE_EN_US_ZZZZ,\n                LOCALE_EN_US,\n                LOCALE_EN,\n                LOCALE_QQ});\n        assertLocaleLookupList(LOCALE_EN_US_ZZZZ, LOCALE_QQ_ZZ,\n            new Locale[] {\n                LOCALE_EN_US_ZZZZ,\n                LOCALE_EN_US,\n                LOCALE_EN,\n                LOCALE_QQ_ZZ});\n        assertLocaleLookupList(LOCALE_FR_CA, LOCALE_EN,\n            new Locale[] {\n                LOCALE_FR_CA,\n                LOCALE_FR,\n                LOCALE_EN});\n    }\n", "    public void testAvailableLocaleList() {\n        List list = LocaleUtils.availableLocaleList();\n        List list2 = LocaleUtils.availableLocaleList();\n        assertNotNull(list);\n        assertSame(list, list2);\n        assertUnmodifiableCollection(list);\n        \n        Locale[] jdkLocaleArray = Locale.getAvailableLocales();\n        List jdkLocaleList = Arrays.asList(jdkLocaleArray);\n        assertEquals(jdkLocaleList, list);\n    }\n", "    public void testAvailableLocaleSet() {\n        Set set = LocaleUtils.availableLocaleSet();\n        Set set2 = LocaleUtils.availableLocaleSet();\n        assertNotNull(set);\n        assertSame(set, set2);\n        assertUnmodifiableCollection(set);\n        \n        Locale[] jdkLocaleArray = Locale.getAvailableLocales();\n        List jdkLocaleList = Arrays.asList(jdkLocaleArray);\n        Set jdkLocaleSet = new HashSet(jdkLocaleList);\n        assertEquals(jdkLocaleSet, set);\n    }\n", "    public void testIsAvailableLocale() {\n        Set set = LocaleUtils.availableLocaleSet();\n        assertEquals(set.contains(LOCALE_EN), LocaleUtils.isAvailableLocale(LOCALE_EN));\n        assertEquals(set.contains(LOCALE_EN_US), LocaleUtils.isAvailableLocale(LOCALE_EN_US));\n        assertEquals(set.contains(LOCALE_EN_US_ZZZZ), LocaleUtils.isAvailableLocale(LOCALE_EN_US_ZZZZ));\n        assertEquals(set.contains(LOCALE_FR), LocaleUtils.isAvailableLocale(LOCALE_FR));\n        assertEquals(set.contains(LOCALE_FR_CA), LocaleUtils.isAvailableLocale(LOCALE_FR_CA));\n        assertEquals(set.contains(LOCALE_QQ), LocaleUtils.isAvailableLocale(LOCALE_QQ));\n        assertEquals(set.contains(LOCALE_QQ_ZZ), LocaleUtils.isAvailableLocale(LOCALE_QQ_ZZ));\n    }\n", "    public void testLanguagesByCountry() {\n        assertLanguageByCountry(null, new String[0]);\n        assertLanguageByCountry(\"GB\", new String[]{\"en\"});\n        assertLanguageByCountry(\"ZZ\", new String[0]);\n        assertLanguageByCountry(\"CH\", new String[]{\"fr\", \"de\", \"it\"});\n    }\n", "    public void testCountriesByLanguage() {}\n"], "Chart_18": ["    public void testRemoveValue() {\n        DefaultCategoryDataset d = new DefaultCategoryDataset();\n        d.removeValue(\"R1\", \"C1\");\n        d.addValue(new Double(1.0), \"R1\", \"C1\");\n        d.removeValue(\"R1\", \"C1\");\n        assertEquals(0, d.getRowCount());\n        assertEquals(0, d.getColumnCount());\n        \n        d.addValue(new Double(1.0), \"R1\", \"C1\");\n        d.addValue(new Double(2.0), \"R2\", \"C1\");\n        d.removeValue(\"R1\", \"C1\");\n        assertEquals(new Double(2.0), d.getValue(0, 0));\n        \n        boolean pass = false;\n        try {\n            d.removeValue(null, \"C1\");\n        }\n        catch (IllegalArgumentException e) {\n            pass = true;\n        }\n        assertTrue(pass);\n\n        pass = false;\n        try {\n            d.removeValue(\"R1\", null);\n        }\n        catch (IllegalArgumentException e) {\n            pass = true;\n        }\n        assertTrue(pass);\n    }\n", "    public void testBug1835955() {\n    \tDefaultCategoryDataset d = new DefaultCategoryDataset();\n    \td.addValue(1.0, \"R1\", \"C1\");\n    \td.addValue(2.0, \"R2\", \"C2\");\n    \td.removeColumn(\"C2\");\n    \td.addValue(3.0, \"R2\", \"C2\");\n    \tassertEquals(3.0, d.getValue(\"R2\", \"C2\").doubleValue(), EPSILON);\n    }\n", "    public void testRemoveValue() {\n        DefaultKeyedValues2D d = new DefaultKeyedValues2D();\n        d.removeValue(\"R1\", \"C1\");\n        d.addValue(new Double(1.0), \"R1\", \"C1\");\n        d.removeValue(\"R1\", \"C1\");\n        assertEquals(0, d.getRowCount());\n        assertEquals(0, d.getColumnCount());\n        \n        d.addValue(new Double(1.0), \"R1\", \"C1\");\n        d.addValue(new Double(2.0), \"R2\", \"C1\");\n        d.removeValue(\"R1\", \"C1\");\n        assertEquals(new Double(2.0), d.getValue(0, 0));\n    }\n", "    public void testRemoveValueBug1690654() {\n        DefaultKeyedValues2D d = new DefaultKeyedValues2D();\n        d.addValue(new Double(1.0), \"R1\", \"C1\");\n        d.addValue(new Double(2.0), \"R2\", \"C2\");\n        assertEquals(2, d.getColumnCount());\n        assertEquals(2, d.getRowCount());\n        d.removeValue(\"R2\", \"C2\");\n        assertEquals(1, d.getColumnCount());\n        assertEquals(1, d.getRowCount());\n        assertEquals(new Double(1.0), d.getValue(0, 0));\n    }\n", "    public void testRemoveColumnByKey() {\n    \tDefaultKeyedValues2D d = new DefaultKeyedValues2D();\n    \td.addValue(new Double(1.0), \"R1\", \"C1\");\n    \td.addValue(new Double(2.0), \"R2\", \"C2\");\n    \td.removeColumn(\"C2\");\n    \td.addValue(new Double(3.0), \"R2\", \"C2\");\n    \tassertEquals(3.0, d.getValue(\"R2\", \"C2\").doubleValue(), EPSILON);\n    \t\n    \t// check for unknown column\n    \tboolean pass = false;\n    \ttry {\n    \t\td.removeColumn(\"XXX\");\n    \t}\n    \tcatch (UnknownKeyException e) {\n    \t\tpass = true;\n    \t}\n    \tassertTrue(pass);\n    }\n", "    public void testGetIndex2() {\n    \tDefaultKeyedValues v = new DefaultKeyedValues();\n    \tassertEquals(-1, v.getIndex(\"K1\"));\n    \tv.addValue(\"K1\", 1.0);\n    \tassertEquals(0, v.getIndex(\"K1\"));\n    \tv.removeValue(\"K1\");\n    \tassertEquals(-1, v.getIndex(\"K1\"));\n    }\n", "    public void testRemoveValue() {\n        DefaultKeyedValues data = new DefaultKeyedValues();\n        data.addValue(\"A\", new Double(1.0));\n        data.addValue(\"B\", null);\n        data.addValue(\"C\", new Double(3.0));\n        data.addValue(\"D\", new Double(2.0));\n        assertEquals(1, data.getIndex(\"B\"));\n        data.removeValue(\"B\");\n        assertEquals(-1, data.getIndex(\"B\"));\n        \n        boolean pass = false;\n        try {\n            data.removeValue(\"XXX\");\n        }\n        catch (UnknownKeyException e) {\n            pass = true;   \n        }\n        assertTrue(pass);\n    }\n"], "Closure_22": ["  public void testUselessCode() {\n    test(\"function f(x) { if(x) return; }\", ok);\n    test(\"function f(x) { if(x); }\", \"function f(x) { if(x); }\", e);\n\n    test(\"if(x) x = y;\", ok);\n    test(\"if(x) x == bar();\", \"if(x) JSCOMPILER_PRESERVE(x == bar());\", e);\n\n    test(\"x = 3;\", ok);\n    test(\"x == 3;\", \"JSCOMPILER_PRESERVE(x == 3);\", e);\n\n    test(\"var x = 'test'\", ok);\n    test(\"var x = 'test'\\n'str'\",\n         \"var x = 'test'\\nJSCOMPILER_PRESERVE('str')\", e);\n\n    test(\"\", ok);\n    test(\"foo();;;;bar();;;;\", ok);\n\n    test(\"var a, b; a = 5, b = 6\", ok);\n    test(\"var a, b; a = 5, b == 6\",\n         \"var a, b; a = 5, JSCOMPILER_PRESERVE(b == 6)\", e);\n    test(\"var a, b; a = (5, 6)\",\n         \"var a, b; a = (JSCOMPILER_PRESERVE(5), 6)\", e);\n    test(\"var a, b; a = (bar(), 6, 7)\",\n         \"var a, b; a = (bar(), JSCOMPILER_PRESERVE(6), 7)\", e);\n    test(\"var a, b; a = (bar(), bar(), 7, 8)\",\n         \"var a, b; a = (bar(), bar(), JSCOMPILER_PRESERVE(7), 8)\", e);\n    test(\"var a, b; a = (b = 7, 6)\", ok);\n    test(\"function x(){}\\nfunction f(a, b){}\\nf(1,(x(), 2));\", ok);\n    test(\"function x(){}\\nfunction f(a, b){}\\nf(1,(2, 3));\",\n         \"function x(){}\\nfunction f(a, b){}\\n\" +\n         \"f(1,(JSCOMPILER_PRESERVE(2), 3));\", e);\n  }\n", "  public void testUselessCodeInFor() {\n    test(\"for(var x = 0; x < 100; x++) { foo(x) }\", ok);\n    test(\"for(; true; ) { bar() }\", ok);\n    test(\"for(foo(); true; foo()) { bar() }\", ok);\n    test(\"for(void 0; true; foo()) { bar() }\",\n         \"for(JSCOMPILER_PRESERVE(void 0); true; foo()) { bar() }\", e);\n    test(\"for(foo(); true; void 0) { bar() }\",\n         \"for(foo(); true; JSCOMPILER_PRESERVE(void 0)) { bar() }\", e);\n    test(\"for(foo(); true; (1, bar())) { bar() }\",\n         \"for(foo(); true; (JSCOMPILER_PRESERVE(1), bar())) { bar() }\", e);\n\n    test(\"for(foo in bar) { foo() }\", ok);\n    test(\"for (i = 0; el = el.previousSibling; i++) {}\", ok);\n    test(\"for (i = 0; el = el.previousSibling; i++);\", ok);\n  }\n"], "Lang_50": ["    public void test_changeDefault_Locale_DateInstance() {\n        Locale realDefaultLocale = Locale.getDefault();\n        try {\n            Locale.setDefault(Locale.US);\n            FastDateFormat format1 = FastDateFormat.getDateInstance(FastDateFormat.FULL, Locale.GERMANY);\n            FastDateFormat format2 = FastDateFormat.getDateInstance(FastDateFormat.FULL);\n            Locale.setDefault(Locale.GERMANY);\n            FastDateFormat format3 = FastDateFormat.getDateInstance(FastDateFormat.FULL);\n\n            assertSame(Locale.GERMANY, format1.getLocale());\n            assertSame(Locale.US, format2.getLocale());\n            assertSame(Locale.GERMANY, format3.getLocale());\n            assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2);\n            assertTrue(format2 != format3);\n\n        } finally {\n            Locale.setDefault(realDefaultLocale);\n        }\n    }\n", "    public void test_changeDefault_Locale_DateTimeInstance() {\n        Locale realDefaultLocale = Locale.getDefault();\n        try {\n            Locale.setDefault(Locale.US);\n            FastDateFormat format1 = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL, Locale.GERMANY);\n            FastDateFormat format2 = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL);\n            Locale.setDefault(Locale.GERMANY);\n            FastDateFormat format3 = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL);\n\n            assertSame(Locale.GERMANY, format1.getLocale());\n            assertSame(Locale.US, format2.getLocale());\n            assertSame(Locale.GERMANY, format3.getLocale());\n            assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2);\n            assertTrue(format2 != format3);\n\n        } finally {\n            Locale.setDefault(realDefaultLocale);\n        }\n    }\n"], "Closure_25": ["  public void testBackwardsInferenceNew() {\n    inFunction(\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" * @param {{foo: (number|undefined)}} x\\n\" +\n        \" */\" +\n        \"function F(x) {}\" +\n        \"var y = {};\" +\n        \"new F(y);\");\n\n    assertEquals(\"{foo: (number|undefined)}\", getType(\"y\").toString());\n  }\n"], "Chart_20": ["    public void test1808376() {\n        Stroke stroke = new BasicStroke(1.0f);\n        Stroke outlineStroke = new BasicStroke(2.0f);\n        ValueMarker m = new ValueMarker(1.0, Color.red, stroke, Color.blue, \n                outlineStroke, 0.5f);\n        assertEquals(1.0, m.getValue(), EPSILON);\n        assertEquals(Color.red, m.getPaint());\n        assertEquals(stroke, m.getStroke());\n        assertEquals(Color.blue, m.getOutlinePaint());\n        assertEquals(outlineStroke, m.getOutlineStroke());\n        assertEquals(0.5f, m.getAlpha(), EPSILON);\n    }\n"], "Lang_8": ["    @Test\n    public void testCalendarTimezoneRespected() {\n        String[] availableZones = TimeZone.getAvailableIDs();\n        TimeZone currentZone = TimeZone.getDefault();\n        \n        TimeZone anotherZone = null;\n        for (String zone : availableZones) {\n            if (!zone.equals(currentZone.getID())) {\n                anotherZone = TimeZone.getTimeZone(zone);\n            }\n        }\n        \n        assertNotNull(\"Cannot find another timezone\", anotherZone);\n        \n        final String pattern = \"h:mma z\";\n        final Calendar cal = Calendar.getInstance(anotherZone);\n        \n        SimpleDateFormat sdf = new SimpleDateFormat(pattern);\n        sdf.setTimeZone(anotherZone);\n        String expectedValue = sdf.format(cal.getTime());\n        String actualValue = FastDateFormat.getInstance(pattern).format(cal);\n        assertEquals(expectedValue, actualValue);\n    }\n"], "Lang_1": ["    @Test\n    public void TestLang747() {\n        assertEquals(Integer.valueOf(0x8000),      NumberUtils.createNumber(\"0x8000\"));\n        assertEquals(Integer.valueOf(0x80000),     NumberUtils.createNumber(\"0x80000\"));\n        assertEquals(Integer.valueOf(0x800000),    NumberUtils.createNumber(\"0x800000\"));\n        assertEquals(Integer.valueOf(0x8000000),   NumberUtils.createNumber(\"0x8000000\"));\n        assertEquals(Integer.valueOf(0x7FFFFFFF),  NumberUtils.createNumber(\"0x7FFFFFFF\"));\n        assertEquals(Long.valueOf(0x80000000L),    NumberUtils.createNumber(\"0x80000000\"));\n        assertEquals(Long.valueOf(0xFFFFFFFFL),    NumberUtils.createNumber(\"0xFFFFFFFF\"));\n\n        // Leading zero tests\n        assertEquals(Integer.valueOf(0x8000000),   NumberUtils.createNumber(\"0x08000000\"));\n        assertEquals(Integer.valueOf(0x7FFFFFFF),  NumberUtils.createNumber(\"0x007FFFFFFF\"));\n        assertEquals(Long.valueOf(0x80000000L),    NumberUtils.createNumber(\"0x080000000\"));\n        assertEquals(Long.valueOf(0xFFFFFFFFL),    NumberUtils.createNumber(\"0x00FFFFFFFF\"));\n\n        assertEquals(Long.valueOf(0x800000000L),        NumberUtils.createNumber(\"0x800000000\"));\n        assertEquals(Long.valueOf(0x8000000000L),       NumberUtils.createNumber(\"0x8000000000\"));\n        assertEquals(Long.valueOf(0x80000000000L),      NumberUtils.createNumber(\"0x80000000000\"));\n        assertEquals(Long.valueOf(0x800000000000L),     NumberUtils.createNumber(\"0x800000000000\"));\n        assertEquals(Long.valueOf(0x8000000000000L),    NumberUtils.createNumber(\"0x8000000000000\"));\n        assertEquals(Long.valueOf(0x80000000000000L),   NumberUtils.createNumber(\"0x80000000000000\"));\n        assertEquals(Long.valueOf(0x800000000000000L),  NumberUtils.createNumber(\"0x800000000000000\"));\n        assertEquals(Long.valueOf(0x7FFFFFFFFFFFFFFFL), NumberUtils.createNumber(\"0x7FFFFFFFFFFFFFFF\"));\n        // N.B. Cannot use a hex constant such as 0x8000000000000000L here as that is interpreted as a negative long\n        assertEquals(new BigInteger(\"8000000000000000\", 16), NumberUtils.createNumber(\"0x8000000000000000\"));\n        assertEquals(new BigInteger(\"FFFFFFFFFFFFFFFF\", 16), NumberUtils.createNumber(\"0xFFFFFFFFFFFFFFFF\"));\n\n        // Leading zero tests\n        assertEquals(Long.valueOf(0x80000000000000L),   NumberUtils.createNumber(\"0x00080000000000000\"));\n        assertEquals(Long.valueOf(0x800000000000000L),  NumberUtils.createNumber(\"0x0800000000000000\"));\n        assertEquals(Long.valueOf(0x7FFFFFFFFFFFFFFFL), NumberUtils.createNumber(\"0x07FFFFFFFFFFFFFFF\"));\n        // N.B. Cannot use a hex constant such as 0x8000000000000000L here as that is interpreted as a negative long\n        assertEquals(new BigInteger(\"8000000000000000\", 16), NumberUtils.createNumber(\"0x00008000000000000000\"));\n        assertEquals(new BigInteger(\"FFFFFFFFFFFFFFFF\", 16), NumberUtils.createNumber(\"0x0FFFFFFFFFFFFFFFF\"));\n    }\n"], "Closure_13": ["  public void testIssue787() {\n    CompilerOptions options = createCompilerOptions();\n    CompilationLevel level = CompilationLevel.SIMPLE_OPTIMIZATIONS;\n    level.setOptionsForCompilationLevel(options);\n    WarningLevel warnings = WarningLevel.DEFAULT;\n    warnings.setOptionsForWarningLevel(options);\n\n    String code = \"\" +\n        \"function some_function() {\\n\" +\n        \"  var fn1;\\n\" +\n        \"  var fn2;\\n\" +\n        \"\\n\" +\n        \"  if (any_expression) {\\n\" +\n        \"    fn2 = external_ref;\\n\" +\n        \"    fn1 = function (content) {\\n\" +\n        \"      return fn2();\\n\" +\n        \"    }\\n\" +\n        \"  }\\n\" +\n        \"\\n\" +\n        \"  return {\\n\" +\n        \"    method1: function () {\\n\" +\n        \"      if (fn1) fn1();\\n\" +\n        \"      return true;\\n\" +\n        \"    },\\n\" +\n        \"    method2: function () {\\n\" +\n        \"      return false;\\n\" +\n        \"    }\\n\" +\n        \"  }\\n\" +\n        \"}\";\n\n    String result = \"\" +\n        \"function some_function() {\\n\" +\n        \"  var a, b;\\n\" +\n        \"  any_expression && (b = external_ref, a = function() {\\n\" +\n        \"    return b()\\n\" +\n        \"  });\\n\" +\n        \"  return{method1:function() {\\n\" +\n        \"    a && a();\\n\" +\n        \"    return !0\\n\" +\n        \"  }, method2:function() {\\n\" +\n        \"    return !1\\n\" +\n        \"  }}\\n\" +\n        \"}\\n\" +\n        \"\";\n\n    test(options, code, result);\n  }\n"], "Chart_16": ["    public void testCloning2() {\n    \tDefaultIntervalCategoryDataset d1 \n                = new DefaultIntervalCategoryDataset(new double[0][0], \n        \t\t    new double[0][0]);\n        DefaultIntervalCategoryDataset d2 = null;\n        try {\n            d2 = (DefaultIntervalCategoryDataset) d1.clone();\n        }\n        catch (CloneNotSupportedException e) {\n            e.printStackTrace();\n        }\n        assertTrue(d1 != d2);\n        assertTrue(d1.getClass() == d2.getClass());\n        assertTrue(d1.equals(d2));\t\n    }\n", "    public void testGetSeriesIndex() {\n    \t// check an empty dataset\n    \tDefaultIntervalCategoryDataset empty \n    \t        = new DefaultIntervalCategoryDataset(new double[0][0], \n    \t        \t\tnew double[0][0]);\n    \tassertEquals(-1, empty.getSeriesIndex(\"ABC\"));\n    }\n", "    public void testGetRowIndex() {\n    \t// check an empty dataset\n    \tDefaultIntervalCategoryDataset empty \n    \t        = new DefaultIntervalCategoryDataset(new double[0][0], \n    \t        \t\tnew double[0][0]);\n    \tassertEquals(-1, empty.getRowIndex(\"ABC\"));\n    }\n", "    public void testGetCategoryIndex() {\n    \t// check an empty dataset\n    \tDefaultIntervalCategoryDataset empty \n    \t        = new DefaultIntervalCategoryDataset(new double[0][0], \n    \t        \t\tnew double[0][0]);\n    \tassertEquals(-1, empty.getCategoryIndex(\"ABC\"));\n    }\n", "    public void testGetColumnIndex() {\n    \t// check an empty dataset\n    \tDefaultIntervalCategoryDataset empty \n    \t        = new DefaultIntervalCategoryDataset(new double[0][0], \n    \t        \t\tnew double[0][0]);\n    \tassertEquals(-1, empty.getColumnIndex(\"ABC\"));\n    }\n", "    public void testSetCategoryKeys() {\n    \t// check an empty dataset\n    \tDefaultIntervalCategoryDataset empty \n    \t        = new DefaultIntervalCategoryDataset(new double[0][0], \n    \t        \t\tnew double[0][0]);\n    \tboolean pass = true;\n    \ttry {\n    \t\tempty.setCategoryKeys(new String[0]);\n    \t}\n    \tcatch (RuntimeException e) {\n    \t\tpass = false;\n    \t}\n    \tassertTrue(pass);\n    }\n", "    public void testGetColumnCount() {\n    \t// check an empty dataset\n    \tDefaultIntervalCategoryDataset empty \n    \t        = new DefaultIntervalCategoryDataset(new double[0][0], \n    \t        \t\tnew double[0][0]);\n        assertEquals(0, empty.getColumnCount());\n    }\n", "    public void testGetRowCount() {\n    \t// check an empty dataset\n    \tDefaultIntervalCategoryDataset empty \n    \t        = new DefaultIntervalCategoryDataset(new double[0][0], \n    \t        \t\tnew double[0][0]);\n        assertEquals(0, empty.getColumnCount());\n    }\n"], "Lang_59": ["    public void testLang299() {\n        StrBuilder sb = new StrBuilder(1);\n        sb.appendFixedWidthPadRight(\"foo\", 1, '-');\n        assertEquals(\"f\", sb.toString());\n    }\n"], "Lang_61": ["    public void testLang294() {\n        StrBuilder sb = new StrBuilder(\"\\n%BLAH%\\nDo more stuff\\neven more stuff\\n%BLAH%\\n\");\n        sb.deleteAll(\"\\n%BLAH%\");\n        assertEquals(\"\\nDo more stuff\\neven more stuff\\n\", sb.toString()); \n    }\n", "    public void testIndexOfLang294() {\n        StrBuilder sb = new StrBuilder(\"onetwothree\");\n        sb.deleteFirst(\"three\");\n        assertEquals(-1, sb.indexOf(\"three\"));\n    }\n"], "Lang_6": ["    @Test\n    public void testEscapeSurrogatePairs() throws Exception {\n        assertEquals(\"\\uD83D\\uDE30\", StringEscapeUtils.escapeCsv(\"\\uD83D\\uDE30\"));\n        // Examples from https://en.wikipedia.org/wiki/UTF-16\n        assertEquals(\"\\uD800\\uDC00\", StringEscapeUtils.escapeCsv(\"\\uD800\\uDC00\"));\n        assertEquals(\"\\uD834\\uDD1E\", StringEscapeUtils.escapeCsv(\"\\uD834\\uDD1E\"));\n        assertEquals(\"\\uDBFF\\uDFFD\", StringEscapeUtils.escapeCsv(\"\\uDBFF\\uDFFD\"));\n        \n    }\n"], "Chart_11": ["    public void testEqualGeneralPaths() {\n        GeneralPath g1 = new GeneralPath();\n        g1.moveTo(1.0f, 2.0f);\n        g1.lineTo(3.0f, 4.0f);\n        g1.curveTo(5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f);\n        g1.quadTo(1.0f, 2.0f, 3.0f, 4.0f);\n        g1.closePath();\n        GeneralPath g2 = new GeneralPath();\n        g2.moveTo(1.0f, 2.0f);\n        g2.lineTo(3.0f, 4.0f);\n        g2.curveTo(5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f);\n        g2.quadTo(1.0f, 2.0f, 3.0f, 4.0f);\n        g2.closePath();\n        assertTrue(ShapeUtilities.equal(g1, g2));\n\n        g2 = new GeneralPath();\n        g2.moveTo(11.0f, 22.0f);\n        g2.lineTo(3.0f, 4.0f);\n        g2.curveTo(5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f);\n        g2.quadTo(1.0f, 2.0f, 3.0f, 4.0f);\n        g2.closePath();\n        assertFalse(ShapeUtilities.equal(g1, g2));\n\n        g2 = new GeneralPath();\n        g2.moveTo(1.0f, 2.0f);\n        g2.lineTo(33.0f, 44.0f);\n        g2.curveTo(5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f);\n        g2.quadTo(1.0f, 2.0f, 3.0f, 4.0f);\n        g2.closePath();\n        assertFalse(ShapeUtilities.equal(g1, g2));\n\n        g2 = new GeneralPath();\n        g2.moveTo(1.0f, 2.0f);\n        g2.lineTo(3.0f, 4.0f);\n        g2.curveTo(55.0f, 66.0f, 77.0f, 88.0f, 99.0f, 100.0f);\n        g2.quadTo(1.0f, 2.0f, 3.0f, 4.0f);\n        g2.closePath();\n        assertFalse(ShapeUtilities.equal(g1, g2));\n\n        g2 = new GeneralPath();\n        g2.moveTo(1.0f, 2.0f);\n        g2.lineTo(3.0f, 4.0f);\n        g2.curveTo(5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f);\n        g2.quadTo(11.0f, 22.0f, 33.0f, 44.0f);\n        g2.closePath();\n        assertFalse(ShapeUtilities.equal(g1, g2));\n\n        g2 = new GeneralPath();\n        g2.moveTo(1.0f, 2.0f);\n        g2.lineTo(3.0f, 4.0f);\n        g2.curveTo(5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f);\n        g2.quadTo(1.0f, 2.0f, 3.0f, 4.0f);\n        g2.lineTo(3.0f, 4.0f);\n        g2.closePath();\n        assertFalse(ShapeUtilities.equal(g1, g2));\n    }\n"], "Closure_14": ["  public void testIssue779() {\n    testNotMissing(\n        \"var a = f(); try { alert(); if (a > 0) return 1; }\" +\n        \"finally { a = 5; } return 2;\");\n  }\n", "  public void testDeepNestedBreakwithFinally() {\n    String src = \"X:while(1){try{while(2){try{var a;break X;}\" +\n        \"finally{}}}finally{}}\";\n    ControlFlowGraph<Node> cfg = createCfg(src);\n    assertDownEdge(cfg, Token.WHILE, Token.BLOCK, Branch.ON_TRUE);\n    assertDownEdge(cfg, Token.BLOCK, Token.TRY, Branch.UNCOND);\n    assertDownEdge(cfg, Token.BLOCK, Token.VAR, Branch.UNCOND);\n    // BREAK to FINALLY.\n    assertCrossEdge(cfg, Token.BREAK, Token.BLOCK, Branch.UNCOND);\n    // FINALLY to FINALLY.\n    assertCrossEdge(cfg, Token.BLOCK, Token.BLOCK, Branch.ON_EX);\n    assertCrossEdge(cfg, Token.WHILE, Token.BLOCK, Branch.ON_FALSE);\n    assertReturnEdge(cfg, Token.BLOCK);\n  }\n", "  public void testDeepNestedFinally() {\n    String src = \"try{try{try{throw 1}\" +\n        \"finally{1;var a}}finally{2;if(a);}}finally{3;a()}\";\n    ControlFlowGraph<Node> cfg = createCfg(src);\n    assertCrossEdge(cfg, Token.THROW, Token.BLOCK, Branch.ON_EX);\n    assertCrossEdge(cfg, Token.VAR, Token.BLOCK, Branch.UNCOND);\n    assertCrossEdge(cfg, Token.IF, Token.BLOCK, Branch.ON_EX);\n  }\n"], "Closure_133": ["  public void testTextExtents() {\n    parse(\"@return {@code foo} bar \\n *    baz. */\",\n        true, \"Bad type annotation. type not recognized due to syntax error\");\n  }\n"], "Closure_40": ["  public void testIssue284() {\n    CompilerOptions options = createCompilerOptions();\n    options.smartNameRemoval = true;\n    test(options,\n        \"var goog = {};\" +\n        \"goog.inherits = function(x, y) {};\" +\n        \"var ns = {};\" +\n        \"/** @constructor */\" +\n        \"ns.PageSelectionModel = function() {};\" +\n        \"/** @constructor */\" +\n        \"ns.PageSelectionModel.FooEvent = function() {};\" +\n        \"/** @constructor */\" +\n        \"ns.PageSelectionModel.SelectEvent = function() {};\" +\n        \"goog.inherits(ns.PageSelectionModel.ChangeEvent,\" +\n        \"    ns.PageSelectionModel.FooEvent);\",\n        \"\");\n  }\n", "  public void testIssue284() {\n    test(\n        \"var goog = {};\" +\n        \"goog.inherits = function(x, y) {};\" +\n        \"var ns = {};\" +\n        \"/** @constructor */\" +\n        \"ns.PageSelectionModel = function() {};\" +\n        \"/** @constructor */\" +\n        \"ns.PageSelectionModel.FooEvent = function() {};\" +\n        \"/** @constructor */\" +\n        \"ns.PageSelectionModel.SelectEvent = function() {};\" +\n        \"goog.inherits(ns.PageSelectionModel.ChangeEvent,\" +\n        \"    ns.PageSelectionModel.FooEvent);\",\n        \"\");\n  }\n"], "Lang_35": ["    public void testLANG571(){\n        String[] stringArray=null;\n        String aString=null;\n        try {\n            @SuppressWarnings(\"unused\")\n            String[] sa = ArrayUtils.add(stringArray, aString);\n            fail(\"Should have caused IllegalArgumentException\");\n        } catch (IllegalArgumentException iae){\n            //expected\n        }\n        try {\n            @SuppressWarnings(\"unused\")\n            String[] sa = ArrayUtils.add(stringArray, 0, aString);\n            fail(\"Should have caused IllegalArgumentException\");\n        } catch (IllegalArgumentException iae){\n            //expected\n        }\n    }\n"], "Closure_47": ["  public void testBasicMapping1() throws Exception {\n    compileAndCheck(\"function __BASIC__() { }\");\n  }\n", "  public void testBasicMappingGoldenOutput() throws Exception {\n    // Empty source map test\n    checkSourceMap(\"function __BASIC__() { }\",\n\n                   \"{\\n\" +\n                   \"\\\"version\\\":3,\\n\" +\n                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n                   \"\\\"lineCount\\\":1,\\n\" +\n                   \"\\\"mappings\\\":\\\"AAAAA,QAASA,UAAS,EAAG;\\\",\\n\" +\n                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n                   \"\\\"names\\\":[\\\"__BASIC__\\\"]\\n\" +\n                   \"}\\n\");\n  }\n", "  public void testBasicMapping2() throws Exception {\n    compileAndCheck(\"function __BASIC__(__PARAM1__) {}\");\n  }\n", "  public void testLiteralMappings() throws Exception {\n    compileAndCheck(\"function __BASIC__(__PARAM1__, __PARAM2__) { \" +\n                    \"var __VAR__ = '__STR__'; }\");\n  }\n", "  public void testLiteralMappingsGoldenOutput() throws Exception {\n    // Empty source map test\n    checkSourceMap(\"function __BASIC__(__PARAM1__, __PARAM2__) { \" +\n                   \"var __VAR__ = '__STR__'; }\",\n\n                   \"{\\n\" +\n                   \"\\\"version\\\":3,\\n\" +\n                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n                   \"\\\"lineCount\\\":1,\\n\" +\n                   \"\\\"mappings\\\":\\\"AAAAA,QAASA,UAAS,CAACC,UAAD,CAAaC,UAAb,\" +\n                       \"CAAyB,CAAE,IAAIC,QAAU,SAAhB;\\\",\\n\" +\n                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n                   \"\\\"names\\\":[\\\"__BASIC__\\\",\\\"__PARAM1__\\\",\\\"__PARAM2__\\\",\" +\n                       \"\\\"__VAR__\\\"]\\n\" +\n                   \"}\\n\");\n  }\n", "  public void testMultilineMapping() throws Exception {\n    compileAndCheck(\"function __BASIC__(__PARAM1__, __PARAM2__) {\\n\" +\n                    \"var __VAR__ = '__STR__';\\n\" +\n                    \"var __ANO__ = \\\"__STR2__\\\";\\n\" +\n                    \"}\");\n  }\n", "  public void testMultilineMapping2() throws Exception {\n    compileAndCheck(\"function __BASIC__(__PARAM1__, __PARAM2__) {\\n\" +\n                    \"var __VAR__ = 1;\\n\" +\n                    \"var __ANO__ = 2;\\n\" +\n                    \"}\");\n  }\n", "  public void testMultiFunctionMapping() throws Exception {\n    compileAndCheck(\"function __BASIC__(__PARAM1__, __PARAM2__) {\\n\" +\n                    \"var __VAR__ = '__STR__';\\n\" +\n                    \"var __ANO__ = \\\"__STR2__\\\";\\n\" +\n                    \"}\\n\" +\n\n                    \"function __BASIC2__(__PARAM3__, __PARAM4__) {\\n\" +\n                    \"var __VAR2__ = '__STR2__';\\n\" +\n                    \"var __ANO2__ = \\\"__STR3__\\\";\\n\" +\n                    \"}\\n\");\n  }\n", "  public void testGoldenOutput0a() throws Exception {\n    // Empty source map test\n    checkSourceMap(\"a;\",\n\n                   \"{\\n\" +\n                   \"\\\"version\\\":3,\\n\" +\n                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n                   \"\\\"lineCount\\\":1,\\n\" +\n                   \"\\\"mappings\\\":\\\"AAAAA;\\\",\\n\" +\n                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n                   \"\\\"names\\\":[\\\"a\\\"]\\n\" +\n                   \"}\\n\");\n  }\n", "  public void testGoldenOutput1() throws Exception {\n    detailLevel = SourceMap.DetailLevel.ALL;\n\n    checkSourceMap(\"function f(foo, bar) { foo = foo + bar + 2; return foo; }\",\n\n                   \"{\\n\" +\n                   \"\\\"version\\\":3,\\n\" +\n                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n                   \"\\\"lineCount\\\":1,\\n\" +\n                   \"\\\"mappings\\\":\\\"AAAAA,QAASA,EAAC,CAACC,GAAD,CAAMC,GAAN,\" +\n                       \"CAAW,CAAED,GAAA,CAAMA,GAAN,CAAYC,GAAZ,CAAkB,CAAG,\" +\n                       \"OAAOD,IAA9B;\\\",\\n\" +\n                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n                   \"\\\"names\\\":[\\\"f\\\",\\\"foo\\\",\\\"bar\\\"]\\n\" +\n                   \"}\\n\");\n\n    detailLevel = SourceMap.DetailLevel.SYMBOLS;\n\n    checkSourceMap(\"function f(foo, bar) { foo = foo + bar + 2; return foo; }\",\n\n                   \"{\\n\" +\n                   \"\\\"version\\\":3,\\n\" +\n                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n                   \"\\\"lineCount\\\":1,\\n\" +\n                   \"\\\"mappings\\\":\\\"AAAAA,QAASA,EAATA,CAAWC,GAAXD,CAAgBE,\" +\n                       \"GAAhBF,EAAuBC,GAAvBD,CAA6BC,GAA7BD,CAAmCE,GAAnCF,\" +\n                       \"SAAmDC,IAAnDD;\\\",\\n\" +\n                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n                   \"\\\"names\\\":[\\\"f\\\",\\\"foo\\\",\\\"bar\\\"]\\n\" +\n                   \"}\\n\");\n  }\n", "  public void testGoldenOutput2() throws Exception {\n    checkSourceMap(\"function f(foo, bar) {\\r\\n\\n\\n\\nfoo = foo + bar + foo;\" +\n                   \"\\nreturn foo;\\n}\",\n\n                   \"{\\n\" +\n                   \"\\\"version\\\":3,\\n\" +\n                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n                   \"\\\"lineCount\\\":1,\\n\" +\n                   \"\\\"mappings\\\":\\\"AAAAA,QAASA,EAAC,CAACC,GAAD,CAAMC,GAAN,\" +\n                       \"CAAW,CAIrBD,GAAA,CAAMA,GAAN,CAAYC,GAAZ,CAAkBD,\" +\n                       \"GAClB,OAAOA,IALc;\\\",\\n\" +\n                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n                   \"\\\"names\\\":[\\\"f\\\",\\\"foo\\\",\\\"bar\\\"]\\n\" +\n                   \"}\\n\");\n  }\n", "  public void testGoldenOutput3() throws Exception {\n    checkSourceMap(\"c:\\\\myfile.js\",\n                   \"foo;\",\n\n                   \"{\\n\" +\n                   \"\\\"version\\\":3,\\n\" +\n                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n                   \"\\\"lineCount\\\":1,\\n\" +\n                   \"\\\"mappings\\\":\\\"AAAAA;\\\",\\n\" +\n                   \"\\\"sources\\\":[\\\"c:\\\\\\\\myfile.js\\\"],\\n\" +\n                   \"\\\"names\\\":[\\\"foo\\\"]\\n\" +\n                   \"}\\n\");\n  }\n", "  public void testGoldenOutput4() throws Exception {\n    checkSourceMap(\"c:\\\\myfile.js\",\n                   \"foo;   boo;   goo;\",\n\n                   \"{\\n\" +\n                   \"\\\"version\\\":3,\\n\" +\n                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n                   \"\\\"lineCount\\\":1,\\n\" +\n                   \"\\\"mappings\\\":\\\"AAAAA,GAAOC,IAAOC;\\\",\\n\" +\n                   \"\\\"sources\\\":[\\\"c:\\\\\\\\myfile.js\\\"],\\n\" +\n                   \"\\\"names\\\":[\\\"foo\\\",\\\"boo\\\",\\\"goo\\\"]\\n\" +\n                   \"}\\n\");\n  }\n", "  public void testGoldenOutput5() throws Exception {\n    detailLevel = SourceMap.DetailLevel.ALL;\n\n    checkSourceMap(\n        \"c:\\\\myfile.js\",\n        \"/** @preserve\\n\" +\n        \" * this is a test.\\n\" +\n        \" */\\n\" +\n        \"var foo=a + 'this is a really long line that will force the\"\n        + \" mapping to span multiple lines 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \"' + c + d + e;\",\n\n        \"{\\n\" +\n        \"\\\"version\\\":3,\\n\" +\n        \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n        \"\\\"lineCount\\\":6,\\n\" +\n        \"\\\"mappings\\\":\\\"A;;;;AAGA,IAAIA,IAAIC,CAAJD,CAAQ,mxCAARA;AAA8xCE,\" +\n            \"CAA9xCF,CAAkyCG,CAAlyCH,CAAsyCI;\\\",\\n\" +\n        \"\\\"sources\\\":[\\\"c:\\\\\\\\myfile.js\\\"],\\n\" +\n        \"\\\"names\\\":[\\\"foo\\\",\\\"a\\\",\\\"c\\\",\\\"d\\\",\\\"e\\\"]\\n\" +\n        \"}\\n\");\n\n    detailLevel = SourceMap.DetailLevel.SYMBOLS;\n\n    checkSourceMap(\"c:\\\\myfile.js\",\n        \"/** @preserve\\n\" +\n        \" * this is a test.\\n\" +\n        \" */\\n\" +\n        \"var foo=a + 'this is a really long line that will force the\"\n        + \" mapping to span multiple lines 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \" 123456789 123456789 123456789 123456789 123456789\"\n        + \"' + c + d + e;\",\n\n        \"{\\n\" +\n        \"\\\"version\\\":3,\\n\" +\n        \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n        \"\\\"lineCount\\\":6,\\n\" +\n        \"\\\"mappings\\\":\\\"A;;;;IAGIA,IAAIC,CAAJD;AAA8xCE,CAA9xCF,CAAkyCG,\" +\n            \"CAAlyCH,CAAsyCI;\\\",\\n\" +\n        \"\\\"sources\\\":[\\\"c:\\\\\\\\myfile.js\\\"],\\n\" +\n        \"\\\"names\\\":[\\\"foo\\\",\\\"a\\\",\\\"c\\\",\\\"d\\\",\\\"e\\\"]\\n\" +\n        \"}\\n\");\n  }\n", "  public void testParseSourceMetaMap() throws Exception {\n    final String INPUT1 = \"file1\";\n    final String INPUT2 = \"file2\";\n    LinkedHashMap<String, String> inputs = Maps.newLinkedHashMap();\n    inputs.put(INPUT1, \"var __FOO__ = 1;\");\n    inputs.put(INPUT2, \"var __BAR__ = 2;\");\n    RunResult result1 = compile(inputs.get(INPUT1), INPUT1);\n    RunResult result2 = compile(inputs.get(INPUT2), INPUT2);\n\n    final String MAP1 = \"map1\";\n    final String MAP2 = \"map2\";\n    final LinkedHashMap<String, String> maps = Maps.newLinkedHashMap();\n    maps.put(MAP1, result1.sourceMapFileContent);\n    maps.put(MAP2, result2.sourceMapFileContent);\n\n    List<SourceMapSection> sections = Lists.newArrayList();\n\n    StringBuilder output = new StringBuilder();\n    FilePosition offset = appendAndCount(output, result1.generatedSource);\n    sections.add(SourceMapSection.forURL(MAP1, 0, 0));\n    output.append(result2.generatedSource);\n    sections.add(\n        SourceMapSection.forURL(MAP2, offset.getLine(), offset.getColumn()));\n\n    SourceMapGeneratorV3 generator = new SourceMapGeneratorV3();\n    StringBuilder mapContents = new StringBuilder();\n    generator.appendIndexMapTo(mapContents, \"out.js\", sections);\n\n    check(inputs, output.toString(), mapContents.toString(),\n      new SourceMapSupplier() {\n        @Override\n        public String getSourceMap(String url){\n          return maps.get(url);\n      }});\n  }\n", "  public void testSourceMapMerging() throws Exception {\n    final String INPUT1 = \"file1\";\n    final String INPUT2 = \"file2\";\n    LinkedHashMap<String, String> inputs = Maps.newLinkedHashMap();\n    inputs.put(INPUT1, \"var __FOO__ = 1;\");\n    inputs.put(INPUT2, \"var __BAR__ = 2;\");\n    RunResult result1 = compile(inputs.get(INPUT1), INPUT1);\n    RunResult result2 = compile(inputs.get(INPUT2), INPUT2);\n\n    StringBuilder output = new StringBuilder();\n    FilePosition offset = appendAndCount(output, result1.generatedSource);\n    output.append(result2.generatedSource);\n\n    SourceMapGeneratorV3 generator = new SourceMapGeneratorV3();\n\n    generator.mergeMapSection(0, 0, result1.sourceMapFileContent);\n    generator.mergeMapSection(offset.getLine(), offset.getColumn(),\n        result2.sourceMapFileContent);\n\n    StringBuilder mapContents = new StringBuilder();\n    generator.appendTo(mapContents, \"out.js\");\n\n    check(inputs, output.toString(), mapContents.toString());\n  }\n"], "Closure_78": ["  public void testFoldArithmetic() {\n    fold(\"x = 10 + 20\", \"x = 30\");\n    fold(\"x = 2 / 4\", \"x = 0.5\");\n    fold(\"x = 2.25 * 3\", \"x = 6.75\");\n    fold(\"z = x * y\", \"z = x * y\");\n    fold(\"x = y * 5\", \"x = y * 5\");\n    fold(\"x = 1 / 0\", \"x = 1 / 0\");\n    fold(\"x = 3 % 2\", \"x = 1\");\n    fold(\"x = 3 % -2\", \"x = 1\");\n    fold(\"x = -1 % 3\", \"x = -1\");\n    fold(\"x = 1 % 0\", \"x = 1 % 0\");\n  }\n", "  public void testFoldArithmetic2() {\n    foldSame(\"x = y + 10 + 20\");\n    foldSame(\"x = y / 2 / 4\");\n    fold(\"x = y * 2.25 * 3\", \"x = y * 6.75\");\n    fold(\"z = x * y\", \"z = x * y\");\n    fold(\"x = y * 5\", \"x = y * 5\");\n    fold(\"x = y + (z * 24 * 60 * 60 * 1000)\", \"x = y + z * 864E5\");\n  }\n", "  public void testFoldArithmetic3() {\n    fold(\"x = null * undefined\", \"x = NaN\");\n    fold(\"x = null * 1\", \"x = 0\");\n    fold(\"x = (null - 1) * 2\", \"x = -2\");\n    fold(\"x = (null + 1) * 2\", \"x = 2\");\n  }\n", "  public void testFoldArithmeticInfinity() {\n    fold(\"x=-Infinity-2\", \"x=-Infinity\");\n    fold(\"x=Infinity-2\", \"x=Infinity\");\n    fold(\"x=Infinity*5\", \"x=Infinity\");\n  }\n", "  public void testFoldArithmeticStringComp() {\n    // Negative Numbers.\n    assertResultString(\"x = 10 - 20\", \"x=-10\");\n  }\n"], "Lang_32": ["    public void testReflectionObjectCycle() {\n        ReflectionTestCycleA a = new ReflectionTestCycleA();\n        ReflectionTestCycleB b = new ReflectionTestCycleB();\n        a.b = b;\n        b.a = a;\n        \n        // Used to caused:\n        // java.lang.StackOverflowError\n        // at java.lang.ClassLoader.getCallerClassLoader(Native Method)\n        // at java.lang.Class.getDeclaredFields(Class.java:992)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionAppend(HashCodeBuilder.java:373)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:349)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:155)\n        // at\n        // org.apache.commons.lang.builder.HashCodeBuilderTest$ReflectionTestCycleB.hashCode(HashCodeBuilderTest.java:53)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.append(HashCodeBuilder.java:422)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionAppend(HashCodeBuilder.java:383)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:349)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:155)\n        // at\n        // org.apache.commons.lang.builder.HashCodeBuilderTest$ReflectionTestCycleA.hashCode(HashCodeBuilderTest.java:42)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.append(HashCodeBuilder.java:422)\n\n        a.hashCode();\n        assertNull(HashCodeBuilder.getRegistry());\n        b.hashCode();\n        assertNull(HashCodeBuilder.getRegistry());\n    }\n"], "Time_2": ["    public void testWith_baseAndArgHaveNoRange() {\n        Partial test = new Partial(DateTimeFieldType.year(), 1);\n        Partial result = test.with(DateTimeFieldType.era(), 1);\n        assertEquals(2, result.size());\n        assertEquals(0, result.indexOf(DateTimeFieldType.era()));\n        assertEquals(1, result.indexOf(DateTimeFieldType.year()));\n    }\n"], "Closure_71": ["  public void testNoPrivateAccessForProperties6() {\n    // Overriding a private property with a non-private property\n    // in a different file causes problems.\n    test(new String[] {\n      \"/** @constructor */ function Foo() {} \" +\n      \"/** @private */ Foo.prototype.bar_ = function() {};\",\n      \"/** @constructor \\n * @extends {Foo} */ \" +\n      \"function SubFoo() {};\" +\n      \"SubFoo.prototype.bar_ = function() {};\"\n    }, null, BAD_PRIVATE_PROPERTY_ACCESS);\n  }\n", "  public void testNoPrivateAccessForProperties8() {\n    test(new String[] {\n      \"/** @constructor */ function Foo() { /** @private */ this.bar_ = 3; }\",\n      \"/** @constructor \\n * @extends {Foo} */ \" +\n      \"function SubFoo() { /** @private */ this.bar_ = 3; };\"\n    }, null, PRIVATE_OVERRIDE);\n  }\n"], "Closure_102": ["  public void testIssue115() {\n    CompilerRunner.FLAG_compilation_level.setForTest(\n        CompilationLevel.SIMPLE_OPTIMIZATIONS);\n    CompilerRunner.FLAG_warning_level.setForTest(\n        WarningLevel.VERBOSE);\n    test(\"function f() { \" +\n         \"  var arguments = Array.prototype.slice.call(arguments, 0);\" +\n         \"  return arguments[0]; \" +\n         \"}\",\n         \"function f() { \" +\n         \"  arguments = Array.prototype.slice.call(arguments, 0);\" +\n         \"  return arguments[0]; \" +\n         \"}\");\n  }\n"], "Closure_85": ["  public void testCascadedRemovalOfUnlessUnconditonalJumps() {\n    test(\"switch (a) { case 'a': break; case 'b': break; case 'c': break }\",\n         \"switch (a) { case 'a': break; case 'b': case 'c': }\");\n    // Only one break removed per pass.\n    test(\"switch (a) { case 'a': break; case 'b': case 'c': }\",\n         \"switch (a) { case 'a': case 'b': case 'c': }\");\n\n    test(\"function foo() {\" +\n      \"  switch (a) { case 'a':return; case 'b':return; case 'c':return }}\",\n      \"function foo() { switch (a) { case 'a':return; case 'b': case 'c': }}\");\n    test(\"function foo() {\" +\n      \"  switch (a) { case 'a':return; case 'b': case 'c': }}\",\n      \"function foo() { switch (a) { case 'a': case 'b': case 'c': }}\");\n\n    testSame(\"function foo() {\" +\n             \"switch (a) { case 'a':return 2; case 'b':return 1}}\");\n  }\n", "  public void testIssue311() {\n    test(\"function a(b) {\\n\" +\n         \"  switch (b.v) {\\n\" +\n         \"    case 'SWITCH':\\n\" +\n         \"      if (b.i >= 0) {\\n\" +\n         \"        return b.o;\\n\" +\n         \"      } else {\\n\" +\n         \"        return;\\n\" +\n         \"      }\\n\" +\n         \"      break;\\n\" +\n         \"  }\\n\" +\n         \"}\",\n         \"function a(b) {\\n\" +\n         \"  switch (b.v) {\\n\" +\n         \"    case 'SWITCH':\\n\" +\n         \"      if (b.i >= 0) {\\n\" +\n         \"        return b.o;\\n\" +\n         \"      } else {\\n\" +\n         \"      }\\n\" +\n         \"  }\\n\" +\n         \"}\");\n  }\n"], "Closure_105": ["  public void testStringJoinAdd() {\n    fold(\"x = ['a', 'b', 'c'].join('')\", \"x = \\\"abc\\\"\");\n    fold(\"x = [].join(',')\", \"x = \\\"\\\"\");\n    fold(\"x = ['a'].join(',')\", \"x = \\\"a\\\"\");\n    fold(\"x = ['a', 'b', 'c'].join(',')\", \"x = \\\"a,b,c\\\"\");\n    fold(\"x = ['a', foo, 'b', 'c'].join(',')\", \"x = [\\\"a\\\",foo,\\\"b,c\\\"].join(\\\",\\\")\");\n    fold(\"x = [foo, 'a', 'b', 'c'].join(',')\", \"x = [foo,\\\"a,b,c\\\"].join(\\\",\\\")\");\n    fold(\"x = ['a', 'b', 'c', foo].join(',')\", \"x = [\\\"a,b,c\\\",foo].join(\\\",\\\")\");\n\n    // Works with numbers\n    fold(\"x = ['a=', 5].join('')\", \"x = \\\"a=5\\\"\");\n    fold(\"x = ['a', '5'].join(7)\", \"x = \\\"a75\\\"\");\n\n    // Works on boolean\n    fold(\"x = ['a=', false].join('')\", \"x = \\\"a=false\\\"\");\n    fold(\"x = ['a', '5'].join(true)\", \"x = \\\"atrue5\\\"\");\n    fold(\"x = ['a', '5'].join(false)\", \"x = \\\"afalse5\\\"\");\n\n    // Only optimize if it's a size win.\n    fold(\"x = ['a', '5', 'c'].join('a very very very long chain')\",\n         \"x = [\\\"a\\\",\\\"5\\\",\\\"c\\\"].join(\\\"a very very very long chain\\\")\");\n    \n    // TODO(user): Its possible to fold this better.\n    foldSame(\"x = ['', foo].join(',')\");\n    foldSame(\"x = ['', foo, ''].join(',')\");\n    \n    fold(\"x = ['', '', foo, ''].join(',')\", \"x = [',', foo, ''].join(',')\");\n    fold(\"x = ['', '', foo, '', ''].join(',')\",\n         \"x = [',', foo, ','].join(',')\");\n    \n    fold(\"x = ['', '', foo, '', '', bar].join(',')\",\n         \"x = [',', foo, ',', bar].join(',')\");\n    \n    fold(\"x = [1,2,3].join('abcdef')\",\n         \"x = '1abcdef2abcdef3'\");\n  }\n", "  public void testStringJoinAdd_b1992789() {\n    fold(\"x = ['a'].join('')\", \"x = \\\"a\\\"\");\n    fold(\"x = [foo()].join('')\", \"x = '' + foo()\");\n    fold(\"[foo()].join('')\", \"'' + foo()\");\n  }\n"], "Closure_82": ["  public void testIssue301() throws Exception {\n    testTypes(\n        \"Array.indexOf = function() {};\" +\n        \"var s = 'hello';\" +\n        \"alert(s.toLowerCase.indexOf('1'));\",\n        \"Property indexOf never defined on String.prototype.toLowerCase\");\n  }\n", "  public void testEmptyFunctionTypes() {\n    assertTrue(LEAST_FUNCTION_TYPE.isEmptyType());\n    assertFalse(GREATEST_FUNCTION_TYPE.isEmptyType());\n  }\n"], "Closure_76": ["  public void testInExpression2() {\n    // This can be improved.  \"a = 1\" is dead but \"a\" is read in the following\n    // expression.\n    inFunction(\n        \"var a; a = 1; if ((a = 2) || (a = 3) || (a)) {}\",\n        \"var a; a = 1; if ((    2) || (a = 3) || (a)) {}\");\n\n    inFunction(\n        \"var a; (a = 1) || (a = 2)\",\n        \"var a; 1 || 2\");\n\n    inFunction(\"var a; (a = 1) || (a = 2); return a\");\n\n    inFunction(\n        \"var a; a = 1; a ? a = 2 : a;\",\n        \"var a; a = 1; a ?     2 : a;\");\n\n    inFunction(\"var a; a = 1; a ? a = 2 : a; return a\");\n\n    inFunction(\n        \"var a; a = 1; a ? a : a = 2;\",\n        \"var a; a = 1; a ? a : 2;\");\n\n    inFunction(\"var a; a = 1; a ? a : a =2; return a\");\n\n    inFunction(\n        \"var a; (a = 1) ? a = 2 : a = 3;\",\n        \"var a;      1  ?     2 :     3;\");\n\n    // This can be improved.  \"a = 1\" is dead but \"a\" is read in the following\n    // expression.\n    inFunction(\"var a; (a = 1) ? a = 2 : a = 3; return a\");\n  }\n", "  public void testIssue384b() {\n    inFunction(\n            \" var a, b;\\n\" +\n            \" (f(b = true) || f(b = false)) ? (a = b) : (a = null);\\n\" +\n            \" return a;\");\n  }\n", "  public void testIssue384c() {\n    inFunction(\n            \" var a, b;\\n\" +\n            \" (a ? f(b = true) : f(b = false)) && (a = b);\\n\" +\n            \" return a;\");\n  }\n", "  public void testIssue384d() {\n    inFunction(\n            \" var a, b;\\n\" +\n            \" (f(b = true) || f(b = false)) && (a = b);\\n\" +\n            \" return a;\");\n  }\n"], "Time_5": ["    public void testNormalizedStandard_periodType_months1() {\n        Period test = new Period(1, 15, 0, 0, 0, 0, 0, 0);\n        Period result = test.normalizedStandard(PeriodType.months());\n        assertEquals(new Period(1, 15, 0, 0, 0, 0, 0, 0), test);\n        assertEquals(new Period(0, 27, 0, 0, 0, 0, 0, 0, PeriodType.months()), result);\n    }\n", "    public void testNormalizedStandard_periodType_months2() {\n        Period test = new Period(-2, 15, 0, 0, 0, 0, 0, 0);\n        Period result = test.normalizedStandard(PeriodType.months());\n        assertEquals(new Period(-2, 15, 0, 0, 0, 0, 0, 0), test);\n        assertEquals(new Period(0, -9, 0, 0, 0, 0, 0, 0, PeriodType.months()), result);\n    }\n", "    public void testNormalizedStandard_periodType_monthsWeeks() {\n        PeriodType type = PeriodType.forFields(new DurationFieldType[]{\n                        DurationFieldType.months(),\n                        DurationFieldType.weeks(),\n                        DurationFieldType.days()});\n        Period test = new Period(2, 4, 6, 0, 0, 0, 0, 0);\n        Period result = test.normalizedStandard(type);\n        assertEquals(new Period(2, 4, 6, 0, 0, 0, 0, 0), test);\n        assertEquals(new Period(0, 28, 6, 0, 0, 0, 0, 0, type), result);\n    }\n"], "Closure_49": ["  public void testInline13() {\n    // Parameter has side-effects.\n    helperInlineReferenceToFunction(\n        \"function foo(a){return a;}; \" +\n        \"function x() { foo(x++); }\",\n        \"function foo(a){return a;}; \" +\n        \"function x() {{var a$$inline_0=x++;\" +\n            \"a$$inline_0}}\",\n        \"foo\", INLINE_BLOCK);\n  }\n", "  public void testInline14() {\n    // Parameter has side-effects.\n    helperInlineReferenceToFunction(\n        \"function foo(a){return a+a;}; foo(x++);\",\n        \"function foo(a){return a+a;}; \" +\n            \"{var a$$inline_0=x++;\" +\n            \" a$$inline_0+\" +\n            \"a$$inline_0;}\",\n        \"foo\", INLINE_BLOCK);\n  }\n", "  public void testInline15() {\n    // Parameter has mutable, references more than once.\n    helperInlineReferenceToFunction(\n        \"function foo(a){return a+a;}; foo(new Date());\",\n        \"function foo(a){return a+a;}; \" +\n            \"{var a$$inline_0=new Date();\" +\n            \" a$$inline_0+\" +\n            \"a$$inline_0;}\",\n        \"foo\", INLINE_BLOCK);\n  }\n", "  public void testInline16() {\n    // Parameter is large, references more than once.\n    helperInlineReferenceToFunction(\n        \"function foo(a){return a+a;}; foo(function(){});\",\n        \"function foo(a){return a+a;}; \" +\n            \"{var a$$inline_0=function(){};\" +\n            \" a$$inline_0+\" +\n            \"a$$inline_0;}\",\n        \"foo\", INLINE_BLOCK);\n  }\n", "  public void testInline17() {\n    // Parameter has side-effects.\n    helperInlineReferenceToFunction(\n        \"function foo(a){return true;}; foo(goo());\",\n        \"function foo(a){return true;};\" +\n            \"{var a$$inline_0=goo();true}\",\n        \"foo\", INLINE_BLOCK);\n  }\n", "  public void testInline18() {\n    // This doesn't bring names into the global name space.\n    helperInlineReferenceToFunction(\n        \"function foo(a){var b;return a;}; \" +\n            \"function x() { foo(goo()); }\",\n            \"function foo(a){var b;return a;}; \" +\n            \"function x() {{var a$$inline_0=goo();\" +\n                \"var b$$inline_1;a$$inline_0}}\",\n        \"foo\", INLINE_BLOCK);\n  }\n", "  public void testInline19() {\n    // Properly alias.\n    helperInlineReferenceToFunction(\n        \"var x = 1; var y = 2;\" +\n        \"function foo(a,b){x = b; y = a;}; \" +\n        \"function bar() { foo(x,y); }\",\n        \"var x = 1; var y = 2;\" +\n        \"function foo(a,b){x = b; y = a;}; \" +\n        \"function bar() {\" +\n           \"{var a$$inline_0=x;\" +\n            \"x = y;\" +\n            \"y = a$$inline_0;}\" +\n        \"}\",\n        \"foo\", INLINE_BLOCK);\n  }\n", "  public void testInline19b() {\n    helperInlineReferenceToFunction(\n        \"var x = 1; var y = 2;\" +\n        \"function foo(a,b){y = a; x = b;}; \" +\n        \"function bar() { foo(x,y); }\",\n        \"var x = 1; var y = 2;\" +\n        \"function foo(a,b){y = a; x = b;}; \" +\n        \"function bar() {\" +\n           \"{var b$$inline_1=y;\" +\n            \"y = x;\" +\n            \"x = b$$inline_1;}\" +\n        \"}\",\n        \"foo\", INLINE_BLOCK);\n  }\n", "  public void testInlineIntoLoop() {\n    helperInlineReferenceToFunction(\n        \"function foo(a){var b;return a;}; \" +\n        \"for(;1;){ foo(1); }\",\n        \"function foo(a){var b;return a;}; \" +\n        \"for(;1;){ {\" +\n            \"var b$$inline_1=void 0;1}}\",\n        \"foo\", INLINE_BLOCK);\n\n    helperInlineReferenceToFunction(\n        \"function foo(a){var b;return a;}; \" +\n        \"do{ foo(1); } while(1)\",\n        \"function foo(a){var b;return a;}; \" +\n        \"do{ {\" +\n            \"var b$$inline_1=void 0;1}}while(1)\",\n        \"foo\", INLINE_BLOCK);\n\n    helperInlineReferenceToFunction(\n        \"function foo(a){for(var b in c)return a;}; \" +\n        \"for(;1;){ foo(1); }\",\n        \"function foo(a){var b;for(b in c)return a;}; \" +\n        \"for(;1;){ {JSCompiler_inline_label_foo_2:{\" +\n            \"var b$$inline_1=void 0;for(b$$inline_1 in c){\" +\n              \"1;break JSCompiler_inline_label_foo_2\" +\n            \"}}}}\",\n        \"foo\", INLINE_BLOCK);\n  }\n", "  public void testInlineFunctionWithInnerFunction5() {\n    // Call with inner function statement.\n    helperInlineReferenceToFunction(\n        \"function foo(){function x() {var a; return true;} return x}; foo();\",\n        \"function foo(){function x(){var a;return true}return x};\" +\n            \"{var x$$inline_0 = function(){\" +\n            \"var a$$inline_1;return true};x$$inline_0}\",\n        \"foo\", INLINE_BLOCK);\n  }\n", "  public void testBug1897706() {\n    helperInlineReferenceToFunction(\n        \"function foo(a){}; foo(x())\",\n        \"function foo(a){}; {var a$$inline_0=x()}\",\n        \"foo\", INLINE_BLOCK);\n\n    helperInlineReferenceToFunction(\n        \"function foo(a){bar()}; foo(x())\",\n        \"function foo(a){bar()}; {var a$$inline_0=x();bar()}\",\n        \"foo\", INLINE_BLOCK);\n\n    helperInlineReferenceToFunction(\n        \"function foo(a,b){bar()}; foo(x(),y())\",\n        \"function foo(a,b){bar()};\" +\n        \"{var a$$inline_0=x();var b$$inline_1=y();bar()}\",\n        \"foo\", INLINE_BLOCK);\n  }\n", "  public void testMutateWithParameters3() {\n    // Parameter has side-effects.\n    helperMutate(\n        \"function foo(a){return a;}; \" +\n        \"function x() { foo(x++); }\",\n        \"{var a$$inline_0 = x++; a$$inline_0}\",\n        \"foo\", null);\n  }\n", "  public void testMutate8() {\n    // Parameter has side-effects.\n    helperMutate(\n        \"function foo(a){return a+a;}; foo(x++);\",\n        \"{var a$$inline_0 = x++;\" +\n            \"a$$inline_0 + a$$inline_0;}\",\n        \"foo\", null);\n  }\n", "  public void testMutateInitializeUninitializedVars1() {\n    helperMutate(\n        \"function foo(a){var b;return a;}; foo(1);\",\n        \"{var b$$inline_1=void 0;1}\",\n        \"foo\", null, false, true);\n  }\n", "  public void testMutateInitializeUninitializedVars2() {\n    helperMutate(\n        \"function foo(a){for(var b in c)return a;}; foo(1);\",\n        \"{JSCompiler_inline_label_foo_2:\" +\n          \"{\" +\n            \"for(var b$$inline_1 in c){\" +\n                \"1;break JSCompiler_inline_label_foo_2\" +\n             \"}\" +\n          \"}\" +\n        \"}\",\n        \"foo\", null);\n  }\n", "  public void testMutateCallInLoopVars1() {\n    // baseline: outside a loop, the constant remains constant.\n    boolean callInLoop = false;\n    helperMutate(\n        \"function foo(a){var B = bar(); a;}; foo(1);\",\n        \"{var B$$inline_1=bar(); 1;}\",\n        \"foo\", null, false, callInLoop);\n    // ... in a loop, the constant-ness is removed.\n    // TODO(johnlenz): update this test to look for the const annotation.\n    callInLoop = true;\n    helperMutate(\n        \"function foo(a){var B = bar(); a;}; foo(1);\",\n        \"{var B$$inline_1 = bar(); 1;}\",\n        \"foo\", null, false, callInLoop);\n  }\n", "  public void testMutateFunctionDefinition() {\n     // function declarations are rewritten as function\n     // expressions\n     helperMutate(\n        \"function foo(a){function g(){}}; foo(1);\",\n        \"{var g$$inline_1=function(){};}\",\n        \"foo\", null);\n  }\n", "  public void testInlineFunctions9() {\n    // don't inline if the input parameter is modified.\n    test(\"function INC(x){return x++}\" +\n         \"var y=INC(i)\",\n         \"var y;{var x$$inline_0=i;\" +\n         \"y=x$$inline_0++}\");\n  }\n", "  public void testInlineFunctions10() {\n    test(\"function INC(x){return x++}\" +\n         \"var y=INC(i);y=INC(i)\",\n         \"var y;\" +\n         \"{var x$$inline_0=i;\" +\n         \"y=x$$inline_0++}\" +\n         \"{var x$$inline_2=i;\" +\n         \"y=x$$inline_2++}\");\n  }\n", "  public void testInlineFunctions13() {\n    // inline as block if the input parameter has side-effects.\n    test(\"function f(x){return x}\" +\n         \"var y=f(i++)\",\n         \"var y;{var x$$inline_0=i++;y=x$$inline_0}\");\n  }\n", "  public void testInlineFunctions15b() {\n    assumeMinimumCapture = false;\n\n    // closure factories: don't inline closure with locals into global scope.\n    test(\"function foo(){var x;return function(a){return a+1}}\" +\n         \"var b=function(){return c};\" +\n         \"var d=b()+foo()\",\n\n         \"function foo(){var x;return function(a){return a+1}}\" +\n         \"var d=c+foo()\");\n\n    assumeMinimumCapture = true;\n\n    test(\"function foo(){var x;return function(a){return a+1}}\" +\n         \"var b=function(){return c};\" +\n         \"var d=b()+foo()\",\n\n         \"var JSCompiler_temp_const$$0 = c;\\n\" +\n         \"{\\n\" +\n         \"var JSCompiler_inline_result$$1;\\n\" +\n         \"var x$$inline_2;\\n\" +\n         \"JSCompiler_inline_result$$1 = \" +\n         \"    function(a$$inline_3){ return a$$inline_3+1 };\\n\" +\n         \"}\" +\n         \"var d=JSCompiler_temp_const$$0 + JSCompiler_inline_result$$1\");\n  }\n", "  public void testInlineFunctions15d() {\n    assumeMinimumCapture = false;\n\n    // closure factories: don't inline functions with vars.\n    test(\"function foo(){var x; return function(a){return a+1}}\" +\n         \"var b=function(){return c};\" +\n         \"function _x(){ var d=b()+foo() }\",\n\n         \"function foo(){var x; return function(a){return a+1}}\" +\n         \"function _x(){ var d=c+foo() }\");\n\n    assumeMinimumCapture = true;\n\n    // closure factories: don't inline functions with vars.\n    test(\"function foo(){var x; return function(a){return a+1}}\" +\n         \"var b=function(){return c};\" +\n         \"function _x(){ var d=b()+foo() }\",\n\n         \"function _x() { \\n\" +\n         \"  var JSCompiler_temp_const$$0 = c;\\n\" +\n         \"  {\\n\" +\n         \"  var JSCompiler_inline_result$$1;\\n\" +\n         \"  var x$$inline_2;\\n\" +\n         \"  JSCompiler_inline_result$$1 = \" +\n         \"      function(a$$inline_3) {return a$$inline_3+1};\\n\" +\n         \"  }\\n\" +\n         \"  var d = JSCompiler_temp_const$$0+JSCompiler_inline_result$$1\\n\" +\n         \"}\");\n  }\n", "  public void testInlineFunctions16a() {\n    assumeMinimumCapture = false;\n\n    testSame(\"function foo(b){return window.bar(function(){c(b)})}\" +\n         \"var d=foo(e)\");\n\n    assumeMinimumCapture = true;\n\n    test(\n        \"function foo(b){return window.bar(function(){c(b)})}\" +\n        \"var d=foo(e)\",\n        \"var d;{var b$$inline_0=e;\" +\n        \"d=window.bar(function(){c(b$$inline_0)})}\");\n  }\n", "  public void testInlineFunctions22() {\n    // Another tricky case ... test nested compiler inlines\n    test(\"function plex(a){if(a) return 0;else return 1;}\" +\n         \"function foo(a, b){return bar(a+b)}\" +\n         \"function bar(d){return plex(d)}\" +\n         \"var d=foo(1,2)\",\n\n         \"var d;{JSCompiler_inline_label_plex_1:{\" +\n         \"if(1+2){\" +\n         \"d=0;break JSCompiler_inline_label_plex_1}\" +\n         \"else{\" +\n         \"d=1;break JSCompiler_inline_label_plex_1}d=void 0}}\");\n  }\n", "  public void testInlineFunctions23() {\n    // Test both orderings again\n    test(\"function complex(a){if(a) return 0;else return 1;}\" +\n         \"function bar(d){return complex(d)}\" +\n         \"function foo(a, b){return bar(a+b)}\" +\n         \"var d=foo(1,2)\",\n\n         \"var d;{JSCompiler_inline_label_complex_1:{\" +\n         \"if(1+2){\" +\n         \"d=0;break JSCompiler_inline_label_complex_1\" +\n         \"}else{\" +\n         \"d=1;break JSCompiler_inline_label_complex_1\" +\n         \"}d=void 0}}\");\n  }\n", "  public void testMixedModeInliningCosting3() {\n    // Do inline here because the function definition can be eliminated.\n    test(\n        \"function foo(a,b){return a+b+a+b+4+5+6+7+8+9+1+2+3+10}\" +\n        \"foo(1,2);\" +\n        \"foo(2,3,x())\",\n\n        \"1+2+1+2+4+5+6+7+8+9+1+2+3+10;\" +\n        \"{var JSCompiler_inline_anon_param_2=x();\" +\n        \"2+3+2+3+4+5+6+7+8+9+1+2+3+10}\");\n  }\n", "  public void testNoInlineIfParametersModified1() {\n    // Assignment\n    test(\"function f(x){return x=1}f(undefined)\",\n         \"{var x$$inline_0=undefined;\" +\n         \"x$$inline_0=1}\");\n  }\n", "  public void testNoInlineIfParametersModified2() {\n    test(\"function f(x){return (x)=1;}f(2)\",\n         \"{var x$$inline_0=2;\" +\n         \"x$$inline_0=1}\");\n  }\n", "  public void testNoInlineIfParametersModified3() {\n    // Assignment variant.\n    test(\"function f(x){return x*=2}f(2)\",\n         \"{var x$$inline_0=2;\" +\n         \"x$$inline_0*=2}\");\n  }\n", "  public void testNoInlineIfParametersModified4() {\n    // Assignment in if.\n    test(\"function f(x){return x?(x=2):0}f(2)\",\n         \"{var x$$inline_0=2;\" +\n         \"x$$inline_0?(\" +\n         \"x$$inline_0=2):0}\");\n  }\n", "  public void testNoInlineIfParametersModified5() {\n    // Assignment in if, multiple params\n    test(\"function f(x,y){return x?(y=2):0}f(2,undefined)\",\n         \"{var y$$inline_1=undefined;2?(\" +\n         \"y$$inline_1=2):0}\");\n  }\n", "  public void testNoInlineIfParametersModified6() {\n    test(\"function f(x,y){return x?(y=2):0}f(2)\",\n         \"{var y$$inline_1=void 0;2?(\" +\n         \"y$$inline_1=2):0}\");\n  }\n", "  public void testNoInlineIfParametersModified7() {\n    // Increment\n    test(\"function f(a){return++a<++a}f(1)\",\n         \"{var a$$inline_0=1;\" +\n         \"++a$$inline_0<\" +\n         \"++a$$inline_0}\");\n  }\n", "  public void testInlineNeverMutateConstants() {\n    test(\"function f(x){return x=1}f(undefined)\",\n         \"{var x$$inline_0=undefined;\" +\n         \"x$$inline_0=1}\");\n  }\n", "  public void testInlineNeverOverrideNewValues() {\n    test(\"function f(a){return++a<++a}f(1)\",\n        \"{var a$$inline_0=1;\" +\n        \"++a$$inline_0<++a$$inline_0}\");\n  }\n", "  public void testInlineBlockMutableArgs1() {\n    test(\"function foo(x){x+x}foo([])\",\n         \"{var x$$inline_0=[];\" +\n         \"x$$inline_0+x$$inline_0}\");\n  }\n", "  public void testInlineBlockMutableArgs2() {\n    test(\"function foo(x){x+x}foo(new Date)\",\n         \"{var x$$inline_0=new Date;\" +\n         \"x$$inline_0+x$$inline_0}\");\n  }\n", "  public void testInlineBlockMutableArgs3() {\n    test(\"function foo(x){x+x}foo(true&&new Date)\",\n         \"{var x$$inline_0=true&&new Date;\" +\n         \"x$$inline_0+x$$inline_0}\");\n  }\n", "  public void testInlineBlockMutableArgs4() {\n    test(\"function foo(x){x+x}foo({})\",\n         \"{var x$$inline_0={};\" +\n         \"x$$inline_0+x$$inline_0}\");\n  }\n", "  public void testShadowVariables1() {\n    // The Normalize pass now guarantees that that globals are never shadowed\n    // by locals.\n\n    // \"foo\" is inlined here as its parameter \"a\" doesn't conflict.\n    // \"bar\" is assigned a new name.\n    test(\"var a=0;\" +\n         \"function foo(a){return 3+a}\" +\n         \"function bar(){var a=foo(4)}\" +\n         \"bar();\",\n\n         \"var a=0;\" +\n         \"{var a$$inline_0=3+4}\");\n  }\n", "  public void testShadowVariables3() {\n    // \"foo\" is inlined into exported \"_bar\", aliasing foo's \"a\".\n    test(\"var a=0;\" +\n        \"function foo(){var a=2;return 3+a}\" +\n        \"function _bar(){a=foo()}\",\n\n        \"var a=0;\" +\n        \"function _bar(){{var a$$inline_0=2;\" +\n        \"a=3+a$$inline_0}}\");\n  }\n", "  public void testShadowVariables6() {\n    test(\"var a=0;\" +\n        \"function foo(){var a=4;return 3+a}\" +\n        \"function _bar(a){a=foo(4)}\",\n\n        \"var a=0;function _bar(a$$2){{\" +\n        \"var a$$inline_0=4;\" +\n        \"a$$2=3+a$$inline_0}}\");\n  }\n", "  public void testShadowVariables7() {\n    assumeMinimumCapture = false;\n    test(\"var a=3;\" +\n         \"function foo(){return a}\" +\n         \"(function(){var a=5;(function(){foo()})()})()\",\n         \"var a=3;\" +\n         \"{var a$$inline_0=5;{a}}\"\n         );\n\n    assumeMinimumCapture = true;\n    test(\"var a=3;\" +\n         \"function foo(){return a}\" +\n         \"(function(){var a=5;(function(){foo()})()})()\",\n         \"var a=3;\" +\n         \"{var a$$inline_1=5;{a}}\"\n         );\n  }\n", "  public void testShadowVariables10() {\n    // callee var must be renamed.\n    test(\"var a;function foo(){return a}\" +\n         \"function _bar(){var a=foo()}\",\n         \"var a;function _bar(){var a$$1=a}\");\n  }\n", "  public void testShadowVariables11() {\n    // The call has a local variable\n    // which collides with the function being inlined\n    test(\"var a=0;var b=1;\" +\n         \"function foo(){return a+a}\" +\n         \"function _bar(){var a=foo();alert(a)}\",\n         \"var a=0;var b=1;\" +\n         \"function _bar(){var a$$1=a+a;\" +\n         \"alert(a$$1)}\"\n         );\n  }\n", "  public void testShadowVariables12() {\n    // 2 globals colliding\n    test(\"var a=0;var b=1;\" +\n         \"function foo(){return a+b}\" +\n         \"function _bar(){var a=foo(),b;alert(a)}\",\n         \"var a=0;var b=1;\" +\n         \"function _bar(){var a$$1=a+b,\" +\n         \"b$$1;\" +\n         \"alert(a$$1)}\");\n  }\n", "  public void testShadowVariables13() {\n    // The only change is to remove the collision\n    test(\"var a=0;var b=1;\" +\n         \"function foo(){return a+a}\" +\n         \"function _bar(){var c=foo();alert(c)}\",\n\n         \"var a=0;var b=1;\" +\n         \"function _bar(){var c=a+a;alert(c)}\");\n  }\n", "  public void testShadowVariables14() {\n    // There is a colision even though it is not read.\n    test(\"var a=0;var b=1;\" +\n         \"function foo(){return a+b}\" +\n         \"function _bar(){var c=foo(),b;alert(c)}\",\n         \"var a=0;var b=1;\" +\n         \"function _bar(){var c=a+b,\" +\n         \"b$$1;alert(c)}\");\n  }\n", "  public void testShadowVariables15() {\n    // Both parent and child reference a global\n    test(\"var a=0;var b=1;\" +\n         \"function foo(){return a+a}\" +\n         \"function _bar(){var c=foo();alert(c+a)}\",\n\n         \"var a=0;var b=1;\" +\n         \"function _bar(){var c=a+a;alert(c+a)}\");\n  }\n", "  public void testShadowVariables16() {\n    assumeMinimumCapture = false;\n    // Inline functions defined as a child of the CALL node.\n    test(\"var a=3;\" +\n         \"function foo(){return a}\" +\n         \"(function(){var a=5;(function(){foo()})()})()\",\n         \"var a=3;\" +\n         \"{var a$$inline_0=5;{a}}\"\n         );\n\n    assumeMinimumCapture = true;\n    // Inline functions defined as a child of the CALL node.\n    test(\"var a=3;\" +\n         \"function foo(){return a}\" +\n         \"(function(){var a=5;(function(){foo()})()})()\",\n         \"var a=3;\" +\n         \"{var a$$inline_1=5;{a}}\"\n         );\n\n  }\n", "  public void testShadowVariables17() {\n    test(\"var a=0;\" +\n         \"function bar(){return a+a}\" +\n         \"function foo(){return bar()}\" +\n         \"function _goo(){var a=2;var x=foo();}\",\n\n         \"var a=0;\" +\n         \"function _goo(){var a$$1=2;var x=a+a}\");\n  }\n", "  public void testShadowVariables18() {\n    test(\"var a=0;\" +\n        \"function bar(){return a+a}\" +\n        \"function foo(){var a=3;return bar()}\" +\n        \"function _goo(){var a=2;var x=foo();}\",\n\n        \"var a=0;\" +\n        \"function _goo(){var a$$2=2;var x;\" +\n        \"{var a$$inline_0=3;x=a+a}}\");\n  }\n", "  public void testCostBasedInlining9() {\n    // Here both direct and block inlining is used.  The call to f as a\n    // parameter is inlined directly, which the call to f with f as a parameter\n    // is inlined using block inlining.\n    test(\"function f(a){return 1 + a + a;}\" +\n         \"var a = f(f(1));\",\n         \"var a;\" +\n         \"{var a$$inline_0=1+1+1;\" +\n         \"a=1+a$$inline_0+a$$inline_0}\");\n  }\n", "  public void testCostBasedInlining11() {\n    // With block inlining\n    test(\"function f(a){return a + a;}\" +\n         \"var a = f(f(1))\",\n         \"var a;\" +\n         \"{var a$$inline_0=1+1;\" +\n         \"a=a$$inline_0+a$$inline_0}\");\n  }\n", "  public void testComplexInlineNoResultNoParamCall3() {\n    // We now allow vars in the global space.\n    //   Don't inline into vars into global scope.\n    //   testSame(\"function f(){a();b();var z=1+1}f()\");\n\n    // But do inline into functions\n    test(\"function f(){a();b();var z=1+1}function _foo(){f()}\",\n         \"function _foo(){{a();b();var z$$inline_0=1+1}}\");\n\n  }\n", "  public void testComplexInline7() {\n    test(\"function f(x,y){if (x) return y(); else return true;}\" +\n         \"var b=1;z=f(1,b)\",\n         \"var b=1;{JSCompiler_inline_label_f_2:{if(1){z=b();\" +\n         \"break JSCompiler_inline_label_f_2}else{z=true;\" +\n         \"break JSCompiler_inline_label_f_2}z=void 0}}\");\n  }\n", "  public void testComplexInlineVars7() {\n    test(\"function f(x,y){if (x) return y(); else return true;}\" +\n         \"var b=1;var z=f(1,b)\",\n         \"var b=1;var z;\" +\n         \"{JSCompiler_inline_label_f_2:{if(1){z=b();\" +\n         \"break JSCompiler_inline_label_f_2\" +\n         \"}else{\" +\n         \"z=true;break JSCompiler_inline_label_f_2}z=void 0}}\");\n  }\n", "  public void testComplexSample() {\n    String result = \"\" +\n      \"{{\" +\n      \"var styleSheet$$inline_2=null;\" +\n      \"if(goog$userAgent$IE)\" +\n        \"styleSheet$$inline_2=0;\" +\n      \"else \" +\n        \"var head$$inline_3=0;\" +\n      \"{\" +\n        \"var element$$inline_4=\" +\n            \"styleSheet$$inline_2;\" +\n        \"var stylesString$$inline_5=a;\" +\n        \"if(goog$userAgent$IE)\" +\n          \"element$$inline_4.cssText=\" +\n              \"stylesString$$inline_5;\" +\n        \"else \" +\n        \"{\" +\n          \"var propToSet$$inline_6=\" +\n              \"\\\"innerText\\\";\" +\n          \"element$$inline_4[\" +\n              \"propToSet$$inline_6]=\" +\n                  \"stylesString$$inline_5\" +\n        \"}\" +\n      \"}\" +\n      \"styleSheet$$inline_2\" +\n      \"}}\";\n\n    test(\"var foo = function(stylesString, opt_element) { \" +\n        \"var styleSheet = null;\" +\n        \"if (goog$userAgent$IE)\" +\n          \"styleSheet = 0;\" +\n        \"else \" +\n          \"var head = 0;\" +\n        \"\" +\n        \"goo$zoo(styleSheet, stylesString);\" +\n        \"return styleSheet;\" +\n     \" };\\n \" +\n\n     \"var goo$zoo = function(element, stylesString) {\" +\n        \"if (goog$userAgent$IE)\" +\n          \"element.cssText = stylesString;\" +\n        \"else {\" +\n          \"var propToSet = 'innerText';\" +\n          \"element[propToSet] = stylesString;\" +\n        \"}\" +\n      \"};\" +\n      \"(function(){foo(a,b);})();\",\n     result);\n  }\n", "  public void testComplexSampleNoInline() {\n    // This is the result we would expect if we could handle \"foo = function\"\n    String result =\n    \"foo=function(stylesString,opt_element){\" +\n        \"var styleSheet=null;\" +\n        \"if(goog$userAgent$IE){\" +\n          \"styleSheet=0\" +\n        \"}else{\" +\n          \"var head=0\" +\n         \"}\" +\n         \"{var JSCompiler_inline_element_0=styleSheet;\" +\n         \"var JSCompiler_inline_stylesString_1=stylesString;\" +\n         \"if(goog$userAgent$IE){\" +\n           \"JSCompiler_inline_element_0.cssText=\" +\n           \"JSCompiler_inline_stylesString_1\" +\n         \"}else{\" +\n           \"var propToSet=goog$userAgent$WEBKIT?\\\"innerText\\\":\\\"innerHTML\\\";\" +\n           \"JSCompiler_inline_element_0[propToSet]=\" +\n           \"JSCompiler_inline_stylesString_1\" +\n         \"}}\" +\n        \"return styleSheet\" +\n     \"}\";\n\n    testSame(\n      \"foo=function(stylesString,opt_element){\" +\n        \"var styleSheet=null;\" +\n        \"if(goog$userAgent$IE)\" +\n          \"styleSheet=0;\" +\n        \"else \" +\n          \"var head=0;\" +\n        \"\" +\n        \"goo$zoo(styleSheet,stylesString);\" +\n        \"return styleSheet\" +\n     \"};\" +\n     \"goo$zoo=function(element,stylesString){\" +\n        \"if(goog$userAgent$IE)\" +\n          \"element.cssText=stylesString;\" +\n        \"else{\" +\n          \"var propToSet=goog$userAgent$WEBKIT?\\\"innerText\\\":\\\"innerHTML\\\";\" +\n          \"element[propToSet]=stylesString\" +\n        \"}\" +\n      \"}\");\n  }\n", "  public void testComplexFunctionWithFunctionDefinition2() {\n    assumeMinimumCapture = false;\n\n    // Don't inline if local names might be captured.\n    testSame(\"function f(a){call(function(){return})}f()\");\n\n    assumeMinimumCapture = true;\n\n    test(\"(function(){\" +\n         \"var f = function(a){call(function(){return a})};f()})()\",\n         \"{{var a$$inline_0=void 0;call(function(){return a$$inline_0})}}\");\n  }\n", "  public void testComplexFunctionWithFunctionDefinition2a() {\n    assumeMinimumCapture = false;\n\n    // Don't inline if local names might be captured.\n    testSame(\"(function(){\" +\n        \"var f = function(a){call(function(){return a})};f()})()\");\n\n    assumeMinimumCapture = true;\n\n    test(\"(function(){\" +\n         \"var f = function(a){call(function(){return a})};f()})()\",\n         \"{{var a$$inline_0=void 0;call(function(){return a$$inline_0})}}\");\n  }\n", "  public void testComplexFunctionWithFunctionDefinition3() {\n    assumeMinimumCapture = false;\n\n    // Don't inline if local names might need to be captured.\n    testSame(\"function f(){var a; call(function(){return a})}f()\");\n\n    assumeMinimumCapture = true;\n\n    test(\"function f(){var a; call(function(){return a})}f()\",\n         \"{var a$$inline_0;call(function(){return a$$inline_0})}\");\n\n  }\n", "  public void testDecomposeFunctionExpressionInCall() {\n    test(\n        \"(function(map){descriptions_=map})(\\n\" +\n           \"function(){\\n\" +\n              \"var ret={};\\n\" +\n              \"ret[ONE]='a';\\n\" +\n              \"ret[TWO]='b';\\n\" +\n              \"return ret\\n\" +\n           \"}()\\n\" +\n        \");\",\n        \"{\" +\n        \"var JSCompiler_inline_result$$0;\" +\n        \"var ret$$inline_1={};\\n\" +\n        \"ret$$inline_1[ONE]='a';\\n\" +\n        \"ret$$inline_1[TWO]='b';\\n\" +\n        \"JSCompiler_inline_result$$0 = ret$$inline_1;\\n\" +\n        \"}\" +\n        \"{\" +\n        \"descriptions_=JSCompiler_inline_result$$0;\" +\n        \"}\"\n        );\n  }\n", "  public void testFunctionExpressionCallInlining11b() {\n    assumeMinimumCapture = false;\n    // Can't inline functions that return inner functions and have local names.\n    testSame(\"((function(){var a; return function(){foo()}})())();\");\n\n    assumeMinimumCapture = true;\n    test(\n        \"((function(){var a; return function(){foo()}})())();\",\n\n        \"{var JSCompiler_inline_result$$0;\" +\n        \"var a$$inline_1;\" +\n        \"JSCompiler_inline_result$$0=function(){foo()};}\" +\n        \"JSCompiler_inline_result$$0()\");\n\n  }\n", "  public void testFunctionExpressionOmega() {\n    // ... with unused recursive name.\n    test(\"(function (f){f(f)})(function(f){f(f)})\",\n         \"{var f$$inline_0=function(f$$1){f$$1(f$$1)};\" +\n          \"{{f$$inline_0(f$$inline_0)}}}\");\n  }\n", "  public void testInlineWithThis7() {\n    assumeStrictThis = true;\n    // In strict mode, \"this\" is never coerced so we can use the provided value.\n    test(\"function f(a){a=1;this} f.call();\",\n         \"{var a$$inline_0=void 0; a$$inline_0=1; void 0;}\");\n    test(\"function f(a){a=1;this} f.call(x, x);\",\n         \"{var a$$inline_0=x; a$$inline_0=1; x;}\");\n  }\n", "  public void testFunctionExpressionYCombinator() {\n    assumeMinimumCapture = false;\n    testSame(\n        \"var factorial = ((function(M) {\\n\" +\n        \"      return ((function(f) {\\n\" +\n        \"                 return M(function(arg) {\\n\" +\n        \"                            return (f(f))(arg);\\n\" +\n        \"                            })\\n\" +\n        \"               })\\n\" +\n        \"              (function(f) {\\n\" +\n        \"                 return M(function(arg) {\\n\" +\n        \"                            return (f(f))(arg);\\n\" +\n        \"                           })\\n\" +\n        \"                 }));\\n\" +\n        \"     })\\n\" +\n        \"    (function(f) {\\n\" +\n        \"       return function(n) {\\n\" +\n        \"        if (n === 0)\\n\" +\n        \"          return 1;\\n\" +\n        \"        else\\n\" +\n        \"          return n * f(n - 1);\\n\" +\n        \"       };\\n\" +\n        \"     }));\\n\" +\n        \"\\n\" +\n        \"factorial(5)\\n\");\n\n    assumeMinimumCapture = true;\n    test(\n        \"var factorial = ((function(M) {\\n\" +\n        \"      return ((function(f) {\\n\" +\n        \"                 return M(function(arg) {\\n\" +\n        \"                            return (f(f))(arg);\\n\" +\n        \"                            })\\n\" +\n        \"               })\\n\" +\n        \"              (function(f) {\\n\" +\n        \"                 return M(function(arg) {\\n\" +\n        \"                            return (f(f))(arg);\\n\" +\n        \"                           })\\n\" +\n        \"                 }));\\n\" +\n        \"     })\\n\" +\n        \"    (function(f) {\\n\" +\n        \"       return function(n) {\\n\" +\n        \"        if (n === 0)\\n\" +\n        \"          return 1;\\n\" +\n        \"        else\\n\" +\n        \"          return n * f(n - 1);\\n\" +\n        \"       };\\n\" +\n        \"     }));\\n\" +\n        \"\\n\" +\n        \"factorial(5)\\n\",\n        \"var factorial;\\n\" +\n        \"{\\n\" +\n        \"var M$$inline_4 = function(f$$2) {\\n\" +\n        \"  return function(n){if(n===0)return 1;else return n*f$$2(n-1)}\\n\" +\n        \"};\\n\" +\n        \"{\\n\" +\n        \"var f$$inline_0=function(f$$inline_7){\\n\" +\n        \"  return M$$inline_4(\\n\" +\n        \"    function(arg$$inline_8){\\n\" +\n        \"      return f$$inline_7(f$$inline_7)(arg$$inline_8)\\n\" +\n        \"     })\\n\" +\n        \"};\\n\" +\n        \"factorial=M$$inline_4(\\n\" +\n        \"  function(arg$$inline_1){\\n\" +\n        \"    return f$$inline_0(f$$inline_0)(arg$$inline_1)\\n\" +\n        \"});\\n\" +\n        \"}\\n\" +\n        \"}\" +\n        \"factorial(5)\");\n  }\n", "  public void testBug4944818() {\n    test(\n        \"var getDomServices_ = function(self) {\\n\" +\n        \"  if (!self.domServices_) {\\n\" +\n        \"    self.domServices_ = goog$component$DomServices.get(\" +\n        \"        self.appContext_);\\n\" +\n        \"  }\\n\" +\n        \"\\n\" +\n        \"  return self.domServices_;\\n\" +\n        \"};\\n\" +\n        \"\\n\" +\n        \"var getOwnerWin_ = function(self) {\\n\" +\n        \"  return getDomServices_(self).getDomHelper().getWindow();\\n\" +\n        \"};\\n\" +\n        \"\\n\" +\n        \"HangoutStarter.prototype.launchHangout = function() {\\n\" +\n        \"  var self = a.b;\\n\" +\n        \"  var myUrl = new goog.Uri(getOwnerWin_(self).location.href);\\n\" +\n        \"};\",\n        \"HangoutStarter.prototype.launchHangout = function() { \" +\n        \"  var self$$2 = a.b;\" +\n        \"  var JSCompiler_temp_const$$0 = goog.Uri;\" +\n        \"  {\" +\n        \"  var JSCompiler_inline_result$$1;\" +\n        \"  var self$$inline_2 = self$$2;\" +\n        \"  if (!self$$inline_2.domServices_) {\" +\n        \"    self$$inline_2.domServices_ = goog$component$DomServices.get(\" +\n        \"        self$$inline_2.appContext_);\" +\n        \"  }\" +\n        \"  JSCompiler_inline_result$$1=self$$inline_2.domServices_;\" +\n        \"  }\" +\n        \"  var myUrl = new JSCompiler_temp_const$$0(\" +\n        \"      JSCompiler_inline_result$$1.getDomHelper().\" +\n        \"          getWindow().location.href)\" +\n        \"}\");\n  }\n", "  public void testIssue423() {\n    assumeMinimumCapture = false;\n    test(\n        \"(function($) {\\n\" +\n        \"  $.fn.multicheck = function(options) {\\n\" +\n        \"    initialize.call(this, options);\\n\" +\n        \"  };\\n\" +\n        \"\\n\" +\n        \"  function initialize(options) {\\n\" +\n        \"    options.checkboxes = $(this).siblings(':checkbox');\\n\" +\n        \"    preload_check_all.call(this);\\n\" +\n        \"  }\\n\" +\n        \"\\n\" +\n        \"  function preload_check_all() {\\n\" +\n        \"    $(this).data('checkboxes');\\n\" +\n        \"  }\\n\" +\n        \"})(jQuery)\",\n        \"(function($){\" +\n        \"  $.fn.multicheck=function(options$$1){\" +\n        \"    {\" +\n        \"     options$$1.checkboxes=$(this).siblings(\\\":checkbox\\\");\" +\n        \"     {\" +\n        \"       $(this).data(\\\"checkboxes\\\")\" +\n        \"     }\" +\n        \"    }\" +\n        \"  }\" +\n        \"})(jQuery)\");\n\n    assumeMinimumCapture = true;\n    test(\n        \"(function($) {\\n\" +\n        \"  $.fn.multicheck = function(options) {\\n\" +\n        \"    initialize.call(this, options);\\n\" +\n        \"  };\\n\" +\n        \"\\n\" +\n        \"  function initialize(options) {\\n\" +\n        \"    options.checkboxes = $(this).siblings(':checkbox');\\n\" +\n        \"    preload_check_all.call(this);\\n\" +\n        \"  }\\n\" +\n        \"\\n\" +\n        \"  function preload_check_all() {\\n\" +\n        \"    $(this).data('checkboxes');\\n\" +\n        \"  }\\n\" +\n        \"})(jQuery)\",\n        \"{var $$$inline_0=jQuery;\\n\" +\n        \"$$$inline_0.fn.multicheck=function(options$$inline_4){\\n\" +\n        \"  {options$$inline_4.checkboxes=\" +\n            \"$$$inline_0(this).siblings(\\\":checkbox\\\");\\n\" +\n        \"  {$$$inline_0(this).data(\\\"checkboxes\\\")}\" +\n        \"  }\\n\" +\n        \"}\\n\" +\n        \"}\");\n  }\n", "  public void testAnonymous1() {\n    assumeMinimumCapture = false;\n    test(\"(function(){var a=10;(function(){var b=a;a++;alert(b)})()})();\",\n         \"{var a$$inline_0=10;\" +\n         \"{var b$$inline_1=a$$inline_0;\" +\n         \"a$$inline_0++;alert(b$$inline_1)}}\");\n\n    assumeMinimumCapture = true;\n    test(\"(function(){var a=10;(function(){var b=a;a++;alert(b)})()})();\",\n        \"{var a$$inline_2=10;\" +\n        \"{var b$$inline_0=a$$inline_2;\" +\n        \"a$$inline_2++;alert(b$$inline_0)}}\");\n  }\n", "  public void testAnonymous3() {\n    // Introducing a new value into is tricky\n    assumeMinimumCapture = false;\n    testSame(\"(function(){var a=10;(function(){arguments;})()})();\");\n\n    assumeMinimumCapture = true;\n    test(\"(function(){var a=10;(function(){arguments;})()})();\",\n         \"{var a$$inline_0=10;(function(){arguments;})();}\");\n\n    test(\"(function(){(function(){arguments;})()})();\",\n        \"{(function(){arguments;})()}\");\n  }\n", "  public void testLoopWithFunctionWithFunction() {\n    assumeMinimumCapture = true;\n    test(\"function _testLocalVariableInLoop_() {\\n\" +\n        \"  var result = 0;\\n\" +\n        \"  function foo() {\\n\" +\n        \"    var arr = [1, 2, 3, 4, 5];\\n\" +\n        \"    for (var i = 0, l = arr.length; i < l; i++) {\\n\" +\n        \"      var j = arr[i];\\n\" +\n        // don't inline this function, because the correct behavior depends\n        // captured values.\n        \"      (function() {\\n\" +\n        \"        var k = j;\\n\" +\n        \"        setTimeout(function() { result += k; }, 5 * i);\\n\" +\n        \"      })();\\n\" +\n        \"    }\\n\" +\n        \"  }\\n\" +\n        \"  foo();\\n\" +\n        \"}\",\n        \"function _testLocalVariableInLoop_(){\\n\" +\n        \"  var result=0;\\n\" +\n        \"  {\" +\n        \"  var arr$$inline_0=[1,2,3,4,5];\\n\" +\n        \"  var i$$inline_1=0;\\n\" +\n        \"  var l$$inline_2=arr$$inline_0.length;\\n\" +\n        \"  for(;i$$inline_1<l$$inline_2;i$$inline_1++){\\n\" +\n        \"    var j$$inline_3=arr$$inline_0[i$$inline_1];\\n\" +\n        \"    (function(){\\n\" +\n        \"       var k$$inline_4=j$$inline_3;\\n\" +\n        \"       setTimeout(function(){result+=k$$inline_4},5*i$$inline_1)\\n\" +\n        \"     })()\\n\" +\n        \"  }\\n\" +\n        \"  }\\n\" +\n        \"}\");\n  }\n", "  public void testMethodWithFunctionWithFunction() {\n    assumeMinimumCapture = true;\n    test(\"function _testLocalVariable_() {\\n\" +\n        \"  var result = 0;\\n\" +\n        \"  function foo() {\\n\" +\n        \"      var j = [i];\\n\" +\n        \"      (function(j) {\\n\" +\n        \"        setTimeout(function() { result += j; }, 5 * i);\\n\" +\n        \"      })(j);\\n\" +\n        \"      j = null;\" +\n        \"  }\\n\" +\n        \"  foo();\\n\" +\n        \"}\",\n        \"function _testLocalVariable_(){\\n\" +\n        \"  var result=0;\\n\" +\n        \"  {\\n\" +\n        \"  var j$$inline_2=[i];\\n\" +\n        \"  {\\n\" +\n        \"  var j$$inline_0=j$$inline_2;\\n\" +  // this temp is needed.\n        \"  setTimeout(function(){result+=j$$inline_0},5*i);\\n\" +\n        \"  }\\n\" +\n        \"  j$$inline_2=null\\n\" + // because this value can be modified later.\n        \"  }\\n\" +\n        \"}\");\n  }\n", "  public void testMakeLocalNamesUniqueWithContext5() {\n    // Set the test type\n    this.useDefaultRenamer = true;\n\n    testWithInversion(\n        \"function f(){var f; f = 1}\",\n        \"function f(){var f$$1; f$$1 = 1}\");\n    testWithInversion(\n        \"function f(f){f = 1}\",\n        \"function f(f$$1){f$$1 = 1}\");\n    testWithInversion(\n        \"function f(f){var f; f = 1}\",\n        \"function f(f$$1){var f$$1; f$$1 = 1}\");\n\n    test(\n        \"var fn = function f(){var f; f = 1}\",\n        \"var fn = function f(){var f$$1; f$$1 = 1}\");\n    test(\n        \"var fn = function f(f){f = 1}\",\n        \"var fn = function f(f$$1){f$$1 = 1}\");\n    test(\n        \"var fn = function f(f){var f; f = 1}\",\n        \"var fn = function f(f$$1){var f$$1; f$$1 = 1}\");\n  }\n"], "Lang_7": ["    @Test\n    public void testCreateNumber() {\n        // a lot of things can go wrong\n        assertEquals(\"createNumber(String) 1 failed\", Float.valueOf(\"1234.5\"), NumberUtils.createNumber(\"1234.5\"));\n        assertEquals(\"createNumber(String) 2 failed\", Integer.valueOf(\"12345\"), NumberUtils.createNumber(\"12345\"));\n        assertEquals(\"createNumber(String) 3 failed\", Double.valueOf(\"1234.5\"), NumberUtils.createNumber(\"1234.5D\"));\n        assertEquals(\"createNumber(String) 3 failed\", Double.valueOf(\"1234.5\"), NumberUtils.createNumber(\"1234.5d\"));\n        assertEquals(\"createNumber(String) 4 failed\", Float.valueOf(\"1234.5\"), NumberUtils.createNumber(\"1234.5F\"));\n        assertEquals(\"createNumber(String) 4 failed\", Float.valueOf(\"1234.5\"), NumberUtils.createNumber(\"1234.5f\"));\n        assertEquals(\"createNumber(String) 5 failed\", Long.valueOf(Integer.MAX_VALUE + 1L), NumberUtils.createNumber(\"\"\n            + (Integer.MAX_VALUE + 1L)));\n        assertEquals(\"createNumber(String) 6 failed\", Long.valueOf(12345), NumberUtils.createNumber(\"12345L\"));\n        assertEquals(\"createNumber(String) 6 failed\", Long.valueOf(12345), NumberUtils.createNumber(\"12345l\"));\n        assertEquals(\"createNumber(String) 7 failed\", Float.valueOf(\"-1234.5\"), NumberUtils.createNumber(\"-1234.5\"));\n        assertEquals(\"createNumber(String) 8 failed\", Integer.valueOf(\"-12345\"), NumberUtils.createNumber(\"-12345\"));\n        assertTrue(\"createNumber(String) 9a failed\", 0xFADE == NumberUtils.createNumber(\"0xFADE\").intValue());\n        assertTrue(\"createNumber(String) 9b failed\", 0xFADE == NumberUtils.createNumber(\"0Xfade\").intValue());\n        assertTrue(\"createNumber(String) 10a failed\", -0xFADE == NumberUtils.createNumber(\"-0xFADE\").intValue());\n        assertTrue(\"createNumber(String) 10b failed\", -0xFADE == NumberUtils.createNumber(\"-0Xfade\").intValue());\n        assertEquals(\"createNumber(String) 11 failed\", Double.valueOf(\"1.1E200\"), NumberUtils.createNumber(\"1.1E200\"));\n        assertEquals(\"createNumber(String) 12 failed\", Float.valueOf(\"1.1E20\"), NumberUtils.createNumber(\"1.1E20\"));\n        assertEquals(\"createNumber(String) 13 failed\", Double.valueOf(\"-1.1E200\"), NumberUtils.createNumber(\"-1.1E200\"));\n        assertEquals(\"createNumber(String) 14 failed\", Double.valueOf(\"1.1E-200\"), NumberUtils.createNumber(\"1.1E-200\"));\n        assertEquals(\"createNumber(null) failed\", null, NumberUtils.createNumber(null));\n        assertEquals(\"createNumber(String) failed\", new BigInteger(\"12345678901234567890\"), NumberUtils\n                .createNumber(\"12345678901234567890L\"));\n\n        // jdk 1.2 doesn't support this. unsure about jdk 1.2.2\n        if (SystemUtils.isJavaVersionAtLeast(JAVA_1_3)) {\n            assertEquals(\"createNumber(String) 15 failed\", new BigDecimal(\"1.1E-700\"), NumberUtils\n                    .createNumber(\"1.1E-700F\"));\n        }\n        assertEquals(\"createNumber(String) 16 failed\", Long.valueOf(\"10\" + Integer.MAX_VALUE), NumberUtils\n                .createNumber(\"10\" + Integer.MAX_VALUE + \"L\"));\n        assertEquals(\"createNumber(String) 17 failed\", Long.valueOf(\"10\" + Integer.MAX_VALUE), NumberUtils\n                .createNumber(\"10\" + Integer.MAX_VALUE));\n        assertEquals(\"createNumber(String) 18 failed\", new BigInteger(\"10\" + Long.MAX_VALUE), NumberUtils\n                .createNumber(\"10\" + Long.MAX_VALUE));\n\n        // LANG-521\n        assertEquals(\"createNumber(String) LANG-521 failed\", Float.valueOf(\"2.\"), NumberUtils.createNumber(\"2.\"));\n\n        // LANG-638\n        assertFalse(\"createNumber(String) succeeded\", checkCreateNumber(\"1eE\"));\n\n        // LANG-693\n        assertEquals(\"createNumber(String) LANG-693 failed\", Double.valueOf(Double.MAX_VALUE), NumberUtils\n                    .createNumber(\"\" + Double.MAX_VALUE));\n        \n        // LANG-822\n        // ensure that the underlying negative number would create a BigDecimal\n        final Number bigNum = NumberUtils.createNumber(\"-1.1E-700F\");\n        assertEquals(BigDecimal.class,bigNum.getClass());\n        assertNotNull(bigNum);\n\n        // Check that the code fails to create a valid number when preceeded by -- rather than -\n        try {\n            NumberUtils.createNumber(\"--1.1E-700F\");\n            fail(\"Expected NumberFormatException\");\n        } catch (NumberFormatException nfe) {\n            // expected\n        }\n    }\n"], "Lang_60": ["    public void testLang295() {\n        StrBuilder sb = new StrBuilder(\"onetwothree\");\n        sb.deleteFirst(\"three\");\n        assertFalse( \"The contains(char) method is looking beyond the end of the string\", sb.contains('h'));\n        assertEquals( \"The indexOf(char) method is looking beyond the end of the string\", -1, sb.indexOf('h'));\n    }\n"], "Closure_15": ["  public void testSimpleForIn() {\n    inline(\"var a,b,x = a in b; x\",\n           \"var a,b,x; a in b\");\n    noInline(\"var a, b; var x = a in b; print(1); x\");\n    noInline(\"var a,b,x = a in b; delete a[b]; x\");\n  }\n"], "Chart_10": ["    public void testGenerateURLFragment() {\n        StandardToolTipTagFragmentGenerator g\n                = new StandardToolTipTagFragmentGenerator();\n        assertEquals(\" title=\\\"abc\\\" alt=\\\"\\\"\",\n                g.generateToolTipFragment(\"abc\"));\n        assertEquals(\" title=\\\"Series &quot;A&quot;, 100.0\\\" alt=\\\"\\\"\",\n                g.generateToolTipFragment(\"Series \\\"A\\\", 100.0\"));\n    }\n"], "Lang_58": ["    public void testLang300() {\n        NumberUtils.createNumber(\"-1l\");\n        NumberUtils.createNumber(\"01l\");\n        NumberUtils.createNumber(\"1l\");\n    }\n"], "Chart_17": ["    public void testBug1832432() {\n        TimeSeries s1 = new TimeSeries(\"Series\");\n        TimeSeries s2 = null;\n        try {\n            s2 = (TimeSeries) s1.clone();\n        }\n        catch (CloneNotSupportedException e) {\n            e.printStackTrace();\n        }\n        assertTrue(s1 != s2);\n        assertTrue(s1.getClass() == s2.getClass());\n        assertTrue(s1.equals(s2));\n\n        // test independence\n        s1.add(new Day(1, 1, 2007), 100.0);\n        assertFalse(s1.equals(s2));    \t\n    }\n"], "Closure_12": ["  public void testIssue794b() {\n    noInline(\n        \"var x = 1; \" +\n        \"try { x = x + someFunction(); } catch (e) {}\" +\n        \"x = x + 1;\" +\n        \"try { x = x + someFunction(); } catch (e) {}\" +\n        \"return x;\");\n  }\n"], "Lang_51": ["    public void test_toBoolean_String() {\n        assertEquals(false, BooleanUtils.toBoolean((String) null));\n        assertEquals(false, BooleanUtils.toBoolean(\"\"));\n        assertEquals(false, BooleanUtils.toBoolean(\"off\"));\n        assertEquals(false, BooleanUtils.toBoolean(\"oof\"));\n        assertEquals(false, BooleanUtils.toBoolean(\"yep\"));\n        assertEquals(false, BooleanUtils.toBoolean(\"trux\"));\n        assertEquals(false, BooleanUtils.toBoolean(\"false\"));\n        assertEquals(false, BooleanUtils.toBoolean(\"a\"));\n        assertEquals(true, BooleanUtils.toBoolean(\"true\")); // interned handled differently\n        assertEquals(true, BooleanUtils.toBoolean(new StringBuffer(\"tr\").append(\"ue\").toString()));\n        assertEquals(true, BooleanUtils.toBoolean(\"truE\"));\n        assertEquals(true, BooleanUtils.toBoolean(\"trUe\"));\n        assertEquals(true, BooleanUtils.toBoolean(\"trUE\"));\n        assertEquals(true, BooleanUtils.toBoolean(\"tRue\"));\n        assertEquals(true, BooleanUtils.toBoolean(\"tRuE\"));\n        assertEquals(true, BooleanUtils.toBoolean(\"tRUe\"));\n        assertEquals(true, BooleanUtils.toBoolean(\"tRUE\"));\n        assertEquals(true, BooleanUtils.toBoolean(\"TRUE\"));\n        assertEquals(true, BooleanUtils.toBoolean(\"TRUe\"));\n        assertEquals(true, BooleanUtils.toBoolean(\"TRuE\"));\n        assertEquals(true, BooleanUtils.toBoolean(\"TRue\"));\n        assertEquals(true, BooleanUtils.toBoolean(\"TrUE\"));\n        assertEquals(true, BooleanUtils.toBoolean(\"TrUe\"));\n        assertEquals(true, BooleanUtils.toBoolean(\"TruE\"));\n        assertEquals(true, BooleanUtils.toBoolean(\"True\"));\n        assertEquals(true, BooleanUtils.toBoolean(\"on\"));\n        assertEquals(true, BooleanUtils.toBoolean(\"oN\"));\n        assertEquals(true, BooleanUtils.toBoolean(\"On\"));\n        assertEquals(true, BooleanUtils.toBoolean(\"ON\"));\n        assertEquals(true, BooleanUtils.toBoolean(\"yes\"));\n        assertEquals(true, BooleanUtils.toBoolean(\"yeS\"));\n        assertEquals(true, BooleanUtils.toBoolean(\"yEs\"));\n        assertEquals(true, BooleanUtils.toBoolean(\"yES\"));\n        assertEquals(true, BooleanUtils.toBoolean(\"Yes\"));\n        assertEquals(true, BooleanUtils.toBoolean(\"YeS\"));\n        assertEquals(true, BooleanUtils.toBoolean(\"YEs\"));\n        assertEquals(true, BooleanUtils.toBoolean(\"YES\"));\n        assertEquals(false, BooleanUtils.toBoolean(\"yes?\"));\n        assertEquals(false, BooleanUtils.toBoolean(\"tru\"));\n    }\n", "    public void test_toBoolean_String_String_String() {\n        assertEquals(true, BooleanUtils.toBoolean((String) null, null, \"N\"));\n        assertEquals(false, BooleanUtils.toBoolean((String) null, \"Y\", null));\n        try {\n            BooleanUtils.toBooleanObject((String) null, \"Y\", \"N\", \"U\");\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        \n        assertEquals(true, BooleanUtils.toBoolean(\"Y\", \"Y\", \"N\"));\n        assertEquals(false, BooleanUtils.toBoolean(\"N\", \"Y\", \"N\"));\n        try {\n            BooleanUtils.toBoolean(null, \"Y\", \"N\");\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            BooleanUtils.toBoolean(\"X\", \"Y\", \"N\");\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }\n"], "Lang_9": ["    @Test\n    public void testLANG_832() throws Exception {\n        testSdfAndFdp(\"'d'd\" ,\"d3\", false); // OK\n        testSdfAndFdp(\"'d'd'\",\"d3\", true); // should fail (unterminated quote)\n    }\n"], "Chart_21": ["    public void testGetRangeBounds() {\n        DefaultBoxAndWhiskerCategoryDataset d1 \n                = new DefaultBoxAndWhiskerCategoryDataset();\n        d1.add(new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, \n                new ArrayList()), \"R1\", \"C1\");\n        assertEquals(new Range(7.0, 8.0), d1.getRangeBounds(false));\n        assertEquals(new Range(7.0, 8.0), d1.getRangeBounds(true));\n        \n        d1.add(new BoxAndWhiskerItem(1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, \n                new ArrayList()), \"R1\", \"C1\");\n        assertEquals(new Range(7.5, 8.5), d1.getRangeBounds(false));\n        assertEquals(new Range(7.5, 8.5), d1.getRangeBounds(true));\n        \n        d1.add(new BoxAndWhiskerItem(2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, \n                new ArrayList()), \"R2\", \"C1\");\n        assertEquals(new Range(7.5, 9.5), d1.getRangeBounds(false));\n        assertEquals(new Range(7.5, 9.5), d1.getRangeBounds(true));\n        \n        // this replaces the entry with the current minimum value, but the new\n        // minimum value is now in a different item\n        d1.add(new BoxAndWhiskerItem(1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 8.6, 9.6, \n                new ArrayList()), \"R1\", \"C1\");\n        assertEquals(new Range(8.5, 9.6), d1.getRangeBounds(false));\n        assertEquals(new Range(8.5, 9.6), d1.getRangeBounds(true));\n    }\n"], "Closure_24": ["  public void testNonAliasLocal() {\n    testScopedFailure(\"var x = 10\", ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n    testScopedFailure(\"var x = goog.dom + 10\",\n        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n    testScopedFailure(\"var x = goog['dom']\",\n        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n    testScopedFailure(\"var x = goog.dom, y = 10\",\n        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n    testScopedFailure(\"function f() {}\",\n        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n  }\n"], "Chart_19": ["    public void testGetDomainAxisIndex() {\n        CategoryAxis domainAxis1 = new CategoryAxis(\"X1\");\n        CategoryAxis domainAxis2 = new CategoryAxis(\"X2\");\n        NumberAxis rangeAxis1 = new NumberAxis(\"Y1\");\n        CategoryPlot plot = new CategoryPlot(null, domainAxis1, rangeAxis1, \n                null);\n        assertEquals(0, plot.getDomainAxisIndex(domainAxis1));\n        assertEquals(-1, plot.getDomainAxisIndex(domainAxis2));\n        plot.setDomainAxis(1, domainAxis2);\n        assertEquals(1, plot.getDomainAxisIndex(domainAxis2));\n        assertEquals(-1, plot.getDomainAxisIndex(new CategoryAxis(\"X2\")));\n        boolean pass = false;\n        try {\n            plot.getDomainAxisIndex(null);\n        }\n        catch (IllegalArgumentException e) {\n            pass = true;\n        }\n        assertTrue(pass);\n    }\n", "    public void testGetRangeAxisIndex() {\n        CategoryAxis domainAxis1 = new CategoryAxis(\"X1\");\n        NumberAxis rangeAxis1 = new NumberAxis(\"Y1\");\n        NumberAxis rangeAxis2 = new NumberAxis(\"Y2\");\n        CategoryPlot plot = new CategoryPlot(null, domainAxis1, rangeAxis1, \n                null);\n        assertEquals(0, plot.getRangeAxisIndex(rangeAxis1));\n        assertEquals(-1, plot.getRangeAxisIndex(rangeAxis2));\n        plot.setRangeAxis(1, rangeAxis2);\n        assertEquals(1, plot.getRangeAxisIndex(rangeAxis2));\n        assertEquals(-1, plot.getRangeAxisIndex(new NumberAxis(\"Y2\")));\n        boolean pass = false;\n        try {\n            plot.getRangeAxisIndex(null);\n        }\n        catch (IllegalArgumentException e) {\n            pass = true;\n        }\n        assertTrue(pass);\n    }\n"], "Closure_23": ["  public void testFoldGetElem() {\n    fold(\"x = [,10][0]\", \"x = void 0\");\n    fold(\"x = [10, 20][0]\", \"x = 10\");\n    fold(\"x = [10, 20][1]\", \"x = 20\");\n    fold(\"x = [10, 20][0.5]\", \"\",\n        PeepholeFoldConstants.INVALID_GETELEM_INDEX_ERROR);\n    fold(\"x = [10, 20][-1]\",    \"\",\n        PeepholeFoldConstants.INDEX_OUT_OF_BOUNDS_ERROR);\n    fold(\"x = [10, 20][2]\",     \"\",\n        PeepholeFoldConstants.INDEX_OUT_OF_BOUNDS_ERROR);\n\n    foldSame(\"x = [foo(), 0][1]\");\n    fold(\"x = [0, foo()][1]\", \"x = foo()\");\n    foldSame(\"x = [0, foo()][0]\");\n  }\n"], "Chart_26": ["    public void testDrawWithNullInfo() {\n        boolean success = false;\n        try {\n            BufferedImage image = new BufferedImage(200 , 100, \n                    BufferedImage.TYPE_INT_RGB);\n            Graphics2D g2 = image.createGraphics();\n            this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, \n                    null);\n            g2.dispose();\n            success = true;\n        }\n        catch (Exception e) {\n            success = false;\n        }\n        assertTrue(success);\n    }\n", "    public void testDrawWithNullInfo() {\n        boolean success = false;\n        try {\n            BufferedImage image = new BufferedImage(200 , 100, \n                    BufferedImage.TYPE_INT_RGB);\n            Graphics2D g2 = image.createGraphics();\n            this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, \n                    null);\n            g2.dispose();\n            success = true;\n        }\n        catch (Exception e) {\n            success = false;\n        }\n        assertTrue(success);\n    }\n", "    public void testDrawWithNullInfo() {\n\n        boolean success = false;\n\n        try {\n            BufferedImage image = new BufferedImage(200 , 100, \n                    BufferedImage.TYPE_INT_RGB);\n            Graphics2D g2 = image.createGraphics();\n            this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, \n                    null);\n            g2.dispose();\n            success = true;\n        }\n        catch (Exception e) {\n            success = false;\n        }\n\n        assertTrue(success);\n\n    }\n", "    public void testDrawWithNullInfo() {\n        boolean success = false;\n        try {\n            BufferedImage image = new BufferedImage(200 , 100, \n                    BufferedImage.TYPE_INT_RGB);\n            Graphics2D g2 = image.createGraphics();\n            this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, \n                    null);\n            g2.dispose();\n            success = true;\n        }\n        catch (Exception e) {\n            success = false;\n        }\n        assertTrue(success);\n    }\n", "    public void testDrawWithNullInfo2() {\n        boolean success = false;\n        try {\n            JFreeChart chart = createGanttChart();\n            CategoryPlot plot = (CategoryPlot) chart.getPlot();\n            plot.setDataset(createDataset());\n            /* BufferedImage img =*/ chart.createBufferedImage(300, 200, null);\n            success = true;\n        }\n        catch (NullPointerException e) {\n            success = false;\n        }\n        assertTrue(success);\n    }\n", "    public void testDrawWithNullInfo() {\n\n        boolean success = false;\n        try {\n            BufferedImage image = new BufferedImage(200 , 100, \n                    BufferedImage.TYPE_INT_RGB);\n            Graphics2D g2 = image.createGraphics();\n            this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, \n                    null);\n            g2.dispose();\n            success = true;\n        }\n        catch (Exception e) {\n            success = false;\n        }\n        assertTrue(success);\n\n    }\n", "    public void testDrawWithNullInfo() {\n\n        boolean success = false;\n        try {\n            BufferedImage image = new BufferedImage(200 , 100, \n                    BufferedImage.TYPE_INT_RGB);\n            Graphics2D g2 = image.createGraphics();\n            this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, \n                    null);\n            g2.dispose();\n            success = true;\n        }\n        catch (Exception e) {\n            success = false;\n        }\n        assertTrue(success);\n\n    }\n", "    public void testDrawWithNullInfo() {\n\n        boolean success = false;\n        try {\n            BufferedImage image = new BufferedImage(200 , 100, \n                    BufferedImage.TYPE_INT_RGB);\n            Graphics2D g2 = image.createGraphics();\n            this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, \n                    null);\n            g2.dispose();\n            success = true;\n        }\n        catch (Exception e) {\n          success = false;\n        }\n        assertTrue(success);\n\n    }\n", "    public void testDrawWithNullInfo() {\n\n        boolean success = false;\n        try {\n            BufferedImage image = new BufferedImage(200 , 100, \n                    BufferedImage.TYPE_INT_RGB);\n            Graphics2D g2 = image.createGraphics();\n            this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null,\n                    null);\n            g2.dispose();\n            success = true;\n        }\n        catch (Exception e) {\n          success = false;\n        }\n        assertTrue(success);\n\n    }\n", "    public void testDrawWithNullInfo() {\n\n        boolean success = false;\n\n        try {\n            BufferedImage image = new BufferedImage(200 , 100, \n                    BufferedImage.TYPE_INT_RGB);\n            Graphics2D g2 = image.createGraphics();\n            this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, \n                    null);\n            g2.dispose();\n            success = true;\n        }\n        catch (Exception e) {\n          success = false;\n        }\n\n        assertTrue(success);\n\n    }\n", "    public void testDrawWithNullInfo() {\n\n        boolean success = false;\n\n        try {\n            BufferedImage image = new BufferedImage(200 , 100, \n                    BufferedImage.TYPE_INT_RGB);\n            Graphics2D g2 = image.createGraphics();\n            this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, \n                    null);\n            g2.dispose();\n            success = true;\n        }\n        catch (Exception e) {\n            success = false;\n        }\n\n        assertTrue(success);\n\n    }\n", "    public void testSerialization3() {\n        DefaultCategoryDataset dataset = new DefaultCategoryDataset();\n        JFreeChart chart = ChartFactory.createBarChart(\n            \"Test Chart\",\n            \"Category Axis\",\n            \"Value Axis\",\n            dataset,\n            PlotOrientation.VERTICAL,\n            true,\n            true,\n            false\n        );\n        JFreeChart chart2 = null;\n        \n        // serialize and deserialize the chart....\n        try {\n            ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n            ObjectOutput out = new ObjectOutputStream(buffer);\n            out.writeObject(chart);\n            out.close();\n\n            ObjectInput in = new ObjectInputStream(\n                    new ByteArrayInputStream(buffer.toByteArray()));\n            chart2 = (JFreeChart) in.readObject();\n            in.close();\n        }\n        catch (Exception e) {\n            fail(e.toString());\n        }\n\n        // now check that the chart is usable...\n        boolean passed = true;\n        try {\n            chart2.createBufferedImage(300, 200);\n        }\n        catch (Exception e) {\n            passed = false;  \n            e.printStackTrace();            \n        }\n        assertTrue(passed);\n    }\n", "    public void testSerialization4() {\n        DefaultCategoryDataset dataset = new DefaultCategoryDataset();\n        JFreeChart chart = ChartFactory.createBarChart(\n            \"Test Chart\",\n            \"Category Axis\",\n            \"Value Axis\",\n            dataset,\n            PlotOrientation.VERTICAL,\n            true,\n            true,\n            false\n        );\n        CategoryPlot plot = (CategoryPlot) chart.getPlot();\n        plot.addRangeMarker(new ValueMarker(1.1), Layer.FOREGROUND);\n        plot.addRangeMarker(new IntervalMarker(2.2, 3.3), Layer.BACKGROUND);\n        JFreeChart chart2 = null;\n        \n        // serialize and deserialize the chart....\n        try {\n            ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n            ObjectOutput out = new ObjectOutputStream(buffer);\n            out.writeObject(chart);\n            out.close();\n\n            ObjectInput in = new ObjectInputStream(\n                    new ByteArrayInputStream(buffer.toByteArray()));\n            chart2 = (JFreeChart) in.readObject();\n            in.close();\n        }\n        catch (Exception e) {\n            fail(e.toString());\n        }\n        assertEquals(chart, chart2);\n        \n        // now check that the chart is usable...\n        boolean passed = true;\n        try {\n            chart2.createBufferedImage(300, 200);\n        }\n        catch (Exception e) {\n            passed = false;  \n            e.printStackTrace();            \n        }\n        assertTrue(passed);\n    }\n", "    public void test1654215() {\n        DefaultCategoryDataset dataset = new DefaultCategoryDataset();\n        JFreeChart chart = ChartFactory.createLineChart(\"Title\", \"X\", \"Y\",\n                dataset, PlotOrientation.VERTICAL, true, false, false);\n        CategoryPlot plot = (CategoryPlot) chart.getPlot();\n        plot.setRenderer(1, new LineAndShapeRenderer());\n        boolean success = false;\n        try {\n            BufferedImage image = new BufferedImage(200 , 100, \n                    BufferedImage.TYPE_INT_RGB);\n            Graphics2D g2 = image.createGraphics();\n            chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, null);\n            g2.dispose();\n            success = true;\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n            success = false;\n        }\n        assertTrue(success);\n    }\n", "    public void testDrawWithNullInfo() {\n        boolean success = false;\n        try {\n            DefaultBoxAndWhiskerCategoryDataset dataset \n                = new DefaultBoxAndWhiskerCategoryDataset();\n            dataset.add(new BoxAndWhiskerItem(new Double(1.0), new Double(2.0),\n                    new Double(0.0), new Double(4.0), new Double(0.5), \n                    new Double(4.5), new Double(-0.5), new Double(5.5), \n                    null), \"S1\", \"C1\");\n            CategoryPlot plot = new CategoryPlot(dataset, \n                    new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), \n                    new BoxAndWhiskerRenderer());\n            JFreeChart chart = new JFreeChart(plot);\n            /* BufferedImage image = */ chart.createBufferedImage(300, 200, \n                    null);\n            success = true;\n        }\n        catch (NullPointerException e) {\n            success = false;\n        }\n        assertTrue(success);\n    }\n", "    public void testDrawWithNullInfo() {\n        boolean success = false;\n        try {\n            DefaultCategoryDataset dataset = new DefaultCategoryDataset();\n            dataset.addValue(1.0, \"S1\", \"C1\");\n            dataset.addValue(2.0, \"S1\", \"C2\");\n            dataset.addValue(3.0, \"S2\", \"C1\");\n            dataset.addValue(4.0, \"S2\", \"C2\");\n            GroupedStackedBarRenderer renderer \n                = new GroupedStackedBarRenderer();\n            CategoryPlot plot = new CategoryPlot(dataset, \n                    new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), \n                    renderer);\n            JFreeChart chart = new JFreeChart(plot);\n            /* BufferedImage image = */ chart.createBufferedImage(300, 200, \n                    null);\n            success = true;\n        }\n        catch (NullPointerException e) {\n            e.printStackTrace();\n            success = false;\n        }\n        assertTrue(success);\n    }\n", "    public void testDrawWithNullInfo() {\n        boolean success = false;\n        try {\n            double[][] starts = new double[][] {{0.1, 0.2, 0.3}, \n                    {0.3, 0.4, 0.5}};\n            double[][] ends = new double[][] {{0.5, 0.6, 0.7}, {0.7, 0.8, 0.9}};\n            DefaultIntervalCategoryDataset dataset \n                = new DefaultIntervalCategoryDataset(starts, ends);        \n            IntervalBarRenderer renderer = new IntervalBarRenderer();\n            CategoryPlot plot = new CategoryPlot(dataset, \n                    new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), \n                    renderer);\n            JFreeChart chart = new JFreeChart(plot);\n            /* BufferedImage image = */ chart.createBufferedImage(300, 200, \n                    null);\n            success = true;\n        }\n        catch (NullPointerException e) {\n            e.printStackTrace();\n            success = false;\n        }\n        assertTrue(success);\n    }\n", "    public void testDrawWithNullInfo() {\n        boolean success = false;\n        try {\n            DefaultCategoryDataset dataset = new DefaultCategoryDataset();\n            dataset.addValue(1.0, \"S1\", \"C1\");\n            CategoryPlot plot = new CategoryPlot(dataset, \n                    new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), \n                    new LayeredBarRenderer());\n            JFreeChart chart = new JFreeChart(plot);\n            /* BufferedImage image = */ chart.createBufferedImage(300, 200, \n                    null);\n            success = true;\n        }\n        catch (NullPointerException e) {\n            e.printStackTrace();\n            success = false;\n        }\n        assertTrue(success);\n    }\n", "    public void testDrawWithNullInfo() {\n        boolean success = false;\n        try {\n            DefaultCategoryDataset dataset = new DefaultCategoryDataset();\n            dataset.addValue(1.0, \"S1\", \"C1\");\n            CategoryPlot plot = new CategoryPlot(dataset, \n                    new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), \n                    new LevelRenderer());\n            JFreeChart chart = new JFreeChart(plot);\n            /* BufferedImage image = */ chart.createBufferedImage(300, 200, \n                    null);\n            success = true;\n        }\n        catch (NullPointerException e) {\n            e.printStackTrace();\n            success = false;\n        }\n        assertTrue(success);\n    }\n", "    public void testDrawWithNullInfo() {\n        boolean success = false;\n        try {\n            DefaultCategoryDataset dataset = new DefaultCategoryDataset();\n            dataset.addValue(1.0, \"S1\", \"C1\");\n            CategoryPlot plot = new CategoryPlot(dataset, \n                    new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), \n                    new MinMaxCategoryRenderer());\n            JFreeChart chart = new JFreeChart(plot);\n            /* BufferedImage image = */ chart.createBufferedImage(300, 200, \n                    null);\n            success = true;\n        }\n        catch (NullPointerException e) {\n            e.printStackTrace();\n            success = false;\n        }\n        assertTrue(success);\n    }\n", "    public void testDrawWithNullInfo() {\n        boolean success = false;\n        try {\n            DefaultStatisticalCategoryDataset dataset \n                = new DefaultStatisticalCategoryDataset();\n            dataset.add(1.0, 2.0, \"S1\", \"C1\");\n            dataset.add(3.0, 4.0, \"S1\", \"C2\");\n            CategoryPlot plot = new CategoryPlot(dataset, \n                    new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), \n                    new StatisticalBarRenderer());\n            JFreeChart chart = new JFreeChart(plot);\n            /* BufferedImage image = */ chart.createBufferedImage(300, 200, \n                    null);\n            success = true;\n        }\n        catch (NullPointerException e) {\n            e.printStackTrace();\n            success = false;\n        }\n        assertTrue(success);\n    }\n", "    public void testDrawWithNullInfo() {\n        boolean success = false;\n        try {\n            DefaultStatisticalCategoryDataset dataset \n                = new DefaultStatisticalCategoryDataset();\n            dataset.add(1.0, 2.0, \"S1\", \"C1\");\n            dataset.add(3.0, 4.0, \"S1\", \"C2\");\n            CategoryPlot plot = new CategoryPlot(dataset, \n                    new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), \n                    new StatisticalLineAndShapeRenderer());\n            JFreeChart chart = new JFreeChart(plot);\n            /* BufferedImage image = */ chart.createBufferedImage(300, 200, \n                    null);\n            success = true;\n        }\n        catch (NullPointerException e) {\n            e.printStackTrace();\n            success = false;\n        }\n        assertTrue(success);\n    }\n"], "Time_4": ["    public void testWith3() {\n        Partial test = createHourMinPartial();\n        try {\n            test.with(DateTimeFieldType.clockhourOfDay(), 6);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        check(test, 10, 20);\n    }\n", "    public void testWith3a() {\n        Partial test = createHourMinPartial();\n        Partial result = test.with(DateTimeFieldType.secondOfMinute(), 15);\n        check(test, 10, 20);\n        assertEquals(3, result.size());\n        assertEquals(true, result.isSupported(DateTimeFieldType.hourOfDay()));\n        assertEquals(true, result.isSupported(DateTimeFieldType.minuteOfHour()));\n        assertEquals(true, result.isSupported(DateTimeFieldType.secondOfMinute()));\n        assertEquals(DateTimeFieldType.hourOfDay(), result.getFieldType(0));\n        assertEquals(DateTimeFieldType.minuteOfHour(), result.getFieldType(1));\n        assertEquals(DateTimeFieldType.secondOfMinute(), result.getFieldType(2));\n        assertEquals(10, result.get(DateTimeFieldType.hourOfDay()));\n        assertEquals(20, result.get(DateTimeFieldType.minuteOfHour()));\n        assertEquals(15, result.get(DateTimeFieldType.secondOfMinute()));\n    }\n", "    public void testWith3b() {\n        Partial test = createHourMinPartial();\n        Partial result = test.with(DateTimeFieldType.minuteOfDay(), 15);\n        check(test, 10, 20);\n        assertEquals(3, result.size());\n        assertEquals(true, result.isSupported(DateTimeFieldType.hourOfDay()));\n        assertEquals(true, result.isSupported(DateTimeFieldType.minuteOfDay()));\n        assertEquals(true, result.isSupported(DateTimeFieldType.minuteOfHour()));\n        assertEquals(DateTimeFieldType.hourOfDay(), result.getFieldType(0));\n        assertEquals(DateTimeFieldType.minuteOfDay(), result.getFieldType(1));\n        assertEquals(DateTimeFieldType.minuteOfHour(), result.getFieldType(2));\n        assertEquals(10, result.get(DateTimeFieldType.hourOfDay()));\n        assertEquals(20, result.get(DateTimeFieldType.minuteOfHour()));\n        assertEquals(15, result.get(DateTimeFieldType.minuteOfDay()));\n    }\n", "    public void testWith3c() {\n        Partial test = createHourMinPartial();\n        Partial result = test.with(DateTimeFieldType.dayOfMonth(), 15);\n        check(test, 10, 20);\n        assertEquals(3, result.size());\n        assertEquals(true, result.isSupported(DateTimeFieldType.dayOfMonth()));\n        assertEquals(true, result.isSupported(DateTimeFieldType.hourOfDay()));\n        assertEquals(true, result.isSupported(DateTimeFieldType.minuteOfHour()));\n        assertEquals(DateTimeFieldType.dayOfMonth(), result.getFieldType(0));\n        assertEquals(DateTimeFieldType.hourOfDay(), result.getFieldType(1));\n        assertEquals(DateTimeFieldType.minuteOfHour(), result.getFieldType(2));\n        assertEquals(10, result.get(DateTimeFieldType.hourOfDay()));\n        assertEquals(20, result.get(DateTimeFieldType.minuteOfHour()));\n        assertEquals(15, result.get(DateTimeFieldType.dayOfMonth()));\n    }\n", "    public void testWith3d() {\n        Partial test = new Partial(DateTimeFieldType.year(), 2005);\n        Partial result = test.with(DateTimeFieldType.monthOfYear(), 6);\n        assertEquals(2, result.size());\n        assertEquals(2005, result.get(DateTimeFieldType.year()));\n        assertEquals(6, result.get(DateTimeFieldType.monthOfYear()));\n    }        \n", "    public void testWith3e() {\n        Partial test = new Partial(DateTimeFieldType.era(), 1);\n        Partial result = test.with(DateTimeFieldType.halfdayOfDay(), 0);\n        assertEquals(2, result.size());\n        assertEquals(1, result.get(DateTimeFieldType.era()));\n        assertEquals(0, result.get(DateTimeFieldType.halfdayOfDay()));\n        assertEquals(0, result.indexOf(DateTimeFieldType.era()));\n        assertEquals(1, result.indexOf(DateTimeFieldType.halfdayOfDay()));\n    }        \n", "    public void testWith3f() {\n        Partial test = new Partial(DateTimeFieldType.halfdayOfDay(), 0);\n        Partial result = test.with(DateTimeFieldType.era(), 1);\n        assertEquals(2, result.size());\n        assertEquals(1, result.get(DateTimeFieldType.era()));\n        assertEquals(0, result.get(DateTimeFieldType.halfdayOfDay()));\n        assertEquals(0, result.indexOf(DateTimeFieldType.era()));\n        assertEquals(1, result.indexOf(DateTimeFieldType.halfdayOfDay()));\n    }        \n"], "Closure_77": ["  public void testZero() {\n    assertPrint(\"var x ='\\\\0';\", \"var x=\\\"\\\\0\\\"\");\n    assertPrint(\"var x ='\\\\x00';\", \"var x=\\\"\\\\0\\\"\");\n    assertPrint(\"var x ='\\\\u0000';\", \"var x=\\\"\\\\0\\\"\");\n  }\n"], "Closure_83": ["  public void testVersionFlag2() {\n    lastArg = \"--version\";\n    testSame(\"\");\n    assertEquals(\n        0,\n        new String(errReader.toByteArray()).indexOf(\n            \"Closure Compiler (http://code.google.com/closure/compiler)\\n\" +\n            \"Version: \"));\n  }\n"], "Closure_104": ["  public void testGreatestSubtypeUnionTypes5() throws Exception {\n    JSType errUnion = createUnionType(EVAL_ERROR_TYPE, URI_ERROR_TYPE);\n    assertEquals(NO_OBJECT_TYPE,\n        errUnion.getGreatestSubtype(STRING_OBJECT_TYPE));\n  }\n"], "Closure_48": ["  public void testIssue586() throws Exception {\n    testTypes(\n        \"/** @constructor */\" +\n        \"var MyClass = function() {};\" +\n        \"/** @param {boolean} success */\" +\n        \"MyClass.prototype.fn = function(success) {};\" +\n        \"MyClass.prototype.test = function() {\" +\n        \"  this.fn();\" +\n        \"  this.fn = function() {};\" +\n        \"};\",\n        \"Function MyClass.prototype.fn: called with 0 argument(s). \" +\n        \"Function requires at least 1 argument(s) \" +\n        \"and no more than 1 argument(s).\");\n  }\n"], "Closure_84": ["  public void testDestructuringAssignForbidden4() {\n    parseError(\"[x, y] = foo();\",\n        \"destructuring assignment forbidden\",\n        \"invalid assignment target\");\n  }\n"], "Closure_103": ["  public void testInstanceOfThrowsException() {\n    testSame(\"function f() {try { if (value instanceof type) return true; } \" +\n             \"catch (e) { }}\");\n  }\n", "  public void testInstanceOf() {\n    String src = \"try { x instanceof 'x' } catch (e) { }\";\n    ControlFlowGraph<Node> cfg = createCfg(src, true);\n    assertCrossEdge(cfg, Token.EXPR_RESULT, Token.BLOCK, Branch.ON_EX);\n  }\n", "  public void testSupertypeReferenceOfSubtypeProperty() {\n    String externs = \"\"\n        + \"/** @constructor */ function Ext() {}\"\n        + \"Ext.prototype.a;\";\n    String js = \"\"\n        + \"/** @constructor */ function Foo() {}\\n\"\n        + \"/** @constructor \\n@extends Foo*/ function Bar() {}\\n\"\n        + \"Bar.prototype.a;\\n\"\n        + \"/** @param {Foo} foo */\"\n        + \"function foo(foo) {\\n\"\n        + \"  var x = foo.a;\\n\"\n        + \"}\\n\";\n    String result = \"\"\n        + \"function Foo() {}\\n\"\n        + \"function Bar() {}\\n\"\n        + \"Bar.prototype.Bar_prototype$a;\\n\"\n        + \"function foo(foo) {\\n\"\n        + \"  var x = foo.Bar_prototype$a;\\n\"\n        + \"}\\n\";\n    testSets(false, externs, js, result, \"{a=[[Bar.prototype]]}\");\n  }\n"], "Closure_70": ["  public void testFunctionArguments13() throws Exception {\n    // verifying that the argument type have non-inferrable types\n    testTypes(\n        \"/** @return {boolean} */ function u() { return true; }\" +\n        \"/** @param {boolean} b\\n@return {?boolean} */\" +\n        \"function f(b) { if (u()) { b = null; } return b; }\",\n        \"assignment\\n\" +\n        \"found   : null\\n\" +\n        \"required: boolean\");\n  }\n", "  public void testDuplicateLocalVarDecl() throws Exception {\n    testClosureTypesMultipleWarnings(\n        \"/** @param {number} x */\\n\" +\n        \"function f(x) { /** @type {string} */ var x = ''; }\",\n        Lists.newArrayList(\n            \"variable x redefined with type string, original definition\" +\n            \" at  [testcode] :2 with type number\",\n            \"initializing variable\\n\" +\n            \"found   : string\\n\" +\n            \"required: number\"));\n  }\n", "  public void testScoping12() throws Exception {\n    testTypes(\n        \"/** @constructor */ function F() {}\" +\n        \"/** @type {number} */ F.prototype.bar = 3;\" +\n        \"/** @param {!F} f */ function g(f) {\" +\n        \"  /** @return {string} */\" +\n        \"  function h() {\" +\n        \"    return f.bar;\" +\n        \"  }\" +\n        \"}\",\n        \"inconsistent return type\\n\" +\n        \"found   : number\\n\" +\n        \"required: string\");\n  }\n", "  public void testFunctionArguments13() throws Exception {\n    // verifying that the argument type have non-inferrable types\n    testTypes(\n        \"/** @return {boolean} */ function u() { return true; }\" +\n        \"/** @param {boolean} b\\n@return {?boolean} */\" +\n        \"function f(b) { if (u()) { b = null; } return b; }\",\n        \"assignment\\n\" +\n        \"found   : null\\n\" +\n        \"required: boolean\");\n  }\n", "  public void testDuplicateLocalVarDecl() throws Exception {\n    testClosureTypesMultipleWarnings(\n        \"/** @param {number} x */\\n\" +\n        \"function f(x) { /** @type {string} */ var x = ''; }\",\n        Lists.newArrayList(\n            \"variable x redefined with type string, original definition\" +\n            \" at  [testcode] :2 with type number\",\n            \"initializing variable\\n\" +\n            \"found   : string\\n\" +\n            \"required: number\"));\n  }\n"], "Time_3": ["    public void testAdd_DurationFieldType_int_dstOverlapWinter_addZero() {\n        MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID(\"Europe/Berlin\"));\n        test.addHours(1);\n        assertEquals(\"2011-10-30T02:30:00.000+01:00\", test.toString());\n        test.add(DurationFieldType.years(), 0);\n        assertEquals(\"2011-10-30T02:30:00.000+01:00\", test.toString());\n    }\n", "    public void testAddYears_int_dstOverlapWinter_addZero() {\n        MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID(\"Europe/Berlin\"));\n        test.addHours(1);\n        assertEquals(\"2011-10-30T02:30:00.000+01:00\", test.toString());\n        test.addYears(0);\n        assertEquals(\"2011-10-30T02:30:00.000+01:00\", test.toString());\n    }\n", "    public void testAddMonths_int_dstOverlapWinter_addZero() {\n        MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID(\"Europe/Berlin\"));\n        test.addHours(1);\n        assertEquals(\"2011-10-30T02:30:00.000+01:00\", test.toString());\n        test.addMonths(0);\n        assertEquals(\"2011-10-30T02:30:00.000+01:00\", test.toString());\n    }\n", "    public void testAddDays_int_dstOverlapWinter_addZero() {\n        MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID(\"Europe/Berlin\"));\n        test.addHours(1);\n        assertEquals(\"2011-10-30T02:30:00.000+01:00\", test.toString());\n        test.addDays(0);\n        assertEquals(\"2011-10-30T02:30:00.000+01:00\", test.toString());\n    }\n", "    public void testAddWeeks_int_dstOverlapWinter_addZero() {\n        MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID(\"Europe/Berlin\"));\n        test.addHours(1);\n        assertEquals(\"2011-10-30T02:30:00.000+01:00\", test.toString());\n        test.addWeeks(0);\n        assertEquals(\"2011-10-30T02:30:00.000+01:00\", test.toString());\n    }\n"], "Closure_46": ["  public void testRecordTypeLeastSuperType2() {\n    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n    builder.addProperty(\"e\", NUMBER_TYPE, null);\n    builder.addProperty(\"b\", STRING_TYPE, null);\n    builder.addProperty(\"c\", STRING_TYPE, null);\n    JSType otherRecordType = builder.build();\n\n    assertTypeEquals(\n        registry.createUnionType(recordType, otherRecordType),\n        recordType.getLeastSupertype(otherRecordType));\n  }\n", "  public void testRecordTypeLeastSuperType3() {\n    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n    builder.addProperty(\"d\", NUMBER_TYPE, null);\n    builder.addProperty(\"e\", STRING_TYPE, null);\n    builder.addProperty(\"f\", STRING_TYPE, null);\n    JSType otherRecordType = builder.build();\n\n    assertTypeEquals(\n        registry.createUnionType(recordType, otherRecordType),\n        recordType.getLeastSupertype(otherRecordType));\n  }\n", "  public void testSupAndInf() {\n    JSType recordA = new RecordTypeBuilder(registry)\n        .addProperty(\"a\", NUMBER_TYPE, null)\n        .addProperty(\"b\", NUMBER_TYPE, null)\n        .build();\n    JSType recordC = new RecordTypeBuilder(registry)\n        .addProperty(\"b\", NUMBER_TYPE, null)\n        .addProperty(\"c\", NUMBER_TYPE, null)\n        .build();\n    ProxyObjectType proxyRecordA = new ProxyObjectType(registry, recordA);\n    ProxyObjectType proxyRecordC = new ProxyObjectType(registry, recordC);\n\n    JSType aInfC = new RecordTypeBuilder(registry)\n        .addProperty(\"a\", NUMBER_TYPE, null)\n        .addProperty(\"b\", NUMBER_TYPE, null)\n        .addProperty(\"c\", NUMBER_TYPE, null)\n        .build();\n\n    JSType aSupC = registry.createUnionType(recordA, recordC);\n\n    Asserts.assertTypeEquals(\n        aInfC, recordA.getGreatestSubtype(recordC));\n    Asserts.assertTypeEquals(\n        aSupC, recordA.getLeastSupertype(recordC));\n\n    Asserts.assertTypeEquals(\n        aInfC, proxyRecordA.getGreatestSubtype(proxyRecordC));\n    Asserts.assertTypeEquals(\n        aSupC, proxyRecordA.getLeastSupertype(proxyRecordC));\n  }\n"], "Lang_33": ["    public void testToClass_object() {\n        assertNull(ClassUtils.toClass(null));\n\n        assertSame(ArrayUtils.EMPTY_CLASS_ARRAY, ClassUtils.toClass(ArrayUtils.EMPTY_OBJECT_ARRAY));\n\n        assertTrue(Arrays.equals(new Class[] { String.class, Integer.class, Double.class },\n                ClassUtils.toClass(new Object[] { \"Test\", 1, 99d })));\n\n        assertTrue(Arrays.equals(new Class[] { String.class, null, Double.class },\n                ClassUtils.toClass(new Object[] { \"Test\", null, 99d })));\n    }\n"], "Closure_79": ["  public void testIssue166a() {\n    test(\"try { throw 1 } catch(e) { /** @suppress {duplicate} */ var e=2 }\",\n         \"try { throw 1 } catch(e) { var e=2 }\",\n         Normalize.CATCH_BLOCK_VAR_ERROR);\n  }\n", "  public void testIssue166b() {\n    test(\"function a() {\" +\n         \"try { throw 1 } catch(e) { /** @suppress {duplicate} */ var e=2 }\" +\n         \"};\",\n         \"function a() {\" +\n         \"try { throw 1 } catch(e) { var e=2 }\" +\n         \"}\",\n         Normalize.CATCH_BLOCK_VAR_ERROR);\n  }\n", "  public void testIssue166c() {\n    test(\"var e = 0; try { throw 1 } catch(e) {\" +\n             \"/** @suppress {duplicate} */ var e=2 }\",\n         \"var e = 0; try { throw 1 } catch(e) { var e=2 }\",\n         Normalize.CATCH_BLOCK_VAR_ERROR);\n  }\n", "  public void testIssue166d() {\n    test(\"function a() {\" +\n         \"var e = 0; try { throw 1 } catch(e) {\" +\n             \"/** @suppress {duplicate} */ var e=2 }\" +\n         \"};\",\n         \"function a() {\" +\n         \"var e = 0; try { throw 1 } catch(e) { var e=2 }\" +\n         \"}\",\n         Normalize.CATCH_BLOCK_VAR_ERROR);\n  }\n", "  public void testIssue166e() {\n    test(\"var e = 2; try { throw 1 } catch(e) {}\",\n         \"var e = 2; try { throw 1 } catch(e$$1) {}\");\n  }\n", "  public void testIssue166f() {\n    test(\"function a() {\" +\n         \"var e = 2; try { throw 1 } catch(e) {}\" +\n         \"}\",\n         \"function a() {\" +\n         \"var e = 2; try { throw 1 } catch(e$$1) {}\" +\n         \"}\");\n  }\n", "  public void testIssue() {\n    super.allowExternsChanges(true);\n    test(\"var a,b,c; var a,b\", \"a(), b()\", \"a(), b()\", null, null);\n  }\n", "  public void testVarReferenceInExterns() {\n    testSame(\"asdf;\", \"var asdf;\",\n        VarCheck.NAME_REFERENCE_IN_EXTERNS_ERROR);\n  }\n", "  public void testCallInExterns() {\n    testSame(\"yz();\", \"function yz() {}\",\n        VarCheck.NAME_REFERENCE_IN_EXTERNS_ERROR);\n  }\n", "  public void testPropReferenceInExterns1() {\n    testSame(\"asdf.foo;\", \"var asdf;\",\n        VarCheck.UNDEFINED_EXTERN_VAR_ERROR);\n  }\n", "  public void testPropReferenceInExterns3() {\n    testSame(\"asdf.foo;\", \"var asdf;\",\n        VarCheck.UNDEFINED_EXTERN_VAR_ERROR);\n\n    externValidationErrorLevel = CheckLevel.ERROR;\n    test(\n        \"asdf.foo;\", \"var asdf;\", \"\",\n         VarCheck.UNDEFINED_EXTERN_VAR_ERROR, null);\n\n    externValidationErrorLevel = CheckLevel.OFF;\n    test(\"asdf.foo;\", \"var asdf;\", \"var asdf;\", null, null);\n  }\n"], "Closure_41": ["  public void testMethodInference6() throws Exception {\n    testTypes(\n        \"/** @constructor */ function F() {}\" +\n        \"/** @param {number} x */ F.prototype.foo = function(x) { };\" +\n        \"/** @constructor \\n * @extends {F} */ \" +\n        \"function G() {}\" +\n        \"/** @override */ G.prototype.foo = function() { };\" +\n        \"(new G()).foo(1);\");\n  }\n", "  public void testMethodInference6() throws Exception {\n    testTypes(\n        \"/** @constructor */ function F() {}\" +\n        \"/** @param {number} x */ F.prototype.foo = function(x) { };\" +\n        \"/** @constructor \\n * @extends {F} */ \" +\n        \"function G() {}\" +\n        \"/** @override */ G.prototype.foo = function() { };\" +\n        \"(new G()).foo(1);\");\n  }\n", "  public void testIssue368() throws Exception {\n    testTypes(\n        \"/** @constructor */ function Foo(){}\" +\n        \"/**\\n\" +\n        \" * @param {number} one\\n\" +\n        \" * @param {string} two\\n\" +\n        \" */\\n\" +\n        \"Foo.prototype.add = function(one, two) {};\" +\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" * @extends {Foo}\\n\" +\n        \" */\\n\" +\n        \"function Bar(){}\" +\n        \"/** @override */\\n\" +\n        \"Bar.prototype.add = function(ignored) {};\" +\n        \"(new Bar()).add(1, 2);\",\n        \"actual parameter 2 of Bar.prototype.add does not match formal parameter\\n\" +\n        \"found   : number\\n\" +\n        \"required: string\");\n  }\n"], "Closure_132": ["  public void testIssue925() {\n    test(\n        \"if (x[--y] === 1) {\\n\" +\n        \"    x[y] = 0;\\n\" +\n        \"} else {\\n\" +\n        \"    x[y] = 1;\\n\" +\n        \"}\",\n        \"(x[--y] === 1) ? x[y] = 0 : x[y] = 1;\");\n\n    test(\n        \"if (x[--y]) {\\n\" +\n        \"    a = 0;\\n\" +\n        \"} else {\\n\" +\n        \"    a = 1;\\n\" +\n        \"}\",\n        \"a = (x[--y]) ? 0 : 1;\");\n\n    test(\"if (x++) { x += 2 } else { x += 3 }\",\n         \"x++ ? x += 2 : x += 3\");\n\n    test(\"if (x++) { x = x + 2 } else { x = x + 3 }\",\n        \"x = x++ ? x + 2 : x + 3\");\n  }\n"], "Lang_34": ["    public void testReflectionObjectArray() {\n        Object[] array = new Object[] { null, base, new int[] { 3, 6 } };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{<null>,5,{3,6}}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }\n", "    public void testReflectionLongArray() {\n        long[] array = new long[] { 1, 2, -3, 4 };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }\n", "    public void testReflectionIntArray() {\n        int[] array = new int[] { 1, 2, -3, 4 };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }\n", "    public void testReflectionShortArray() {\n        short[] array = new short[] { 1, 2, -3, 4 };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }\n", "    public void testReflectionyteArray() {\n        byte[] array = new byte[] { 1, 2, -3, 4 };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }\n", "    public void testReflectionCharArray() {\n        char[] array = new char[] { 'A', '2', '_', 'D' };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{A,2,_,D}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }\n", "    public void testReflectionDoubleArray() {\n        double[] array = new double[] { 1.0, 2.9876, -3.00001, 4.3 };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{1.0,2.9876,-3.00001,4.3}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }\n", "    public void testReflectionFloatArray() {\n        float[] array = new float[] { 1.0f, 2.9876f, -3.00001f, 4.3f };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{1.0,2.9876,-3.00001,4.3}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }\n", "    public void testReflectionBooleanArray() {\n        boolean[] array = new boolean[] { true, false, false };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{true,false,false}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }\n", "    public void testReflectionFloatArrayArray() {\n        float[][] array = new float[][] { { 1.0f, 2.29686f }, null, { Float.NaN } };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{{1.0,2.29686},<null>,{NaN}}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }\n", "    public void testReflectionLongArrayArray() {\n        long[][] array = new long[][] { { 1, 2 }, null, { 5 } };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }\n", "    public void testReflectionIntArrayArray() {\n        int[][] array = new int[][] { { 1, 2 }, null, { 5 } };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }\n", "    public void testReflectionhortArrayArray() {\n        short[][] array = new short[][] { { 1, 2 }, null, { 5 } };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }\n", "    public void testReflectionByteArrayArray() {\n        byte[][] array = new byte[][] { { 1, 2 }, null, { 5 } };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }\n", "    public void testReflectionCharArrayArray() {\n        char[][] array = new char[][] { { 'A', 'B' }, null, { 'p' } };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{{A,B},<null>,{p}}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }\n", "    public void testReflectionDoubleArrayArray() {\n        double[][] array = new double[][] { { 1.0, 2.29686 }, null, { Double.NaN } };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{{1.0,2.29686},<null>,{NaN}}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }\n", "    public void testReflectionBooleanArrayArray() {\n        boolean[][] array = new boolean[][] { { true, false }, null, { false } };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{{true,false},<null>,{false}}]\", ToStringBuilder.reflectionToString(array));\n        assertEquals(baseStr + \"[{{true,false},<null>,{false}}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }\n", "    public void testReflectionHierarchyArrayList() {}\n", "    public void testReflectionHierarchy() {\n        ReflectionTestFixtureA baseA = new ReflectionTestFixtureA();\n        String baseStr = this.toBaseString(baseA);\n        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA));\n        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null));\n        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false));\n        assertEquals(baseStr + \"[a=a,transientA=t]\", ToStringBuilder.reflectionToString(baseA, null, true));\n        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false, null));\n        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false, Object.class));\n        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false, ReflectionTestFixtureA.class));\n\n        ReflectionTestFixtureB baseB = new ReflectionTestFixtureB();\n        baseStr = this.toBaseString(baseB);\n        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB));\n        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB));\n        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null));\n        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false));\n        assertEquals(baseStr + \"[b=b,transientB=t,a=a,transientA=t]\", ToStringBuilder.reflectionToString(baseB, null, true));\n        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false, null));\n        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false, Object.class));\n        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false, ReflectionTestFixtureA.class));\n        assertEquals(baseStr + \"[b=b]\", ToStringBuilder.reflectionToString(baseB, null, false, ReflectionTestFixtureB.class));\n        this.validateNullToStringStyleRegistry();\n    }\n", "    public void testReflectionArrayCycle() throws Exception {\n        Object[] objects = new Object[1];\n        objects[0] = objects;\n        assertEquals(\n            this.toBaseString(objects) + \"[{\" + this.toBaseString(objects) + \"}]\",\n            ToStringBuilder.reflectionToString(objects));\n        this.validateNullToStringStyleRegistry();\n    }\n", "    public void testReflectionArrayCycleLevel2() throws Exception {\n        Object[] objects = new Object[1];\n        Object[] objectsLevel2 = new Object[1];\n        objects[0] = objectsLevel2;\n        objectsLevel2[0] = objects;\n        assertEquals(\n            this.toBaseString(objects) + \"[{{\" + this.toBaseString(objects) + \"}}]\",\n            ToStringBuilder.reflectionToString(objects));\n        assertEquals(\n            this.toBaseString(objectsLevel2) + \"[{{\" + this.toBaseString(objectsLevel2) + \"}}]\",\n            ToStringBuilder.reflectionToString(objectsLevel2));\n        this.validateNullToStringStyleRegistry();\n    }\n", "    public void testReflectionArrayArrayCycle() throws Exception {\n        Object[][] objects = new Object[2][2];\n        objects[0][0] = objects;\n        objects[0][1] = objects;\n        objects[1][0] = objects;\n        objects[1][1] = objects;\n        String basicToString = this.toBaseString(objects);\n        assertEquals(\n            basicToString\n                + \"[{{\"\n                + basicToString\n                + \",\"\n                + basicToString\n                + \"},{\"\n                + basicToString\n                + \",\"\n                + basicToString\n                + \"}}]\",\n            ToStringBuilder.reflectionToString(objects));\n        this.validateNullToStringStyleRegistry();\n    }\n", "    public void testSimpleReflectionObjectCycle() throws Exception {\n        SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture();\n        simple.o = simple;\n        assertEquals(this.toBaseString(simple) + \"[o=\" + this.toBaseString(simple) + \"]\", simple.toString());\n        this.validateNullToStringStyleRegistry();\n    }\n", "    public void testSelfInstanceVarReflectionObjectCycle() throws Exception {\n        SelfInstanceVarReflectionTestFixture test = new SelfInstanceVarReflectionTestFixture();\n        assertEquals(this.toBaseString(test) + \"[typeIsSelf=\" + this.toBaseString(test) + \"]\", test.toString());\n        this.validateNullToStringStyleRegistry();\n    }\n", "    public void testSelfInstanceTwoVarsReflectionObjectCycle() throws Exception {\n        SelfInstanceTwoVarsReflectionTestFixture test = new SelfInstanceTwoVarsReflectionTestFixture();\n        assertEquals(this.toBaseString(test) + \"[typeIsSelf=\" + this.toBaseString(test) + \",otherType=\" + test.getOtherType().toString() + \"]\", test.toString());\n        this.validateNullToStringStyleRegistry();\n    }\n", "    public void testReflectionObjectCycle() throws Exception {\n        ReflectionTestCycleA a = new ReflectionTestCycleA();\n        ReflectionTestCycleB b = new ReflectionTestCycleB();\n        a.b = b;\n        b.a = a;\n        assertEquals(\n            this.toBaseString(a) + \"[b=\" + this.toBaseString(b) + \"[a=\" + this.toBaseString(a) + \"]]\",\n            a.toString());\n        this.validateNullToStringStyleRegistry();\n    }\n", "    public void testReflectionArrayAndObjectCycle() throws Exception {\n        Object[] objects = new Object[1];\n        SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture(objects);\n        objects[0] = simple;\n        assertEquals(\n            this.toBaseString(objects)\n                + \"[{\"\n                + this.toBaseString(simple)\n                + \"[o=\"\n                + this.toBaseString(objects)\n                + \"]\"\n                + \"}]\",\n            ToStringBuilder.reflectionToString(objects));\n        assertEquals(\n            this.toBaseString(simple)\n                + \"[o={\"\n                + this.toBaseString(simple)\n                + \"}]\",\n            ToStringBuilder.reflectionToString(simple));\n        this.validateNullToStringStyleRegistry();\n    }\n", "    public void testObjectCycle() {\n        ObjectCycle a = new ObjectCycle();\n        ObjectCycle b = new ObjectCycle();\n        a.obj = b;\n        b.obj = a;\n\n        String expected = toBaseString(a) + \"[\" + toBaseString(b) + \"[\" + toBaseString(a) + \"]]\";\n        assertEquals(expected, a.toString());\n        validateNullToStringStyleRegistry();\n    }\n"], "Lang_16": ["    @Test\n    public void testCreateNumber() {\n        // a lot of things can go wrong\n        assertEquals(\"createNumber(String) 1 failed\", Float.valueOf(\"1234.5\"), NumberUtils.createNumber(\"1234.5\"));\n        assertEquals(\"createNumber(String) 2 failed\", Integer.valueOf(\"12345\"), NumberUtils.createNumber(\"12345\"));\n        assertEquals(\"createNumber(String) 3 failed\", Double.valueOf(\"1234.5\"), NumberUtils.createNumber(\"1234.5D\"));\n        assertEquals(\"createNumber(String) 3 failed\", Double.valueOf(\"1234.5\"), NumberUtils.createNumber(\"1234.5d\"));\n        assertEquals(\"createNumber(String) 4 failed\", Float.valueOf(\"1234.5\"), NumberUtils.createNumber(\"1234.5F\"));\n        assertEquals(\"createNumber(String) 4 failed\", Float.valueOf(\"1234.5\"), NumberUtils.createNumber(\"1234.5f\"));\n        assertEquals(\"createNumber(String) 5 failed\", Long.valueOf(Integer.MAX_VALUE + 1L), NumberUtils.createNumber(\"\"\n            + (Integer.MAX_VALUE + 1L)));\n        assertEquals(\"createNumber(String) 6 failed\", Long.valueOf(12345), NumberUtils.createNumber(\"12345L\"));\n        assertEquals(\"createNumber(String) 6 failed\", Long.valueOf(12345), NumberUtils.createNumber(\"12345l\"));\n        assertEquals(\"createNumber(String) 7 failed\", Float.valueOf(\"-1234.5\"), NumberUtils.createNumber(\"-1234.5\"));\n        assertEquals(\"createNumber(String) 8 failed\", Integer.valueOf(\"-12345\"), NumberUtils.createNumber(\"-12345\"));\n        assertTrue(\"createNumber(String) 9a failed\", 0xFADE == NumberUtils.createNumber(\"0xFADE\").intValue());\n        assertTrue(\"createNumber(String) 9b failed\", 0xFADE == NumberUtils.createNumber(\"0Xfade\").intValue());\n        assertTrue(\"createNumber(String) 10a failed\", -0xFADE == NumberUtils.createNumber(\"-0xFADE\").intValue());\n        assertTrue(\"createNumber(String) 10b failed\", -0xFADE == NumberUtils.createNumber(\"-0Xfade\").intValue());\n        assertEquals(\"createNumber(String) 11 failed\", Double.valueOf(\"1.1E200\"), NumberUtils.createNumber(\"1.1E200\"));\n        assertEquals(\"createNumber(String) 12 failed\", Float.valueOf(\"1.1E20\"), NumberUtils.createNumber(\"1.1E20\"));\n        assertEquals(\"createNumber(String) 13 failed\", Double.valueOf(\"-1.1E200\"), NumberUtils.createNumber(\"-1.1E200\"));\n        assertEquals(\"createNumber(String) 14 failed\", Double.valueOf(\"1.1E-200\"), NumberUtils.createNumber(\"1.1E-200\"));\n        assertEquals(\"createNumber(null) failed\", null, NumberUtils.createNumber(null));\n        assertEquals(\"createNumber(String) failed\", new BigInteger(\"12345678901234567890\"), NumberUtils\n                .createNumber(\"12345678901234567890L\"));\n\n        // jdk 1.2 doesn't support this. unsure about jdk 1.2.2\n        if (SystemUtils.isJavaVersionAtLeast(JAVA_1_3)) {\n            assertEquals(\"createNumber(String) 15 failed\", new BigDecimal(\"1.1E-700\"), NumberUtils\n                    .createNumber(\"1.1E-700F\"));\n        }\n        assertEquals(\"createNumber(String) 16 failed\", Long.valueOf(\"10\" + Integer.MAX_VALUE), NumberUtils\n                .createNumber(\"10\" + Integer.MAX_VALUE + \"L\"));\n        assertEquals(\"createNumber(String) 17 failed\", Long.valueOf(\"10\" + Integer.MAX_VALUE), NumberUtils\n                .createNumber(\"10\" + Integer.MAX_VALUE));\n        assertEquals(\"createNumber(String) 18 failed\", new BigInteger(\"10\" + Long.MAX_VALUE), NumberUtils\n                .createNumber(\"10\" + Long.MAX_VALUE));\n\n        // LANG-521\n        assertEquals(\"createNumber(String) LANG-521 failed\", Float.valueOf(\"2.\"), NumberUtils.createNumber(\"2.\"));\n\n        // LANG-638\n        assertFalse(\"createNumber(String) succeeded\", checkCreateNumber(\"1eE\"));\n\n        // LANG-693\n        assertEquals(\"createNumber(String) LANG-693 failed\", Double.valueOf(Double.MAX_VALUE), NumberUtils\n                    .createNumber(\"\" + Double.MAX_VALUE));\n    }\n"], "Time_20": ["    public void test_printParseZoneDawsonCreek() {  // clashes with shorter Dawson\n        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n            .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneId();\n        DateTimeFormatter f = bld.toFormatter();\n        \n        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, DateTimeZone.forID(\"America/Dawson_Creek\"));\n        assertEquals(\"2007-03-04 12:30 America/Dawson_Creek\", f.print(dt));\n        assertEquals(dt, f.parseDateTime(\"2007-03-04 12:30 America/Dawson_Creek\"));\n    }\n"], "Closure_97": ["  public void testFoldBitShifts() {\n    fold(\"x = 1 << 0\", \"x = 1\");\n    fold(\"x = -1 << 0\", \"x = -1\");\n    fold(\"x = 1 << 1\", \"x = 2\");\n    fold(\"x = 3 << 1\", \"x = 6\");\n    fold(\"x = 1 << 8\", \"x = 256\");\n\n    fold(\"x = 1 >> 0\", \"x = 1\");\n    fold(\"x = -1 >> 0\", \"x = -1\");\n    fold(\"x = 1 >> 1\", \"x = 0\");\n    fold(\"x = 2 >> 1\", \"x = 1\");\n    fold(\"x = 5 >> 1\", \"x = 2\");\n    fold(\"x = 127 >> 3\", \"x = 15\");\n    fold(\"x = 3 >> 1\", \"x = 1\");\n    fold(\"x = 3 >> 2\", \"x = 0\");\n    fold(\"x = 10 >> 1\", \"x = 5\");\n    fold(\"x = 10 >> 2\", \"x = 2\");\n    fold(\"x = 10 >> 5\", \"x = 0\");\n\n    fold(\"x = 10 >>> 1\", \"x = 5\");\n    fold(\"x = 10 >>> 2\", \"x = 2\");\n    fold(\"x = 10 >>> 5\", \"x = 0\");\n    fold(\"x = -1 >>> 1\", \"x = 2147483647\"); // 0x7fffffff\n    fold(\"x = -1 >>> 0\", \"x = 4294967295\"); // 0xffffffff\n    fold(\"x = -2 >>> 0\", \"x = 4294967294\"); // 0xfffffffe\n\n    fold(\"3000000000 << 1\", \"3000000000<<1\",\n         PeepholeFoldConstants.BITWISE_OPERAND_OUT_OF_RANGE);\n    fold(\"1 << 32\", \"1<<32\",\n        PeepholeFoldConstants.SHIFT_AMOUNT_OUT_OF_BOUNDS);\n    fold(\"1 << -1\", \"1<<32\",\n        PeepholeFoldConstants.SHIFT_AMOUNT_OUT_OF_BOUNDS);\n    fold(\"3000000000 >> 1\", \"3000000000>>1\",\n        PeepholeFoldConstants.BITWISE_OPERAND_OUT_OF_RANGE);\n    fold(\"1 >> 32\", \"1>>32\",\n        PeepholeFoldConstants.SHIFT_AMOUNT_OUT_OF_BOUNDS);\n    fold(\"1.5 << 0\",  \"1.5<<0\",\n        PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n    fold(\"1 << .5\",   \"1.5<<0\",\n        PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n    fold(\"1.5 >>> 0\", \"1.5>>>0\",\n        PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n    fold(\"1 >>> .5\",  \"1.5>>>0\",\n        PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n    fold(\"1.5 >> 0\",  \"1.5>>0\",\n        PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n    fold(\"1 >> .5\",   \"1.5>>0\",\n        PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n  }\n", "  public void testFoldBitShiftsStringCompare() {\n    // Negative numbers.\n    assertResultString(\"x = -1 << 1\", \"x=-2\");\n    assertResultString(\"x = -1 << 8\", \"x=-256\");\n    assertResultString(\"x = -1 >> 1\", \"x=-1\");\n    assertResultString(\"x = -2 >> 1\", \"x=-1\");\n    assertResultString(\"x = -1 >> 0\", \"x=-1\");\n  }\n"], "Closure_110": ["  public void testFunctionDeclaration() {\n    testScoped(\"if (x) { function f() {} } g(f)\",\n               SCOPE_NAMESPACE +\n               \"if (x) { $jscomp.scope.f = function () {}; } \" +\n               \"g($jscomp.scope.f); \");\n  }\n", "  public void testHoistedFunctionDeclaration() {\n    testScoped(\" g(f); function f() {} \",\n               SCOPE_NAMESPACE +\n               \" $jscomp.scope.f = function () {}; \" +\n               \"g($jscomp.scope.f); \");\n  }\n"], "Lang_29": ["    public void testJavaVersionAsInt() {\n        assertEquals(0, SystemUtils.toJavaVersionInt(null));\n        assertEquals(0, SystemUtils.toJavaVersionInt(\"\"));\n        assertEquals(0, SystemUtils.toJavaVersionInt(\"0\"));\n        assertEquals(110, SystemUtils.toJavaVersionInt(\"1.1\"));\n        assertEquals(120, SystemUtils.toJavaVersionInt(\"1.2\"));\n        assertEquals(130, SystemUtils.toJavaVersionInt(\"1.3.0\"));\n        assertEquals(131, SystemUtils.toJavaVersionInt(\"1.3.1\"));\n        assertEquals(140, SystemUtils.toJavaVersionInt(\"1.4.0\"));\n        assertEquals(141, SystemUtils.toJavaVersionInt(\"1.4.1\"));\n        assertEquals(142, SystemUtils.toJavaVersionInt(\"1.4.2\"));\n        assertEquals(150, SystemUtils.toJavaVersionInt(\"1.5.0\"));\n        assertEquals(160, SystemUtils.toJavaVersionInt(\"1.6.0\"));\n        assertEquals(131, SystemUtils.toJavaVersionInt(\"JavaVM-1.3.1\"));\n        assertEquals(131, SystemUtils.toJavaVersionInt(\"1.3.1 subset\"));\n        // This used to return 0f in [lang] version 2.5:\n        assertEquals(130, SystemUtils.toJavaVersionInt(\"XXX-1.3.x\"));\n    }\n"], "Time_18": ["    public void testLeapYearRulesConstruction() {\n        // 1500 not leap in Gregorian, but is leap in Julian\n        DateMidnight dt = new DateMidnight(1500, 2, 29, GJChronology.getInstanceUTC());\n        assertEquals(dt.getYear(), 1500);\n        assertEquals(dt.getMonthOfYear(), 2);\n        assertEquals(dt.getDayOfMonth(), 29);\n    }\n", "    public void testLeapYearRulesConstructionInvalid() {\n        // 1500 not leap in Gregorian, but is leap in Julian\n        try {\n            new DateMidnight(1500, 2, 30, GJChronology.getInstanceUTC());\n            fail();\n        } catch (IllegalFieldValueException ex) {\n            // good\n        }\n    }\n"], "Closure_128": ["  public void testIssue942() {\n    assertPrint(\"var x = {0: 1};\", \"var x={0:1}\");\n  }\n"], "Lang_11": ["    public void testLANG807() {\n        try {\n            RandomStringUtils.random(3,5,5,false,false);\n            fail(\"Expected IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) { // distinguish from Random#nextInt message\n            final String msg = ex.getMessage();\n            assertTrue(\"Message (\" + msg + \") must contain 'start'\", msg.contains(\"start\"));\n            assertTrue(\"Message (\" + msg + \") must contain 'end'\", msg.contains(\"end\"));\n        }\n    }\n"], "Closure_90": ["  public void testBackwardsTypedefUse8() throws Exception {\n    // Tehnically, this isn't quite right, because the JS runtime\n    // will coerce null -> the global object. But we'll punt on that for now.\n    testTypes(\n        \"/** @param {!Array} x */ function g(x) {}\" +\n        \"/** @this {goog.MyTypedef} */ function f() { g(this); }\" +\n        \"var goog = {};\" +\n        \"/** @typedef {(Array|null|undefined)} */ goog.MyTypedef;\");\n  }\n", "  public void testBackwardsTypedefUse9() throws Exception {\n    testTypes(\n        \"/** @param {!Array} x */ function g(x) {}\" +\n        \"/** @this {goog.MyTypedef} */ function f() { g(this); }\" +\n        \"var goog = {};\" +\n        \"/** @typedef {(Error|null|undefined)} */ goog.MyTypedef;\",\n        \"actual parameter 1 of g does not match formal parameter\\n\" +\n        \"found   : Error\\n\" +\n        \"required: Array\");\n  }\n"], "Closure_117": ["  public void testIssue1047() throws Exception {\n    testTypes(\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" */\\n\" +\n        \"function C2() {}\\n\" +\n        \"\\n\" +\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" */\\n\" +\n        \"function C3(c2) {\\n\" +\n        \"  /**\\n\" +\n        \"   * @type {C2} \\n\" +\n        \"   * @private\\n\" +\n        \"   */\\n\" +\n        \"  this.c2_;\\n\" +\n        \"\\n\" +\n        \"  var x = this.c2_.prop;\\n\" +\n        \"}\",\n        \"Property prop never defined on C2\");\n  }\n"], "Time_27": ["    public void testBug2495455() {\n        PeriodFormatter pfmt1 = new PeriodFormatterBuilder()\n            .appendLiteral(\"P\")\n            .appendYears()\n            .appendSuffix(\"Y\")\n            .appendMonths()\n            .appendSuffix(\"M\")\n            .appendWeeks()\n            .appendSuffix(\"W\")\n            .appendDays()\n            .appendSuffix(\"D\")\n            .appendSeparatorIfFieldsAfter(\"T\")\n            .appendHours()\n            .appendSuffix(\"H\")\n            .appendMinutes()\n            .appendSuffix(\"M\")\n            .appendSecondsWithOptionalMillis()\n            .appendSuffix(\"S\")\n            .toFormatter();\n        PeriodFormatter pfmt2 = new PeriodFormatterBuilder()\n            .append(ISOPeriodFormat.standard())\n            .toFormatter();\n        pfmt1.parsePeriod(\"PT1003199059S\");\n        pfmt2.parsePeriod(\"PT1003199059S\");\n    }\n"], "Closure_64": ["  public void testES5StrictUseStrictMultipleInputs() {\n    args.add(\"--language_in=ECMASCRIPT5_STRICT\");\n    Compiler compiler = compile(new String[] {\"var x = f.function\",\n        \"var y = f.function\", \"var z = f.function\"});\n    String outputSource = compiler.toSource();\n    assertEquals(\"'use strict'\", outputSource.substring(0, 12));\n    assertEquals(outputSource.substring(13).indexOf(\"'use strict'\"), -1);\n  }\n"], "Closure_99": ["  public void testInterface1() {\n    testSame(\n        \"/** @interface */function A() { /** @type {string} */ this.m2; }\");\n  }\n", "  public void testMethod4() {\n    testSame(\"a.prototype['x' + 'y'] =  function() { this.foo = 3; };\");\n  }\n", "  public void testPropertyOfMethod() {\n    testFailure(\"a.protoype.b = {}; \" +\n        \"a.prototype.b.c = function() { this.foo = 3; };\");\n  }\n"], "Lang_27": ["    public void testCreateNumber() {\n        // a lot of things can go wrong\n        assertEquals(\"createNumber(String) 1 failed\", new Float(\"1234.5\"), NumberUtils.createNumber(\"1234.5\"));\n        assertEquals(\"createNumber(String) 2 failed\", new Integer(\"12345\"), NumberUtils.createNumber(\"12345\"));\n        assertEquals(\"createNumber(String) 3 failed\", new Double(\"1234.5\"), NumberUtils.createNumber(\"1234.5D\"));\n        assertEquals(\"createNumber(String) 3 failed\", new Double(\"1234.5\"), NumberUtils.createNumber(\"1234.5d\"));\n        assertEquals(\"createNumber(String) 4 failed\", new Float(\"1234.5\"), NumberUtils.createNumber(\"1234.5F\"));\n        assertEquals(\"createNumber(String) 4 failed\", new Float(\"1234.5\"), NumberUtils.createNumber(\"1234.5f\"));\n        assertEquals(\"createNumber(String) 5 failed\", new Long(Integer.MAX_VALUE + 1L), NumberUtils.createNumber(\"\"\n            + (Integer.MAX_VALUE + 1L)));\n        assertEquals(\"createNumber(String) 6 failed\", new Long(12345), NumberUtils.createNumber(\"12345L\"));\n        assertEquals(\"createNumber(String) 6 failed\", new Long(12345), NumberUtils.createNumber(\"12345l\"));\n        assertEquals(\"createNumber(String) 7 failed\", new Float(\"-1234.5\"), NumberUtils.createNumber(\"-1234.5\"));\n        assertEquals(\"createNumber(String) 8 failed\", new Integer(\"-12345\"), NumberUtils.createNumber(\"-12345\"));\n        assertTrue(\"createNumber(String) 9 failed\", 0xFADE == NumberUtils.createNumber(\"0xFADE\").intValue());\n        assertTrue(\"createNumber(String) 10 failed\", -0xFADE == NumberUtils.createNumber(\"-0xFADE\").intValue());\n        assertEquals(\"createNumber(String) 11 failed\", new Double(\"1.1E200\"), NumberUtils.createNumber(\"1.1E200\"));\n        assertEquals(\"createNumber(String) 12 failed\", new Float(\"1.1E20\"), NumberUtils.createNumber(\"1.1E20\"));\n        assertEquals(\"createNumber(String) 13 failed\", new Double(\"-1.1E200\"), NumberUtils.createNumber(\"-1.1E200\"));\n        assertEquals(\"createNumber(String) 14 failed\", new Double(\"1.1E-200\"), NumberUtils.createNumber(\"1.1E-200\"));\n        assertEquals(\"createNumber(null) failed\", null, NumberUtils.createNumber(null));\n        assertEquals(\"createNumber(String) failed\", new BigInteger(\"12345678901234567890\"), NumberUtils\n                .createNumber(\"12345678901234567890L\"));\n\n        // jdk 1.2 doesn't support this. unsure about jdk 1.2.2\n        if (SystemUtils.isJavaVersionAtLeast(1.3f)) {\n            assertEquals(\"createNumber(String) 15 failed\", new BigDecimal(\"1.1E-700\"), NumberUtils\n                    .createNumber(\"1.1E-700F\"));\n        }\n        assertEquals(\"createNumber(String) 16 failed\", new Long(\"10\" + Integer.MAX_VALUE), NumberUtils\n                .createNumber(\"10\" + Integer.MAX_VALUE + \"L\"));\n        assertEquals(\"createNumber(String) 17 failed\", new Long(\"10\" + Integer.MAX_VALUE), NumberUtils\n                .createNumber(\"10\" + Integer.MAX_VALUE));\n        assertEquals(\"createNumber(String) 18 failed\", new BigInteger(\"10\" + Long.MAX_VALUE), NumberUtils\n                .createNumber(\"10\" + Long.MAX_VALUE));\n\n        // LANG-521\n        assertEquals(\"createNumber(String) LANG-521 failed\", new Float(\"2.\"), NumberUtils.createNumber(\"2.\"));\n\n        // LANG-638\n        assertFalse(\"createNumber(String) succeeded\", checkCreateNumber(\"1eE\"));\n    }\n"], "Lang_18": ["    public void testFormat() {\n        Locale realDefaultLocale = Locale.getDefault();\n        TimeZone realDefaultZone = TimeZone.getDefault();\n        try {\n            Locale.setDefault(Locale.US);\n            TimeZone.setDefault(TimeZone.getTimeZone(\"America/New_York\"));\n\n            GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20);\n            GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00);\n            Date date1 = cal1.getTime();\n            Date date2 = cal2.getTime();\n            long millis1 = date1.getTime();\n            long millis2 = date2.getTime();\n\n            FastDateFormat fdf = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss\");\n            SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss\");\n            assertEquals(sdf.format(date1), fdf.format(date1));\n            assertEquals(\"2003-01-10T15:33:20\", fdf.format(date1));\n            assertEquals(\"2003-01-10T15:33:20\", fdf.format(cal1));\n            assertEquals(\"2003-01-10T15:33:20\", fdf.format(millis1));\n            assertEquals(\"2003-07-10T09:00:00\", fdf.format(date2));\n            assertEquals(\"2003-07-10T09:00:00\", fdf.format(cal2));\n            assertEquals(\"2003-07-10T09:00:00\", fdf.format(millis2));\n\n            fdf = FastDateFormat.getInstance(\"Z\");\n            assertEquals(\"-0500\", fdf.format(date1));\n            assertEquals(\"-0500\", fdf.format(cal1));\n            assertEquals(\"-0500\", fdf.format(millis1));\n\n            assertEquals(\"-0400\", fdf.format(date2));\n            assertEquals(\"-0400\", fdf.format(cal2));\n            assertEquals(\"-0400\", fdf.format(millis2));\n\n            fdf = FastDateFormat.getInstance(\"ZZ\");\n            assertEquals(\"-05:00\", fdf.format(date1));\n            assertEquals(\"-05:00\", fdf.format(cal1));\n            assertEquals(\"-05:00\", fdf.format(millis1));\n\n            assertEquals(\"-04:00\", fdf.format(date2));\n            assertEquals(\"-04:00\", fdf.format(cal2));\n            assertEquals(\"-04:00\", fdf.format(millis2));\n\n            String pattern = \"GGGG GGG GG G yyyy yyy yy y MMMM MMM MM M\" +\n                \" dddd ddd dd d DDDD DDD DD D EEEE EEE EE E aaaa aaa aa a zzzz zzz zz z\";\n            fdf = FastDateFormat.getInstance(pattern);\n            sdf = new SimpleDateFormat(pattern);\n            // SDF bug fix starting with Java 7\n            assertEquals(sdf.format(date1).replaceAll(\"2003 03 03 03\", \"2003 2003 03 2003\"), fdf.format(date1));\n            assertEquals(sdf.format(date2).replaceAll(\"2003 03 03 03\", \"2003 2003 03 2003\"), fdf.format(date2));\n        } finally {\n            Locale.setDefault(realDefaultLocale);\n            TimeZone.setDefault(realDefaultZone);\n        }\n    }\n"], "Closure_121": ["  public void testExternalIssue1053() {\n    testSame(\n        \"var u; function f() { u = Random(); var x = u; f(); alert(x===u)}\");\n  }\n"], "Closure_52": ["  public void testNumericKeys() {\n    assertPrint(\"var x = {010: 1};\", \"var x={8:1}\");\n    assertPrint(\"var x = {'010': 1};\", \"var x={\\\"010\\\":1}\");\n\n    assertPrint(\"var x = {0x10: 1};\", \"var x={16:1}\");\n    assertPrint(\"var x = {'0x10': 1};\", \"var x={\\\"0x10\\\":1}\");\n\n    // I was surprised at this result too.\n    assertPrint(\"var x = {.2: 1};\", \"var x={\\\"0.2\\\":1}\");\n    assertPrint(\"var x = {'.2': 1};\", \"var x={\\\".2\\\":1}\");\n\n    assertPrint(\"var x = {0.2: 1};\", \"var x={\\\"0.2\\\":1}\");\n    assertPrint(\"var x = {'0.2': 1};\", \"var x={\\\"0.2\\\":1}\");\n  }\n"], "Lang_20": ["    public void testJoin_Objectarray() {\n//        assertEquals(null, StringUtils.join(null)); // generates warning\n        assertEquals(null, StringUtils.join((Object[]) null)); // equivalent explicit cast\n        // test additional varargs calls\n        assertEquals(\"\", StringUtils.join()); // empty array\n        assertEquals(\"\", StringUtils.join((Object) null)); // => new Object[]{null}\n\n        assertEquals(\"\", StringUtils.join(EMPTY_ARRAY_LIST));\n        assertEquals(\"\", StringUtils.join(NULL_ARRAY_LIST));\n        assertEquals(\"null\", StringUtils.join(NULL_TO_STRING_LIST));\n        assertEquals(\"abc\", StringUtils.join(new String[] {\"a\", \"b\", \"c\"}));\n        assertEquals(\"a\", StringUtils.join(new String[] {null, \"a\", \"\"}));\n        assertEquals(\"foo\", StringUtils.join(MIXED_ARRAY_LIST));\n        assertEquals(\"foo2\", StringUtils.join(MIXED_TYPE_LIST));\n    }\n", "    public void testJoin_ArrayChar() {\n        assertEquals(null, StringUtils.join((Object[]) null, ','));\n        assertEquals(TEXT_LIST_CHAR, StringUtils.join(ARRAY_LIST, SEPARATOR_CHAR));\n        assertEquals(\"\", StringUtils.join(EMPTY_ARRAY_LIST, SEPARATOR_CHAR));\n        assertEquals(\";;foo\", StringUtils.join(MIXED_ARRAY_LIST, SEPARATOR_CHAR));\n        assertEquals(\"foo;2\", StringUtils.join(MIXED_TYPE_LIST, SEPARATOR_CHAR));\n\n        assertEquals(\"/\", StringUtils.join(MIXED_ARRAY_LIST, '/', 0, MIXED_ARRAY_LIST.length-1));\n        assertEquals(\"foo\", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 1));\n        assertEquals(\"null\", StringUtils.join(NULL_TO_STRING_LIST,'/', 0, 1));\n        assertEquals(\"foo/2\", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 2));\n        assertEquals(\"2\", StringUtils.join(MIXED_TYPE_LIST, '/', 1, 2));\n        assertEquals(\"\", StringUtils.join(MIXED_TYPE_LIST, '/', 2, 1));\n    }\n"], "Closure_119": ["  public void testGlobalCatch() throws Exception {\n    testSame(\n        \"try {\" +\n        \"  throw Error();\" +\n        \"} catch (e) {\" +\n        \"  console.log(e.name)\" +\n        \"}\");\n  }\n"], "Closure_55": ["  public void testIssue538() {\n    checkCompilesToSame(      \"/** @constructor */\\n\" +\n        \"WebInspector.Setting = function() {}\\n\" +\n        \"WebInspector.Setting.prototype = {\\n\" +\n        \"    get name0(){return this._name;},\\n\" +\n        \"    get name1(){return this._name;},\\n\" +\n        \"    get name2(){return this._name;},\\n\" +\n        \"    get name3(){return this._name;},\\n\" +\n        \"    get name4(){return this._name;},\\n\" +\n        \"    get name5(){return this._name;},\\n\" +\n        \"    get name6(){return this._name;},\\n\" +\n        \"    get name7(){return this._name;},\\n\" +\n        \"    get name8(){return this._name;},\\n\" +\n        \"    get name9(){return this._name;},\\n\" +\n        \"}\", 1);\n  }\n"], "Closure_126": ["  public void testFunctionReturnOptimization() throws Exception {\n    fold(\"function f(){if(a()){b();if(c())return;}}\",\n         \"function f(){if(a()){b();if(c());}}\");\n    fold(\"function f(){if(x)return; x=3; return; }\",\n         \"function f(){if(x); else x=3}\");\n    fold(\"function f(){if(true){a();return;}else;b();}\",\n         \"function f(){if(true){a();}else{b();}}\");\n    fold(\"function f(){if(false){a();return;}else;b();return;}\",\n         \"function f(){if(false){a();}else{b();}}\");\n    fold(\"function f(){if(a()){b();return;}else;c();}\",\n         \"function f(){if(a()){b();}else{c();}}\");\n    fold(\"function f(){if(a()){b()}else{c();return;}}\",\n         \"function f(){if(a()){b()}else{c();}}\");\n    fold(\"function f(){if(a()){b();return;}else;}\",\n         \"function f(){if(a()){b();}else;}\");\n    fold(\"function f(){if(a()){return;}else{return;} return;}\",\n         \"function f(){if(a()){}else{}}\");\n    fold(\"function f(){if(a()){return;}else{return;} b();}\",\n         \"function f(){if(a()){}else{return;b()}}\");\n    fold(\"function f(){ if (x) return; if (y) return; if (z) return; w(); }\",\n        \" function f() {\" +\n        \"   if (x) {} else { if (y) {} else { if (z) {} else w(); }}\" +\n        \" }\");\n\n    fold(\"function f(){while(a())return;}\",\n         \"function f(){while(a())return}\");\n    foldSame(\"function f(){for(x in a())return}\");\n\n    fold(\"function f(){while(a())break;}\",\n         \"function f(){while(a())break}\");\n    foldSame(\"function f(){for(x in a())break}\");\n\n    fold(\"function f(){try{return;}catch(e){throw 9;}finally{return}}\",\n         \"function f(){try{}catch(e){throw 9;}finally{return}}\");\n    foldSame(\"function f(){try{throw 9;}finally{return;}}\");\n\n    fold(\"function f(){try{return;}catch(e){return;}}\",\n         \"function f(){try{}catch(e){}}\");\n    fold(\"function f(){try{if(a()){return;}else{return;} return;}catch(e){}}\",\n         \"function f(){try{if(a()){}else{}}catch(e){}}\");\n\n    fold(\"function f(){g:return}\",\n         \"function f(){}\");\n    fold(\"function f(){g:if(a()){return;}else{return;} return;}\",\n         \"function f(){g:if(a()){}else{}}\");\n    fold(\"function f(){try{g:if(a()){throw 9;} return;}finally{return}}\",\n         \"function f(){try{g:if(a()){throw 9;}}finally{return}}\");\n  }\n", "  public void testDontRemoveBreakInTryFinally() throws Exception {\n    foldSame(\"function f() {b:try{throw 9} finally {break b} return 1;}\");\n  }\n"], "Time_16": ["    public void testParseInto_monthOnly() {\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"M\").withLocale(Locale.UK);\n        MutableDateTime result = new MutableDateTime(2004, 1, 9, 12, 20, 30, 0, LONDON);\n        assertEquals(1, f.parseInto(result, \"5\", 0));\n        assertEquals(new MutableDateTime(2004, 5, 9, 12, 20, 30, 0, LONDON), result);\n    }\n", "    public void testParseInto_monthOnly_baseStartYear() {\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"M\").withLocale(Locale.UK);\n        MutableDateTime result = new MutableDateTime(2004, 1, 1, 12, 20, 30, 0, TOKYO);\n        assertEquals(1, f.parseInto(result, \"5\", 0));\n        assertEquals(new MutableDateTime(2004, 5, 1, 12, 20, 30, 0, TOKYO), result);\n    }\n", "    public void testParseInto_monthOnly_parseStartYear() {\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"M\").withLocale(Locale.UK);\n        MutableDateTime result = new MutableDateTime(2004, 2, 1, 12, 20, 30, 0, TOKYO);\n        assertEquals(1, f.parseInto(result, \"1\", 0));\n        assertEquals(new MutableDateTime(2004, 1, 1, 12, 20, 30, 0, TOKYO), result);\n    }\n", "    public void testParseInto_monthOnly_baseEndYear() {\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"M\").withLocale(Locale.UK);\n        MutableDateTime result = new MutableDateTime(2004, 12, 31, 12, 20, 30, 0, TOKYO);\n        assertEquals(1, f.parseInto(result, \"5\", 0));\n        assertEquals(new MutableDateTime(2004, 5, 31, 12, 20, 30, 0, TOKYO), result);\n   }\n", "    public void testParseInto_monthOnly_parseEndYear() {\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"M\").withLocale(Locale.UK);\n        MutableDateTime result = new MutableDateTime(2004, 1, 31, 12, 20, 30, 0,TOKYO);\n        assertEquals(2, f.parseInto(result, \"12\", 0));\n        assertEquals(new MutableDateTime(2004, 12, 31, 12, 20, 30, 0, TOKYO), result);\n    }\n", "    public void testParseInto_monthDay_feb29() {\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"M d\").withLocale(Locale.UK);\n        MutableDateTime result = new MutableDateTime(2004, 1, 9, 12, 20, 30, 0, LONDON);\n        assertEquals(4, f.parseInto(result, \"2 29\", 0));\n        assertEquals(new MutableDateTime(2004, 2, 29, 12, 20, 30, 0, LONDON), result);\n    }\n", "    public void testParseInto_monthDay_withDefaultYear_feb29() {\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"M d\").withDefaultYear(2012);\n        MutableDateTime result = new MutableDateTime(2004, 1, 9, 12, 20, 30, 0, LONDON);\n        assertEquals(4, f.parseInto(result, \"2 29\", 0));\n        assertEquals(new MutableDateTime(2004, 2, 29, 12, 20, 30, 0, LONDON), result);\n    }\n"], "Closure_39": ["  public void testRecursiveRecord() {\n    ProxyObjectType loop = new ProxyObjectType(registry, NUMBER_TYPE);\n    JSType record = new RecordTypeBuilder(registry)\n        .addProperty(\"loop\", loop, null)\n        .addProperty(\"number\", NUMBER_TYPE, null)\n        .addProperty(\"string\", STRING_TYPE, null)\n        .build();\n    assertEquals(\"{loop: number, number: number, string: string}\",\n        record.toString());\n\n    loop.setReferencedType(record);\n    assertEquals(\"{loop: {...}, number: number, string: string}\",\n        record.toString());\n    assertEquals(\"{loop: ?, number: number, string: string}\",\n        record.toAnnotationString());\n\n    Asserts.assertEquivalenceOperations(record, loop);\n  }\n", "  public void testLongToString() {\n    JSType record = new RecordTypeBuilder(registry)\n        .addProperty(\"a1\", NUMBER_TYPE, null)\n        .addProperty(\"a2\", NUMBER_TYPE, null)\n        .addProperty(\"a3\", NUMBER_TYPE, null)\n        .addProperty(\"a4\", NUMBER_TYPE, null)\n        .addProperty(\"a5\", NUMBER_TYPE, null)\n        .addProperty(\"a6\", NUMBER_TYPE, null)\n        .build();\n    assertEquals(\"{a1: number, a2: number, a3: number, a4: number, ...}\",\n        record.toString());\n    assertEquals(\n        \"{a1: number, a2: number, a3: number, a4: number,\" +\n        \" a5: number, a6: number}\",\n        record.toAnnotationString());\n  }\n"], "Closure_30": ["  public void testInlineAcrossSideEffect1() {\n    // This can't be inlined because print() has side-effects and might change\n    // the definition of noSFX.\n    //\n    // noSFX must be both const and pure in order to inline it.\n    noInline(\"var y; var x = noSFX(y); print(x)\");\n    //inline(\"var y; var x = noSFX(y); print(x)\", \"var y;var x;print(noSFX(y))\");\n  }\n", "  public void testCanInlineAcrossNoSideEffect() {\n    // This can't be inlined because print() has side-effects and might change\n    // the definition of noSFX. We should be able to mark noSFX as const\n    // in some way.\n    noInline(\n        \"var y; var x = noSFX(y), z = noSFX(); noSFX(); noSFX(), print(x)\");\n    //inline(\n    //    \"var y; var x = noSFX(y), z = noSFX(); noSFX(); noSFX(), print(x)\",\n    //    \"var y; var x, z = noSFX(); noSFX(); noSFX(), print(noSFX(y))\");\n  }\n", "  public void testIssue698() {\n    // Most of the flow algorithms operate on Vars. We want to make\n    // sure the algorithm bails out appropriately if it sees\n    // a var that it doesn't know about.\n    inline(\n        \"var x = ''; \"\n        + \"unknown.length < 2 && (unknown='0' + unknown);\"\n        + \"x = x + unknown; \"\n        + \"unknown.length < 3 && (unknown='0' + unknown);\"\n        + \"x = x + unknown; \"\n        + \"return x;\",\n        \"var x; \"\n        + \"unknown.length < 2 && (unknown='0' + unknown);\"\n        + \"x = '' + unknown; \"\n        + \"unknown.length < 3 && (unknown='0' + unknown);\"\n        + \"x = x + unknown; \"\n        + \"return x;\");\n  }\n"], "Lang_45": ["    public void testAbbreviate() {\n        // check null and empty are returned respectively\n        assertNull(WordUtils.abbreviate(null, 1,-1,\"\"));\n        assertEquals(StringUtils.EMPTY, WordUtils.abbreviate(\"\", 1,-1,\"\"));\n\n        // test upper limit\n        assertEquals(\"01234\", WordUtils.abbreviate(\"0123456789\", 0,5,\"\"));\n        assertEquals(\"01234\", WordUtils.abbreviate(\"0123456789\", 5, 2,\"\"));\n        assertEquals(\"012\", WordUtils.abbreviate(\"012 3456789\", 2, 5,\"\"));\n        assertEquals(\"012 3\", WordUtils.abbreviate(\"012 3456789\", 5, 2,\"\"));\n        assertEquals(\"0123456789\", WordUtils.abbreviate(\"0123456789\", 0,-1,\"\"));\n\n        // test upper limit + append string\n        assertEquals(\"01234-\", WordUtils.abbreviate(\"0123456789\", 0,5,\"-\"));\n        assertEquals(\"01234-\", WordUtils.abbreviate(\"0123456789\", 5, 2,\"-\"));\n        assertEquals(\"012\", WordUtils.abbreviate(\"012 3456789\", 2, 5, null));\n        assertEquals(\"012 3\", WordUtils.abbreviate(\"012 3456789\", 5, 2,\"\"));\n        assertEquals(\"0123456789\", WordUtils.abbreviate(\"0123456789\", 0,-1,\"\"));\n\n        // test lower value\n        assertEquals(\"012\", WordUtils.abbreviate(\"012 3456789\", 0,5, null));\n        assertEquals(\"01234\", WordUtils.abbreviate(\"01234 56789\", 5, 10, null));\n        assertEquals(\"01 23 45 67\", WordUtils.abbreviate(\"01 23 45 67 89\", 9, -1, null));\n        assertEquals(\"01 23 45 6\", WordUtils.abbreviate(\"01 23 45 67 89\", 9, 10, null));\n        assertEquals(\"0123456789\", WordUtils.abbreviate(\"0123456789\", 15, 20, null));\n\n        // test lower value + append\n        assertEquals(\"012\", WordUtils.abbreviate(\"012 3456789\", 0,5, null));\n        assertEquals(\"01234-\", WordUtils.abbreviate(\"01234 56789\", 5, 10, \"-\"));\n        assertEquals(\"01 23 45 67abc\", WordUtils.abbreviate(\"01 23 45 67 89\", 9, -1, \"abc\"));\n        assertEquals(\"01 23 45 6\", WordUtils.abbreviate(\"01 23 45 67 89\", 9, 10, \"\"));\n\n        // others\n        assertEquals(\"\", WordUtils.abbreviate(\"0123456790\", 0,0,\"\"));\n        assertEquals(\"\", WordUtils.abbreviate(\" 0123456790\", 0,-1,\"\"));\n    }\n"], "Closure_37": ["  public void testIncompleteFunction() {\n    CompilerOptions options = createCompilerOptions();\n    options.ideMode = true;\n    DiagnosticType[] warnings = new DiagnosticType[]{\n        RhinoErrorReporter.PARSE_ERROR,\n        RhinoErrorReporter.PARSE_ERROR,\n        RhinoErrorReporter.PARSE_ERROR,\n        RhinoErrorReporter.PARSE_ERROR};\n    test(options,\n        new String[] { \"var foo = {bar: function(e) }\" },\n        new String[] { \"var foo = {bar: function(e){}};\" },\n        warnings\n    );\n  }\n"], "Lang_42": ["    public void testEscapeHtmlHighUnicode() throws java.io.UnsupportedEncodingException {\n        // this is the utf8 representation of the character:\n        // COUNTING ROD UNIT DIGIT THREE\n        // in unicode\n        // codepoint: U+1D362\n        byte[] data = new byte[] { (byte)0xF0, (byte)0x9D, (byte)0x8D, (byte)0xA2 };\n\n        String escaped = StringEscapeUtils.escapeHtml( new String(data, \"UTF8\") );\n        String unescaped = StringEscapeUtils.unescapeHtml( escaped );\n\n        assertEquals( \"High unicode was not escaped correctly\", \"&#119650;\", escaped);\n    }\n"], "Lang_21": ["    public void testIsSameLocalTime_Cal() {\n        GregorianCalendar cal1 = new GregorianCalendar(TimeZone.getTimeZone(\"GMT+1\"));\n        GregorianCalendar cal2 = new GregorianCalendar(TimeZone.getTimeZone(\"GMT-1\"));\n        cal1.set(2004, 6, 9, 13, 45, 0);\n        cal1.set(Calendar.MILLISECOND, 0);\n        cal2.set(2004, 6, 9, 13, 45, 0);\n        cal2.set(Calendar.MILLISECOND, 0);\n        assertEquals(true, DateUtils.isSameLocalTime(cal1, cal2));\n\n        Calendar cal3 = Calendar.getInstance();\n        Calendar cal4 = Calendar.getInstance();\n        cal3.set(2004, 6, 9, 4,  0, 0);\n        cal4.set(2004, 6, 9, 16, 0, 0);\n        cal3.set(Calendar.MILLISECOND, 0);\n        cal4.set(Calendar.MILLISECOND, 0);\n        assertFalse(\"LANG-677\", DateUtils.isSameLocalTime(cal3, cal4));\n        \n        cal2.set(2004, 6, 9, 11, 45, 0);\n        assertEquals(false, DateUtils.isSameLocalTime(cal1, cal2));\n        try {\n            DateUtils.isSameLocalTime((Calendar) null, (Calendar) null);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n    }\n"], "Closure_118": ["  public void testOneType4() {\n    String js = \"\"\n        + \"/** @constructor */ function Foo() {}\\n\"\n        + \"Foo.prototype = {'a': 0};\\n\"\n        + \"/** @type Foo */\\n\"\n        + \"var F = new Foo;\\n\"\n        + \"F['a'] = 0;\";\n    String expected = \"{}\";\n    testSets(false, js, js, expected);\n    testSets(true, js, js, expected);\n  }\n", "  public void testTwoTypes4() {\n    String js = \"\"\n        + \"/** @constructor */ function Foo() {}\\n\"\n        + \"Foo.prototype = {a: 0};\"\n        + \"/** @type Foo */\\n\"\n        + \"var F = new Foo;\\n\"\n        + \"F.a = 0;\"\n        + \"/** @constructor */ function Bar() {}\\n\"\n        + \"Bar.prototype = {'a': 0};\"\n        + \"/** @type Bar */\\n\"\n        + \"var B = new Bar;\\n\"\n        + \"B['a'] = 0;\";\n\n    String output = \"\"\n        + \"function Foo(){}\"\n        + \"Foo.prototype = {a: 0};\"\n        + \"var F=new Foo;\"\n        + \"F.a=0;\"\n        + \"function Bar(){}\"\n        + \"Bar.prototype = {'a': 0};\"\n        + \"var B=new Bar;\"\n        + \"B['a']=0\";\n\n    testSets(false, js, output, \"{a=[[Foo.prototype]]}\");\n    testSets(true, js, output, \"{a=[[Foo.prototype]]}\");\n  }\n"], "Closure_127": ["  public void testIssue4177428a() {\n    testSame(\n        \"f = function() {\\n\" +\n        \"  var action;\\n\" +\n        \"  a: {\\n\" +\n        \"    var proto = null;\\n\" +\n        \"    try {\\n\" +\n        \"      proto = new Proto\\n\" +\n        \"    } finally {\\n\" +\n        \"      action = proto;\\n\" +\n        \"      break a\\n\" +  // Keep this...\n        \"    }\\n\" +\n        \"  }\\n\" +\n        \"  alert(action)\\n\" + // and this.\n        \"};\");\n  }\n", "  public void testIssue4177428c() {\n    testSame(\n        \"f = function() {\\n\" +\n        \"  var action;\\n\" +\n        \"  a: {\\n\" +\n        \"    var proto = null;\\n\" +\n        \"    try {\\n\" +\n        \"    } finally {\\n\" +\n        \"    try {\\n\" +\n        \"      proto = new Proto\\n\" +\n        \"    } finally {\\n\" +\n        \"      action = proto;\\n\" +\n        \"      break a\\n\" +  // Keep this...\n        \"    }\\n\" +\n        \"    }\\n\" +\n        \"  }\\n\" +\n        \"  alert(action)\\n\" + // and this.\n        \"};\");\n  }\n", "  public void testIssue4177428_continue() {\n    testSame(\n        \"f = function() {\\n\" +\n        \"  var action;\\n\" +\n        \"  a: do {\\n\" +\n        \"    var proto = null;\\n\" +\n        \"    try {\\n\" +\n        \"      proto = new Proto\\n\" +\n        \"    } finally {\\n\" +\n        \"      action = proto;\\n\" +\n        \"      continue a\\n\" +  // Keep this...\n        \"    }\\n\" +\n        \"  } while(false)\\n\" +\n        \"  alert(action)\\n\" + // and this.\n        \"};\");\n  }\n", "  public void testIssue4177428_return() {\n    test(\n        \"f = function() {\\n\" +\n        \"  var action;\\n\" +\n        \"  a: {\\n\" +\n        \"    var proto = null;\\n\" +\n        \"    try {\\n\" +\n        \"      proto = new Proto\\n\" +\n        \"    } finally {\\n\" +\n        \"      action = proto;\\n\" +\n        \"      return\\n\" +  // Keep this...\n        \"    }\\n\" +\n        \"  }\\n\" +\n        \"  alert(action)\\n\" + // and remove this.\n        \"};\",\n        \"f = function() {\\n\" +\n        \"  var action;\\n\" +\n        \"  a: {\\n\" +\n        \"    var proto = null;\\n\" +\n        \"    try {\\n\" +\n        \"      proto = new Proto\\n\" +\n        \"    } finally {\\n\" +\n        \"      action = proto;\\n\" +\n        \"      return\\n\" +\n        \"    }\\n\" +\n        \"  }\\n\" +\n        \"};\"\n        );\n  }\n", "  public void testDontRemoveBreakInTryFinally() throws Exception {\n    testSame(\"function f() {b:try{throw 9} finally {break b} return 1;}\");\n  }\n", "  public void testDontRemoveBreakInTryFinallySwitch() throws Exception {\n    testSame(\"function f() {b:try{throw 9} finally {switch(x) {case 1: break b} } return 1;}\");\n  }\n"], "Time_17": ["    public void testBug3476684_adjustOffset() {\n        final DateTimeZone zone = DateTimeZone.forID(\"America/Sao_Paulo\");\n        DateTime base = new DateTime(2012, 2, 25, 22, 15, zone);\n        DateTime baseBefore = base.plusHours(1);  // 23:15 (first)\n        DateTime baseAfter = base.plusHours(2);  // 23:15 (second)\n        \n        assertSame(base, base.withEarlierOffsetAtOverlap());\n        assertSame(base, base.withLaterOffsetAtOverlap());\n        \n        assertSame(baseBefore, baseBefore.withEarlierOffsetAtOverlap());\n        assertEquals(baseAfter, baseBefore.withLaterOffsetAtOverlap());\n        \n        assertSame(baseAfter, baseAfter.withLaterOffsetAtOverlap());\n        assertEquals(baseBefore, baseAfter.withEarlierOffsetAtOverlap());\n    }\n", "    public void testBug3476684_adjustOffset_springGap() {\n      final DateTimeZone zone = DateTimeZone.forID(\"America/Sao_Paulo\");\n      DateTime base = new DateTime(2011, 10, 15, 22, 15, zone);\n      DateTime baseBefore = base.plusHours(1);  // 23:15\n      DateTime baseAfter = base.plusHours(2);  // 01:15\n      \n      assertSame(base, base.withEarlierOffsetAtOverlap());\n      assertSame(base, base.withLaterOffsetAtOverlap());\n      \n      assertSame(baseBefore, baseBefore.withEarlierOffsetAtOverlap());\n      assertEquals(baseBefore, baseBefore.withLaterOffsetAtOverlap());\n      \n      assertSame(baseAfter, baseAfter.withLaterOffsetAtOverlap());\n      assertEquals(baseAfter, baseAfter.withEarlierOffsetAtOverlap());\n  }\n"], "Closure_54": ["  public void testIssue537a() throws Exception {\n    testTypes(\n        \"/** @constructor */ function Foo() {}\" +\n        \"Foo.prototype = {method: function() {}};\" +\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" * @extends {Foo}\\n\" +\n        \" */\\n\" +\n        \"function Bar() {\" +\n        \"  Foo.call(this);\" +\n        \"  if (this.baz()) this.method(1);\" +\n        \"}\" +\n        \"Bar.prototype = {\" +\n        \"  baz: function() {\" +\n        \"    return true;\" +\n        \"  }\" +\n        \"};\" +\n        \"Bar.prototype.__proto__ = Foo.prototype;\",\n        \"Function Foo.prototype.method: called with 1 argument(s). \" +\n        \"Function requires at least 0 argument(s) \" +\n        \"and no more than 0 argument(s).\");\n  }\n", "  public void testIssue537b() throws Exception {\n    testTypes(\n        \"/** @constructor */ function Foo() {}\" +\n        \"Foo.prototype = {method: function() {}};\" +\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" * @extends {Foo}\\n\" +\n        \" */\\n\" +\n        \"function Bar() {\" +\n        \"  Foo.call(this);\" +\n        \"  if (this.baz(1)) this.method();\" +\n        \"}\" +\n        \"Bar.prototype = {\" +\n        \"  baz: function() {\" +\n        \"    return true;\" +\n        \"  }\" +\n        \"};\" +\n        \"Bar.prototype.__proto__ = Foo.prototype;\",\n        \"Function Bar.prototype.baz: called with 1 argument(s). \" +\n        \"Function requires at least 0 argument(s) \" +\n        \"and no more than 0 argument(s).\");\n  }\n", "  public void testPropertyOnUnknownSuperClass2() {\n    testSame(\n        \"var goog = this.foo();\" +\n        \"/** @constructor \\n * @extends {goog.Unknown} */\" +\n        \"function Foo() {}\" +\n        \"Foo.prototype = {bar: 1};\" +\n        \"var x = new Foo();\",\n        RhinoErrorReporter.TYPE_PARSE_ERROR);\n    ObjectType x = (ObjectType) findNameType(\"x\", globalScope);\n    assertEquals(\"Foo\", x.toString());\n    assertEquals(\"Foo.prototype\", x.getImplicitPrototype().toString());\n    assertTrue(x.getImplicitPrototype().hasOwnProperty(\"bar\"));\n    assertEquals(\"?\", x.getPropertyType(\"bar\").toString());\n    assertTrue(x.isPropertyTypeInferred(\"bar\"));\n  }\n"], "Lang_26": ["    public void testLang645() {\n        Locale locale = new Locale(\"sv\", \"SE\");\n\n        Calendar cal = Calendar.getInstance();\n        cal.set(2010, 0, 1, 12, 0, 0);\n        Date d = cal.getTime();\n\n        FastDateFormat fdf = FastDateFormat.getInstance(\"EEEE', week 'ww\", locale);\n\n        assertEquals(\"fredag, week 53\", fdf.format(d));\n    }\n"], "Closure_98": ["  public void testNoInlineAliasesInLoop() {\n    testSame(\n        \"function f() { \" +\n        \"  for (var i = 0; i < 5; i++) {\" +\n        \"    var x = extern();\" +\n        \"    (function() {\" +\n        \"       var y = x; window.setTimeout(function() { extern(y); }, 0);\" +\n        \"     })();\" +\n        \"  }\" +\n        \"}\");\n  }\n"], "Closure_53": ["  public void testBug545() {\n    testLocal(\"var a = {}\", \"\");\n    testLocal(\"var a; a = {}\", \"true\");\n  }\n"], "Time_10": ["    public void testFactory_daysBetween_RPartial_MonthDay() {\n        MonthDay start1 = new MonthDay(2, 1);\n        MonthDay start2 = new MonthDay(2, 28);\n        MonthDay end1 = new MonthDay(2, 28);\n        MonthDay end2 = new MonthDay(2, 29);\n        \n        assertEquals(27, Days.daysBetween(start1, end1).getDays());\n        assertEquals(28, Days.daysBetween(start1, end2).getDays());\n        assertEquals(0, Days.daysBetween(start2, end1).getDays());\n        assertEquals(1, Days.daysBetween(start2, end2).getDays());\n        \n        assertEquals(-27, Days.daysBetween(end1, start1).getDays());\n        assertEquals(-28, Days.daysBetween(end2, start1).getDays());\n        assertEquals(0, Days.daysBetween(end1, start2).getDays());\n        assertEquals(-1, Days.daysBetween(end2, start2).getDays());\n    }\n", "    public void testFactory_monthsBetween_RPartial_MonthDay() {\n        MonthDay start = new MonthDay(2, 1);\n        MonthDay end1 = new MonthDay(2, 28);\n        MonthDay end2 = new MonthDay(2, 29);\n        MonthDay end3 = new MonthDay(3, 1);\n        \n        assertEquals(0, Months.monthsBetween(start, end1).getMonths());\n        assertEquals(0, Months.monthsBetween(start, end2).getMonths());\n        assertEquals(1, Months.monthsBetween(start, end3).getMonths());\n        \n        assertEquals(0, Months.monthsBetween(end1, start).getMonths());\n        assertEquals(0, Months.monthsBetween(end2, start).getMonths());\n        assertEquals(-1, Months.monthsBetween(end3, start).getMonths());\n    }\n"], "Lang_19": ["    public void testOutOfBounds() {\n        NumericEntityUnescaper neu = new NumericEntityUnescaper();\n\n        assertEquals(\"Failed to ignore when last character is &\", \"Test &\", neu.translate(\"Test &\"));\n        assertEquals(\"Failed to ignore when last character is &\", \"Test &#\", neu.translate(\"Test &#\"));\n        assertEquals(\"Failed to ignore when last character is &\", \"Test &#x\", neu.translate(\"Test &#x\"));\n        assertEquals(\"Failed to ignore when last character is &\", \"Test &#X\", neu.translate(\"Test &#X\"));\n    }\n", "    public void testUnfinishedEntity() {\n        NumericEntityUnescaper neu = new NumericEntityUnescaper();\n        String input = \"Test &#x30 not test\";\n        String expected = \"Test \\u0030 not test\";\n\n        String result = neu.translate(input);\n        assertEquals(\"Failed to support unfinished entities (i.e. missing semi-colon\", expected, result);\n    }\n"], "Closure_120": ["  public void testExternalIssue1053() {\n    testSame(\n        \"var u; function f() { u = Random(); var x = u; f(); alert(x===u)}\");\n  }\n"], "Time_19": ["    public void testDateTimeCreation_london() {\n        DateTimeZone zone = DateTimeZone.forID(\"Europe/London\");\n        DateTime base = new DateTime(2011, 10, 30, 1, 15, zone);\n        assertEquals(\"2011-10-30T01:15:00.000+01:00\", base.toString());\n        assertEquals(\"2011-10-30T01:15:00.000Z\", base.plusHours(1).toString());\n    }\n"], "Closure_129": ["  public void testIssue937() {\n    CompilerOptions options = createCompilerOptions();\n    CompilationLevel level = CompilationLevel.SIMPLE_OPTIMIZATIONS;\n    level.setOptionsForCompilationLevel(options);\n    WarningLevel warnings = WarningLevel.DEFAULT;\n    warnings.setOptionsForWarningLevel(options);\n\n    String code = \"\" +\n        \"console.log(\" +\n            \"/** @type {function():!string} */ ((new x())['abc'])() );\";\n    String result = \"\" +\n        \"console.log((new x()).abc());\";\n    test(options, code, result);\n  }\n"], "Lang_10": ["    @Test\n    public void testLANG_831() throws Exception {\n        testSdfAndFdp(\"M E\",\"3  Tue\", true);\n    }\n"], "Closure_65": ["  public void testZero() {\n    assertPrint(\"var x ='\\\\0';\", \"var x=\\\"\\\\000\\\"\");\n    assertPrint(\"var x ='\\\\x00';\", \"var x=\\\"\\\\000\\\"\");\n    assertPrint(\"var x ='\\\\u0000';\", \"var x=\\\"\\\\000\\\"\");\n    assertPrint(\"var x ='\\\\u00003';\", \"var x=\\\"\\\\0003\\\"\");\n  }\n"], "Closure_116": ["  public void testIssue1101a() {\n    helperCanInlineReferenceToFunction(CanInlineResult.NO,\n        \"function foo(a){return modifiyX() + a;} foo(x);\", \"foo\",\n        INLINE_DIRECT);\n  }\n", "  public void testIssue1101b() {\n    helperCanInlineReferenceToFunction(CanInlineResult.NO,\n        \"function foo(a){return (x.prop = 2),a;} foo(x.prop);\", \"foo\",\n        INLINE_DIRECT);\n  }\n", "  public void testInlineFunctions6() {\n    // more complex inlines\n    test(\"function BAR_FN(x, y, z) { return z(nochg(x + y)) }\" +\n         \"alert(BAR_FN(1, 2, baz))\",\n\n         \"var JSCompiler_temp_const$$0=alert;\" +\n         \"var JSCompiler_inline_result$$1;\" +\n         \"{JSCompiler_inline_result$$1=baz(nochg(1+2));}\" +\n         \"JSCompiler_temp_const$$0(JSCompiler_inline_result$$1)\");\n  }\n", "  public void testInlineIfParametersModified8() {\n    // OK, object parameter modified.\n    test(\"function f(a){return a.x=2}f(o)\", \"{o.x=2}\");\n  }\n", "  public void testInlineIfParametersModified9() {\n    // OK, array parameter modified.\n    test(\"function f(a){return a[2]=2}f(o)\", \"{o[2]=2}\");\n  }\n", "  public void testDoubleInlining2() {\n    test(\"var foo = function(a) { return getWindow(a); };\" +\n         \"var bar = function(b) { return b; };\" +\n         \"foo(bar(x));\",\n         \"{getWindow(x)}\");\n  }\n", "  public void testBug4944818() {\n    test(\n        \"var getDomServices_ = function(self) {\\n\" +\n        \"  if (!self.domServices_) {\\n\" +\n        \"    self.domServices_ = goog$component$DomServices.get(\" +\n        \"        self.appContext_);\\n\" +\n        \"  }\\n\" +\n        \"\\n\" +\n        \"  return self.domServices_;\\n\" +\n        \"};\\n\" +\n        \"\\n\" +\n        \"var getOwnerWin_ = function(self) {\\n\" +\n        \"  return getDomServices_(self).getDomHelper().getWindow();\\n\" +\n        \"};\\n\" +\n        \"\\n\" +\n        \"HangoutStarter.prototype.launchHangout = function() {\\n\" +\n        \"  var self = a.b;\\n\" +\n        \"  var myUrl = new goog.Uri(getOwnerWin_(self).location.href);\\n\" +\n        \"};\",\n        \"HangoutStarter.prototype.launchHangout=function(){\" +\n        \"  var self$$2=a.b;\" +\n        \"  var JSCompiler_temp_const$$0=goog.Uri;\" +\n        \"  var JSCompiler_inline_result$$1;\" +\n        \"  {\" +\n        \"    var JSCompiler_inline_result$$0;\" +\n        \"    {\" +\n        \"      var self$$inline_1=self$$2;\" +\n        \"      if(!self$$inline_1.domServices_) {\" +\n        \"        self$$inline_1.domServices_=goog$component$DomServices.get(self$$inline_1.appContext_);\" +\n        \"      }\" +\n        \"      JSCompiler_inline_result$$0=self$$inline_1.domServices_;\" +\n        \"    }\" +\n        \"    JSCompiler_inline_result$$1=JSCompiler_inline_result$$0.getDomHelper().getWindow();\" +\n        \"  }\" +\n        \"  var myUrl=new JSCompiler_temp_const$$0(JSCompiler_inline_result$$1.location.href)\" +\n        \"}\");\n  }\n", "  public void testIssue1101() {\n    test(\n        \"var x = (function (saved) {\" +\n        \"    return foo(obj) + saved;\" +\n        \"  })(obj[\\\"prop\\\"]);\",\n        \"var x;\" +\n        \"{\" +\n        \"  var saved$$inline_0=obj[\\\"prop\\\"];x=foo(obj)+saved$$inline_0\" +\n        \"}\");\n  }\n"], "Closure_91": ["  public void testLendsAnnotation3() {\n    testSame(\"/** @constructor */ function F() {}\" +\n        \"dojo.declare(F, /** @lends {F.prototype} */ (\" +\n        \"    {foo: function() { return this.foo; }}));\");\n  }\n"], "Time_26": ["    public void testWithMinuteOfHourInDstChange_mockZone() {\n        DateTime cutover = new DateTime(2010, 10, 31, 1, 15, DateTimeZone.forOffsetHoursMinutes(0, 30));\n        assertEquals(\"2010-10-31T01:15:00.000+00:30\", cutover.toString());\n        DateTimeZone halfHourZone = new MockZone(cutover.getMillis(), 3600000, -1800);\n        DateTime pre = new DateTime(2010, 10, 31, 1, 0, halfHourZone);\n        assertEquals(\"2010-10-31T01:00:00.000+01:00\", pre.toString());\n        DateTime post = new DateTime(2010, 10, 31, 1, 59, halfHourZone);\n        assertEquals(\"2010-10-31T01:59:00.000+00:30\", post.toString());\n        \n        DateTime testPre1 = pre.withMinuteOfHour(30);\n        assertEquals(\"2010-10-31T01:30:00.000+01:00\", testPre1.toString());  // retain offset\n        DateTime testPre2 = pre.withMinuteOfHour(50);\n        assertEquals(\"2010-10-31T01:50:00.000+00:30\", testPre2.toString());\n        \n        DateTime testPost1 = post.withMinuteOfHour(30);\n        assertEquals(\"2010-10-31T01:30:00.000+00:30\", testPost1.toString());  // retain offset\n        DateTime testPost2 = post.withMinuteOfHour(10);\n        assertEquals(\"2010-10-31T01:10:00.000+01:00\", testPost2.toString());\n    }\n", "    public void testWithHourOfDayInDstChange() {\n        DateTime dateTime = new DateTime(\"2010-10-31T02:30:10.123+02:00\", ZONE_PARIS);\n        assertEquals(\"2010-10-31T02:30:10.123+02:00\", dateTime.toString());\n        DateTime test = dateTime.withHourOfDay(2);\n        assertEquals(\"2010-10-31T02:30:10.123+02:00\", test.toString());\n    }\n", "    public void testWithMinuteOfHourInDstChange() {\n        DateTime dateTime = new DateTime(\"2010-10-31T02:30:10.123+02:00\", ZONE_PARIS);\n        assertEquals(\"2010-10-31T02:30:10.123+02:00\", dateTime.toString());\n        DateTime test = dateTime.withMinuteOfHour(0);\n        assertEquals(\"2010-10-31T02:00:10.123+02:00\", test.toString());\n    }\n", "    public void testWithSecondOfMinuteInDstChange() {\n        DateTime dateTime = new DateTime(\"2010-10-31T02:30:10.123+02:00\", ZONE_PARIS);\n        assertEquals(\"2010-10-31T02:30:10.123+02:00\", dateTime.toString());\n        DateTime test = dateTime.withSecondOfMinute(0);\n        assertEquals(\"2010-10-31T02:30:00.123+02:00\", test.toString());\n    }\n", "    public void testWithMillisOfSecondInDstChange_Paris_summer() {\n        DateTime dateTime = new DateTime(\"2010-10-31T02:30:10.123+02:00\", ZONE_PARIS);\n        assertEquals(\"2010-10-31T02:30:10.123+02:00\", dateTime.toString());\n        DateTime test = dateTime.withMillisOfSecond(0);\n        assertEquals(\"2010-10-31T02:30:10.000+02:00\", test.toString());\n    }\n", "    public void testWithMillisOfSecondInDstChange_NewYork_winter() {\n        DateTime dateTime = new DateTime(\"2007-11-04T01:30:00.123-05:00\", ZONE_NEW_YORK);\n        assertEquals(\"2007-11-04T01:30:00.123-05:00\", dateTime.toString());\n        DateTime test = dateTime.withMillisOfSecond(0);\n        assertEquals(\"2007-11-04T01:30:00.000-05:00\", test.toString());\n    }\n", "    public void testBug2182444_usCentral() {\n        Chronology chronUSCentral = GregorianChronology.getInstance(DateTimeZone.forID(\"US/Central\"));\n        Chronology chronUTC = GregorianChronology.getInstance(DateTimeZone.UTC);\n        DateTime usCentralStandardInUTC = new DateTime(2008, 11, 2, 7, 0, 0, 0, chronUTC);\n        DateTime usCentralDaylightInUTC = new DateTime(2008, 11, 2, 6, 0, 0, 0, chronUTC);\n        assertTrue(\"Should be standard time\", chronUSCentral.getZone().isStandardOffset(usCentralStandardInUTC.getMillis()));\n        assertFalse(\"Should be daylight time\", chronUSCentral.getZone().isStandardOffset(usCentralDaylightInUTC.getMillis()));\n        \n        DateTime usCentralStandardInUSCentral = usCentralStandardInUTC.toDateTime(chronUSCentral);\n        DateTime usCentralDaylightInUSCentral = usCentralDaylightInUTC.toDateTime(chronUSCentral);\n        assertEquals(1, usCentralStandardInUSCentral.getHourOfDay());\n        assertEquals(usCentralStandardInUSCentral.getHourOfDay(), usCentralDaylightInUSCentral.getHourOfDay());\n        assertTrue(usCentralStandardInUSCentral.getMillis() != usCentralDaylightInUSCentral.getMillis());\n        assertEquals(usCentralStandardInUSCentral, usCentralStandardInUSCentral.withHourOfDay(1));\n        assertEquals(usCentralStandardInUSCentral.getMillis() + 3, usCentralStandardInUSCentral.withMillisOfSecond(3).getMillis());\n        assertEquals(usCentralDaylightInUSCentral, usCentralDaylightInUSCentral.withHourOfDay(1));\n        assertEquals(usCentralDaylightInUSCentral.getMillis() + 3, usCentralDaylightInUSCentral.withMillisOfSecond(3).getMillis());\n    }\n", "    public void testBug2182444_ausNSW() {\n        Chronology chronAusNSW = GregorianChronology.getInstance(DateTimeZone.forID(\"Australia/NSW\"));\n        Chronology chronUTC = GregorianChronology.getInstance(DateTimeZone.UTC);\n        DateTime australiaNSWStandardInUTC = new DateTime(2008, 4, 5, 16, 0, 0, 0, chronUTC);\n        DateTime australiaNSWDaylightInUTC = new DateTime(2008, 4, 5, 15, 0, 0, 0, chronUTC);\n        assertTrue(\"Should be standard time\", chronAusNSW.getZone().isStandardOffset(australiaNSWStandardInUTC.getMillis()));\n        assertFalse(\"Should be daylight time\", chronAusNSW.getZone().isStandardOffset(australiaNSWDaylightInUTC.getMillis()));\n        \n        DateTime australiaNSWStandardInAustraliaNSW = australiaNSWStandardInUTC.toDateTime(chronAusNSW);\n        DateTime australiaNSWDaylightInAusraliaNSW = australiaNSWDaylightInUTC.toDateTime(chronAusNSW);\n        assertEquals(2, australiaNSWStandardInAustraliaNSW.getHourOfDay());\n        assertEquals(australiaNSWStandardInAustraliaNSW.getHourOfDay(), australiaNSWDaylightInAusraliaNSW.getHourOfDay());\n        assertTrue(australiaNSWStandardInAustraliaNSW.getMillis() != australiaNSWDaylightInAusraliaNSW.getMillis());\n        assertEquals(australiaNSWStandardInAustraliaNSW, australiaNSWStandardInAustraliaNSW.withHourOfDay(2));\n        assertEquals(australiaNSWStandardInAustraliaNSW.getMillis() + 3, australiaNSWStandardInAustraliaNSW.withMillisOfSecond(3).getMillis());\n        assertEquals(australiaNSWDaylightInAusraliaNSW, australiaNSWDaylightInAusraliaNSW.withHourOfDay(2));\n        assertEquals(australiaNSWDaylightInAusraliaNSW.getMillis() + 3, australiaNSWDaylightInAusraliaNSW.withMillisOfSecond(3).getMillis());\n    }\n"], "Lang_17": ["    public void testLang720() {\n        String input = new StringBuilder(\"\\ud842\\udfb7\").append(\"A\").toString();\n        String escaped = StringEscapeUtils.escapeXml(input);\n        assertEquals(input, escaped);\n    }\n"], "Closure_111": ["  public void testGoogIsArray2() throws Exception {\n    testClosureFunction(\"goog.isArray\",\n        ALL_TYPE,\n        ARRAY_TYPE,\n        ALL_TYPE);\n  }\n"], "Lang_28": ["    public void testSupplementaryUnescaping() {\n        NumericEntityUnescaper neu = new NumericEntityUnescaper();\n        String input = \"&#68642;\";\n        String expected = \"\\uD803\\uDC22\";\n\n        String result = neu.translate(input);\n        assertEquals(\"Failed to unescape numeric entities supplementary characters\", expected, result);\n    }\n"], "Closure_96": ["  public void testFunctionArguments16() throws Exception {\n    testTypes(\n        \"/** @param {...number} var_args */\" +\n        \"function g(var_args) {} g(1, true);\",\n        \"actual parameter 2 of g does not match formal parameter\\n\" +\n        \"found   : boolean\\n\" +\n        \"required: (number|undefined)\");\n  }\n"], "Closure_62": ["  public void testFormatErrorSpaceEndOfLine1() throws Exception {\n    JSError error = JSError.make(\"javascript/complex.js\",\n        1, 10, FOO_TYPE);\n    LightweightMessageFormatter formatter = formatter(\"assert (1;\");\n    assertEquals(\"javascript/complex.js:1: ERROR - error description here\\n\" +\n        \"assert (1;\\n\" +\n        \"          ^\\n\", formatter.formatError(error));\n  }\n", "  public void testFormatErrorSpaceEndOfLine2() throws Exception {\n    JSError error = JSError.make(\"javascript/complex.js\",\n        6, 7, FOO_TYPE);\n    LightweightMessageFormatter formatter = formatter(\"if (foo\");\n    assertEquals(\"javascript/complex.js:6: ERROR - error description here\\n\" +\n        \"if (foo\\n\" +\n        \"       ^\\n\", formatter.formatError(error));\n  }\n"], "Closure_36": ["  public void testSingletonGetter1() {\n    CompilerOptions options = createCompilerOptions();\n    CompilationLevel.ADVANCED_OPTIMIZATIONS\n        .setOptionsForCompilationLevel(options);\n    options.setCodingConvention(new ClosureCodingConvention());\n    test(options,\n        \"/** @const */\\n\" +\n        \"var goog = goog || {};\\n\" +\n        \"goog.addSingletonGetter = function(ctor) {\\n\" +\n        \"  ctor.getInstance = function() {\\n\" +\n        \"    return ctor.instance_ || (ctor.instance_ = new ctor());\\n\" +\n        \"  };\\n\" +\n        \"};\" +\n        \"function Foo() {}\\n\" +\n        \"goog.addSingletonGetter(Foo);\" +\n        \"Foo.prototype.bar = 1;\" +\n        \"function Bar() {}\\n\" +\n        \"goog.addSingletonGetter(Bar);\" +\n        \"Bar.prototype.bar = 1;\",\n        \"\");\n  }\n"], "Lang_43": ["    public void testEscapedQuote_LANG_477() {\n        String pattern = \"it''s a {0,lower} 'test'!\";\n        ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry);\n        assertEquals(\"it's a dummy test!\", emf.format(new Object[] {\"DUMMY\"}));\n    }\n"], "Closure_31": ["  public void testDependencySortingWhitespaceMode() {\n    args.add(\"--manage_closure_dependencies\");\n    args.add(\"--compilation_level=WHITESPACE_ONLY\");\n    test(new String[] {\n          \"goog.require('beer');\",\n          \"goog.provide('beer');\\ngoog.require('hops');\",\n          \"goog.provide('hops');\",\n         },\n         new String[] {\n          \"goog.provide('hops');\",\n          \"goog.provide('beer');\\ngoog.require('hops');\",\n          \"goog.require('beer');\"\n         });\n  }\n"], "Lang_44": ["    public void testLang457() {\n        String[] badInputs = new String[] { \"l\", \"L\", \"f\", \"F\", \"junk\", \"bobL\"};\n        for(int i=0; i<badInputs.length; i++) {\n            try {\n                NumberUtils.createNumber(badInputs[i]);\n                fail(\"NumberFormatException was expected for \" + badInputs[i]);\n            } catch (NumberFormatException e) {\n                return; // expected\n            }\n        }\n    }\n"], "Closure_38": ["  public void testMinusNegativeZero() {\n    // Negative zero is weird, because we have to be able to distinguish\n    // it from positive zero (there are some subtle differences in behavior).\n    assertPrint(\"x- -0\", \"x- -0.0\");\n  }\n"], "Math_65": ["    public void testCircleFitting() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        assertTrue(optimizer.getEvaluations() < 10);\n        assertTrue(optimizer.getJacobianEvaluations() < 10);\n        double rms = optimizer.getRMS();\n        assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);\n        assertEquals(96.07590211815305, center.x,      1.0e-10);\n        assertEquals(48.13516790438953, center.y,      1.0e-10);\n        double[][] cov = optimizer.getCovariances();\n        assertEquals(1.839, cov[0][0], 0.001);\n        assertEquals(0.731, cov[0][1], 0.001);\n        assertEquals(cov[0][1], cov[1][0], 1.0e-14);\n        assertEquals(0.786, cov[1][1], 0.001);\n        double[] errors = optimizer.guessParametersErrors();\n        assertEquals(1.384, errors[0], 0.001);\n        assertEquals(0.905, errors[1], 0.001);\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        assertEquals(0.0016, cov[0][0], 0.001);\n        assertEquals(3.2e-7, cov[0][1], 1.0e-9);\n        assertEquals(cov[0][1], cov[1][0], 1.0e-14);\n        assertEquals(0.0016, cov[1][1], 0.001);\n        errors = optimizer.guessParametersErrors();\n        assertEquals(0.004, errors[0], 0.001);\n        assertEquals(0.004, errors[1], 0.001);\n\n    }\n", "    public void testCircleFittingBadInit() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        double[][] points = new double[][] {\n                {-0.312967,  0.072366}, {-0.339248,  0.132965}, {-0.379780,  0.202724},\n                {-0.390426,  0.260487}, {-0.361212,  0.328325}, {-0.346039,  0.392619},\n                {-0.280579,  0.444306}, {-0.216035,  0.470009}, {-0.149127,  0.493832},\n                {-0.075133,  0.483271}, {-0.007759,  0.452680}, { 0.060071,  0.410235},\n                { 0.103037,  0.341076}, { 0.118438,  0.273884}, { 0.131293,  0.192201},\n                { 0.115869,  0.129797}, { 0.072223,  0.058396}, { 0.022884,  0.000718},\n                {-0.053355, -0.020405}, {-0.123584, -0.032451}, {-0.216248, -0.032862},\n                {-0.278592, -0.005008}, {-0.337655,  0.056658}, {-0.385899,  0.112526},\n                {-0.405517,  0.186957}, {-0.415374,  0.262071}, {-0.387482,  0.343398},\n                {-0.347322,  0.397943}, {-0.287623,  0.458425}, {-0.223502,  0.475513},\n                {-0.135352,  0.478186}, {-0.061221,  0.483371}, { 0.003711,  0.422737},\n                { 0.065054,  0.375830}, { 0.108108,  0.297099}, { 0.123882,  0.222850},\n                { 0.117729,  0.134382}, { 0.085195,  0.056820}, { 0.029800, -0.019138},\n                {-0.027520, -0.072374}, {-0.102268, -0.091555}, {-0.200299, -0.106578},\n                {-0.292731, -0.091473}, {-0.356288, -0.051108}, {-0.420561,  0.014926},\n                {-0.471036,  0.074716}, {-0.488638,  0.182508}, {-0.485990,  0.254068},\n                {-0.463943,  0.338438}, {-0.406453,  0.404704}, {-0.334287,  0.466119},\n                {-0.254244,  0.503188}, {-0.161548,  0.495769}, {-0.075733,  0.495560},\n                { 0.001375,  0.434937}, { 0.082787,  0.385806}, { 0.115490,  0.323807},\n                { 0.141089,  0.223450}, { 0.138693,  0.131703}, { 0.126415,  0.049174},\n                { 0.066518, -0.010217}, {-0.005184, -0.070647}, {-0.080985, -0.103635},\n                {-0.177377, -0.116887}, {-0.260628, -0.100258}, {-0.335756, -0.056251},\n                {-0.405195, -0.000895}, {-0.444937,  0.085456}, {-0.484357,  0.175597},\n                {-0.472453,  0.248681}, {-0.438580,  0.347463}, {-0.402304,  0.422428},\n                {-0.326777,  0.479438}, {-0.247797,  0.505581}, {-0.152676,  0.519380},\n                {-0.071754,  0.516264}, { 0.015942,  0.472802}, { 0.076608,  0.419077},\n                { 0.127673,  0.330264}, { 0.159951,  0.262150}, { 0.153530,  0.172681},\n                { 0.140653,  0.089229}, { 0.078666,  0.024981}, { 0.023807, -0.037022},\n                {-0.048837, -0.077056}, {-0.127729, -0.075338}, {-0.221271, -0.067526}\n        };\n        double[] target = new double[points.length];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[points.length];\n        Arrays.fill(weights, 2.0);\n        for (int i = 0; i < points.length; ++i) {\n            circle.addPoint(points[i][0], points[i][1]);\n        }\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-8, 1.0e-8));\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, target, weights, new double[] { -12, -12 });\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        assertTrue(optimizer.getEvaluations() < 25);\n        assertTrue(optimizer.getJacobianEvaluations() < 20);\n        assertEquals( 0.043, optimizer.getRMS(), 1.0e-3);\n        assertEquals( 0.292235,  circle.getRadius(center), 1.0e-6);\n        assertEquals(-0.151738,  center.x,      1.0e-6);\n        assertEquals( 0.2075001, center.y,      1.0e-6);\n    }\n"], "Math_91": ["    public void testCompareTo() {\n        Fraction first = new Fraction(1, 2);\n        Fraction second = new Fraction(1, 3);\n        Fraction third = new Fraction(1, 2);\n        \n        assertEquals(0, first.compareTo(first));\n        assertEquals(0, first.compareTo(third));\n        assertEquals(1, first.compareTo(second));\n        assertEquals(-1, second.compareTo(first));\n\n        // these two values are different approximations of PI\n        // the first  one is approximately PI - 3.07e-18\n        // the second one is approximately PI + 1.936e-17\n        Fraction pi1 = new Fraction(1068966896, 340262731);\n        Fraction pi2 = new Fraction( 411557987, 131002976);\n        assertEquals(-1, pi1.compareTo(pi2));\n        assertEquals( 1, pi2.compareTo(pi1));\n        assertEquals(0.0, pi1.doubleValue() - pi2.doubleValue(), 1.0e-20);\n    }\n"], "Chart_5": ["    public void testBug1955483() {\n        XYSeries series = new XYSeries(\"Series\", true, true);\n        series.addOrUpdate(1.0, 1.0);\n        series.addOrUpdate(1.0, 2.0);\n        assertEquals(new Double(1.0), series.getY(0));\n        assertEquals(new Double(2.0), series.getY(1));\n        assertEquals(2, series.getItemCount());\n    }\n"], "Math_96": ["    public void testMath221() {\n        assertEquals(new Complex(0,-1), new Complex(0,1).multiply(new Complex(-1,0)));\n    }\n"], "Math_62": ["    @Test\n    public void testQuinticMin() throws MathException {\n        // The quintic function has zeros at 0, +-0.5 and +-1.\n        // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,\n        UnivariateRealFunction f = new QuinticFunction();\n        UnivariateRealOptimizer underlying = new BrentOptimizer(1e-9, 1e-14);\n        underlying.setMaxEvaluations(300);\n        JDKRandomGenerator g = new JDKRandomGenerator();\n        g.setSeed(4312000053L);\n        MultiStartUnivariateRealOptimizer optimizer =\n            new MultiStartUnivariateRealOptimizer(underlying, 5, g);\n\n        UnivariateRealPointValuePair optimum\n            = optimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2);\n        assertEquals(-0.2719561293, optimum.getPoint(), 1e-9);\n        assertEquals(-0.0443342695, optimum.getValue(), 1e-9);\n\n        UnivariateRealPointValuePair[] optima = optimizer.getOptima();\n        for (int i = 0; i < optima.length; ++i) {\n            assertEquals(f.value(optima[i].getPoint()), optima[i].getValue(), 1e-9);\n        }\n        assertTrue(optimizer.getEvaluations() >= 50);\n        assertTrue(optimizer.getEvaluations() <= 100);\n    }\n"], "Chart_2": ["    public void testBug2849731_2() {\n        XYIntervalSeriesCollection d = new XYIntervalSeriesCollection();\n        XYIntervalSeries s = new XYIntervalSeries(\"S1\");\n        s.add(1.0, Double.NaN, Double.NaN, Double.NaN, 1.5, Double.NaN);\n        d.addSeries(s);\n        Range r = DatasetUtilities.iterateDomainBounds(d);\n        assertEquals(1.0, r.getLowerBound(), EPSILON);\n        assertEquals(1.0, r.getUpperBound(), EPSILON);\n\n        s.add(1.0, 1.5, Double.NaN, Double.NaN, 1.5, Double.NaN);\n        r = DatasetUtilities.iterateDomainBounds(d);\n        assertEquals(1.0, r.getLowerBound(), EPSILON);\n        assertEquals(1.5, r.getUpperBound(), EPSILON);\n\n        s.add(1.0, Double.NaN, 0.5, Double.NaN, 1.5, Double.NaN);\n        r = DatasetUtilities.iterateDomainBounds(d);\n        assertEquals(0.5, r.getLowerBound(), EPSILON);\n        assertEquals(1.5, r.getUpperBound(), EPSILON);\n    }\n", "    public void testBug2849731_3() {\n        XYIntervalSeriesCollection d = new XYIntervalSeriesCollection();\n        XYIntervalSeries s = new XYIntervalSeries(\"S1\");\n        s.add(1.0, Double.NaN, Double.NaN, 1.5, Double.NaN, Double.NaN);\n        d.addSeries(s);\n        Range r = DatasetUtilities.iterateRangeBounds(d);\n        assertEquals(1.5, r.getLowerBound(), EPSILON);\n        assertEquals(1.5, r.getUpperBound(), EPSILON);\n\n        s.add(1.0, 1.5, Double.NaN, Double.NaN, Double.NaN, 2.5);\n        r = DatasetUtilities.iterateRangeBounds(d);\n        assertEquals(1.5, r.getLowerBound(), EPSILON);\n        assertEquals(2.5, r.getUpperBound(), EPSILON);\n\n        s.add(1.0, Double.NaN, 0.5, Double.NaN, 3.5, Double.NaN);\n        r = DatasetUtilities.iterateRangeBounds(d);\n        assertEquals(1.5, r.getLowerBound(), EPSILON);\n        assertEquals(3.5, r.getUpperBound(), EPSILON);\n    }\n"], "Closure_8": ["  public void testIssue820() throws Exception {\n    // Don't redeclare function parameters, this is incompatible with\n    // strict mode.\n    testSame(\"function f(a){ var b=1; a=2; var c; }\");\n  }\n"], "Math_54": ["    @Test\n    public void testIssue567() {\n        DfpField field = new DfpField(100);\n        Assert.assertEquals(0.0, field.getZero().toDouble(), MathUtils.SAFE_MIN);\n        Assert.assertEquals(0.0, field.newDfp(0.0).toDouble(), MathUtils.SAFE_MIN);\n        Assert.assertEquals(-1, FastMath.copySign(1, field.newDfp(-0.0).toDouble()), MathUtils.EPSILON);\n        Assert.assertEquals(+1, FastMath.copySign(1, field.newDfp(+0.0).toDouble()), MathUtils.EPSILON);\n    }\n"], "Closure_1": ["  public void testSimpleModeLeavesUnusedParams() {\n    args.add(\"--compilation_level=SIMPLE_OPTIMIZATIONS\");\n    testSame(\"window.f = function(a) {};\");\n  }\n", "  public void testDebugFlag1() {\n    args.add(\"--compilation_level=SIMPLE_OPTIMIZATIONS\");\n    args.add(\"--debug=false\");\n    test(\"function foo(a) {}\",\n         \"function foo(a) {}\");\n  }\n", "  public void testForwardDeclareDroppedTypes() {\n    args.add(\"--manage_closure_dependencies=true\");\n\n    args.add(\"--warning_level=VERBOSE\");\n    test(new String[] {\n          \"goog.require('beer');\",\n          \"goog.provide('beer'); /** @param {Scotch} x */ function f(x) {}\",\n          \"goog.provide('Scotch'); var x = 3;\"\n         },\n         new String[] {\n           \"var beer = {}; function f(a) {}\",\n           \"\"\n         });\n\n    test(new String[] {\n          \"goog.require('beer');\",\n          \"goog.provide('beer'); /** @param {Scotch} x */ function f(x) {}\"\n         },\n         new String[] {\n           \"var beer = {}; function f(a) {}\",\n           \"\"\n         },\n         RhinoErrorReporter.TYPE_PARSE_ERROR);\n  }\n", "  public void testIssue787() {\n    CompilerOptions options = createCompilerOptions();\n    CompilationLevel level = CompilationLevel.SIMPLE_OPTIMIZATIONS;\n    level.setOptionsForCompilationLevel(options);\n    WarningLevel warnings = WarningLevel.DEFAULT;\n    warnings.setOptionsForWarningLevel(options);\n\n    String code = \"\" +\n        \"function some_function() {\\n\" +\n        \"  var fn1;\\n\" +\n        \"  var fn2;\\n\" +\n        \"\\n\" +\n        \"  if (any_expression) {\\n\" +\n        \"    fn2 = external_ref;\\n\" +\n        \"    fn1 = function (content) {\\n\" +\n        \"      return fn2();\\n\" +\n        \"    }\\n\" +\n        \"  }\\n\" +\n        \"\\n\" +\n        \"  return {\\n\" +\n        \"    method1: function () {\\n\" +\n        \"      if (fn1) fn1();\\n\" +\n        \"      return true;\\n\" +\n        \"    },\\n\" +\n        \"    method2: function () {\\n\" +\n        \"      return false;\\n\" +\n        \"    }\\n\" +\n        \"  }\\n\" +\n        \"}\";\n\n    String result = \"\" +\n        \"function some_function() {\\n\" +\n        \"  var a, b;\\n\" +\n        \"  any_expression && (b = external_ref, a = function(a) {\\n\" +\n        \"    return b()\\n\" +\n        \"  });\\n\" +\n        \"  return{method1:function() {\\n\" +\n        \"    a && a();\\n\" +\n        \"    return !0\\n\" +\n        \"  }, method2:function() {\\n\" +\n        \"    return !1\\n\" +\n        \"  }}\\n\" +\n        \"}\\n\" +\n        \"\";\n\n    test(options, code, result);\n  }\n", "  public void testRemoveGlobal1() {\n    removeGlobal = false;\n    testSame(\"var x=1\");\n    test(\"var y=function(x){var z;}\", \"var y=function(x){}\");\n  }\n", "  public void testRemoveGlobal2() {\n    removeGlobal = false;\n    testSame(\"var x=1\");\n    test(\"function y(x){var z;}\", \"function y(x){}\");\n  }\n", "  public void testRemoveGlobal3() {\n    removeGlobal = false;\n    testSame(\"var x=1\");\n    test(\"function x(){function y(x){var z;}y()}\",\n         \"function x(){function y(x){}y()}\");\n  }\n", "  public void testIssue168b() {\n    removeGlobal = false;\n    test(\"function a(){\" +\n         \"  (function(x){ b(); })(1);\" +\n         \"}\" +\n         \"function b(){\" +\n         \"  a();\" +\n         \"}\",\n         \"function a(){(function(x){b()})(1)}\" +\n         \"function b(){a()}\");\n  }\n"], "Closure_6": ["  public void testTypeRedefinition() throws Exception {\n    testClosureTypesMultipleWarnings(\n        \"a={};/**@enum {string}*/ a.A = {ZOR:'b'};\"\n        + \"/** @constructor */ a.A = function() {}\",\n        Lists.newArrayList(\n            \"variable a.A redefined with type function (new:a.A): undefined, \" +\n            \"original definition at [testcode]:1 with type enum{a.A}\",\n            \"assignment to property A of a\\n\" +\n            \"found   : function (new:a.A): undefined\\n\" +\n            \"required: enum{a.A}\"));\n  }\n", "  public void testTypeRedefinition() throws Exception {\n    testClosureTypesMultipleWarnings(\"a={};/**@enum {string}*/ a.A = {ZOR:'b'};\"\n        + \"/** @constructor */ a.A = function() {}\",\n        Lists.newArrayList(\n            \"variable a.A redefined with type function (new:a.A): undefined, \" +\n            \"original definition at [testcode]:1 with type enum{a.A}\",\n            \"assignment to property A of a\\n\" +\n            \"found   : function (new:a.A): undefined\\n\" +\n            \"required: enum{a.A}\"));\n  }\n", "  public void testIssue635b() throws Exception {\n    testTypes(\n        \"/** @constructor */\" +\n        \"function F() {}\" +\n        \"/** @constructor */\" +\n        \"function G() {}\" +\n        \"/** @type {function(new:G)} */ var x = F;\",\n        \"initializing variable\\n\" +\n        \"found   : function (new:F): undefined\\n\" +\n        \"required: function (new:G): ?\");\n  }\n"], "Math_53": ["    @Test\n    public void testAddNaN() {\n        Complex x = new Complex(3.0, 4.0);\n        Complex z = x.add(Complex.NaN);\n        Assert.assertTrue(z.isNaN());\n        z = new Complex(1, nan);\n        Complex w = x.add(z);\n        Assert.assertTrue(Double.isNaN(w.getReal()));\n        Assert.assertTrue(Double.isNaN(w.getImaginary()));\n    }\n"], "Math_98": ["    public void testMath209() {\n        BigMatrix a = new BigMatrixImpl(new BigDecimal[][] {\n                { new BigDecimal(1), new BigDecimal(2) },\n                { new BigDecimal(3), new BigDecimal(4) },\n                { new BigDecimal(5), new BigDecimal(6) }\n        }, false);\n        BigDecimal[] b = a.operate(new BigDecimal[] { new BigDecimal(1), new BigDecimal(1) });\n        assertEquals(a.getRowDimension(), b.length);\n        assertEquals( 3.0, b[0].doubleValue(), 1.0e-12);\n        assertEquals( 7.0, b[1].doubleValue(), 1.0e-12);\n        assertEquals(11.0, b[2].doubleValue(), 1.0e-12);\n    }\n", "    public void testMath209() {\n        RealMatrix a = new RealMatrixImpl(new double[][] {\n                { 1, 2 }, { 3, 4 }, { 5, 6 }\n        }, false);\n        double[] b = a.operate(new double[] { 1, 1 });\n        assertEquals(a.getRowDimension(), b.length);\n        assertEquals( 3.0, b[0], 1.0e-12);\n        assertEquals( 7.0, b[1], 1.0e-12);\n        assertEquals(11.0, b[2], 1.0e-12);\n    }\n"], "Math_38": ["    @Test\n    public void testConstrainedRosenWithMoreInterpolationPoints() {\n        final double[] startPoint = point(DIM, 0.1);\n        final double[][] boundaries = boundaries(DIM, -1, 2);\n        final RealPointValuePair expected = new RealPointValuePair(point(DIM, 1.0), 0.0);\n\n        // This should have been 78 because in the code the hard limit is\n        // said to be\n        //   ((DIM + 1) * (DIM + 2)) / 2 - (2 * DIM + 1)\n        // i.e. 78 in this case, but the test fails for 48, 59, 62, 63, 64,\n        // 65, 66, ...\n        final int maxAdditionalPoints = 47;\n\n        for (int num = 1; num <= maxAdditionalPoints; num++) {\n            doTest(new Rosen(), startPoint, boundaries,\n                   GoalType.MINIMIZE,\n                   1e-12, 1e-6, 2000,\n                   num,\n                   expected,\n                   \"num=\" + num);\n        }\n    }\n"], "Math_36": ["    @Test\n    public void testDoubleValueForLargeNumeratorAndDenominator() {\n        final BigInteger pow400 = BigInteger.TEN.pow(400);\n        final BigInteger pow401 = BigInteger.TEN.pow(401);\n        final BigInteger two = new BigInteger(\"2\");\n        final BigFraction large = new BigFraction(pow401.add(BigInteger.ONE),\n                                                  pow400.multiply(two));\n\n        Assert.assertEquals(5, large.doubleValue(), 1e-15);\n    }\n", "    @Test\n    public void testFloatValueForLargeNumeratorAndDenominator() {\n        final BigInteger pow400 = BigInteger.TEN.pow(400);\n        final BigInteger pow401 = BigInteger.TEN.pow(401);\n        final BigInteger two = new BigInteger(\"2\");\n        final BigFraction large = new BigFraction(pow401.add(BigInteger.ONE),\n                                                  pow400.multiply(two));\n\n        Assert.assertEquals(5, large.floatValue(), 1e-15);\n    }\n"], "Math_31": ["    @Test\n    public void testMath718() {\n        // for large trials the evaluation of ContinuedFraction was inaccurate\n        // do a sweep over several large trials to test if the current implementation is\n        // numerically stable.\n\n        for (int trials = 500000; trials < 20000000; trials += 100000) {\n            BinomialDistribution dist = new BinomialDistribution(trials, 0.5);\n            int p = dist.inverseCumulativeProbability(0.5);\n            Assert.assertEquals(trials / 2, p);\n        }\n\n    }\n", "    @Test\n    public void testMath785() {\n        // this test was failing due to inaccurate results from ContinuedFraction.\n\n        try {\n            double prob = 0.01;\n            FDistribution f = new FDistribution(200000, 200000);\n            double result = f.inverseCumulativeProbability(prob);\n            Assert.assertTrue(result < 1.0);\n        } catch (Exception e) {\n            Assert.fail(\"Failing to calculate inverse cumulative probability\");\n        }\n    }\n"], "Closure_7": ["  public void testGoogIsFunction2() throws Exception {\n    testClosureFunction(\"goog.isFunction\",\n        OBJECT_NUMBER_STRING_BOOLEAN,\n        U2U_CONSTRUCTOR_TYPE,\n        OBJECT_NUMBER_STRING_BOOLEAN);\n  }\n", "  @SuppressWarnings(\"unchecked\")\n  public void testTypeof3() {\n    FlowScope blind = newScope();\n    testBinop(blind,\n        Token.EQ,\n        new Node(Token.TYPEOF, createVar(\n            blind, \"a\", OBJECT_NUMBER_STRING_BOOLEAN)),\n        Node.newString(\"function\"),\n        Sets.newHashSet(\n            new TypedName(\"a\", U2U_CONSTRUCTOR_TYPE)),\n        Sets.newHashSet(\n            new TypedName(\"a\", OBJECT_NUMBER_STRING_BOOLEAN)));\n  }\n"], "Math_52": ["  @Test\n  public void testIssue639(){\n      Vector3D u1 = new Vector3D(-1321008684645961.0 /  268435456.0,\n                                 -5774608829631843.0 /  268435456.0,\n                                 -3822921525525679.0 / 4294967296.0);\n      Vector3D u2 =new Vector3D( -5712344449280879.0 /    2097152.0,\n                                 -2275058564560979.0 /    1048576.0,\n                                  4423475992255071.0 /      65536.0);\n      Rotation rot = new Rotation(u1, u2, Vector3D.PLUS_I,Vector3D.PLUS_K);\n      Assert.assertEquals( 0.6228370359608200639829222, rot.getQ0(), 1.0e-15);\n      Assert.assertEquals( 0.0257707621456498790029987, rot.getQ1(), 1.0e-15);\n      Assert.assertEquals(-0.0000000002503012255839931, rot.getQ2(), 1.0e-15);\n      Assert.assertEquals(-0.7819270390861109450724902, rot.getQ3(), 1.0e-15);\n  }\n"], "Math_99": ["    public void testGcd() {\n        int a = 30;\n        int b = 50;\n        int c = 77;\n\n        assertEquals(0, MathUtils.gcd(0, 0));\n\n        assertEquals(b, MathUtils.gcd(0, b));\n        assertEquals(a, MathUtils.gcd(a, 0));\n        assertEquals(b, MathUtils.gcd(0, -b));\n        assertEquals(a, MathUtils.gcd(-a, 0));\n\n        assertEquals(10, MathUtils.gcd(a, b));\n        assertEquals(10, MathUtils.gcd(-a, b));\n        assertEquals(10, MathUtils.gcd(a, -b));\n        assertEquals(10, MathUtils.gcd(-a, -b));\n\n        assertEquals(1, MathUtils.gcd(a, c));\n        assertEquals(1, MathUtils.gcd(-a, c));\n        assertEquals(1, MathUtils.gcd(a, -c));\n        assertEquals(1, MathUtils.gcd(-a, -c));\n\n        assertEquals(3 * (1<<15), MathUtils.gcd(3 * (1<<20), 9 * (1<<15)));\n\n        assertEquals(Integer.MAX_VALUE, MathUtils.gcd(Integer.MAX_VALUE, 0));\n        assertEquals(Integer.MAX_VALUE, MathUtils.gcd(-Integer.MAX_VALUE, 0));\n        assertEquals(1<<30, MathUtils.gcd(1<<30, -Integer.MIN_VALUE));\n        try {\n            // gcd(Integer.MIN_VALUE, 0) > Integer.MAX_VALUE\n            MathUtils.gcd(Integer.MIN_VALUE, 0);\n            fail(\"expecting ArithmeticException\");\n        } catch (ArithmeticException expected) {\n            // expected\n        }\n        try {\n            // gcd(0, Integer.MIN_VALUE) > Integer.MAX_VALUE\n            MathUtils.gcd(0, Integer.MIN_VALUE);\n            fail(\"expecting ArithmeticException\");\n        } catch (ArithmeticException expected) {\n            // expected\n        }\n        try {\n            // gcd(Integer.MIN_VALUE, Integer.MIN_VALUE) > Integer.MAX_VALUE\n            MathUtils.gcd(Integer.MIN_VALUE, Integer.MIN_VALUE);\n            fail(\"expecting ArithmeticException\");\n        } catch (ArithmeticException expected) {\n            // expected\n        }\n    }\n", "    public void testLcm() {\n        int a = 30;\n        int b = 50;\n        int c = 77;\n\n        assertEquals(0, MathUtils.lcm(0, b));\n        assertEquals(0, MathUtils.lcm(a, 0));\n        assertEquals(b, MathUtils.lcm(1, b));\n        assertEquals(a, MathUtils.lcm(a, 1));\n        assertEquals(150, MathUtils.lcm(a, b));\n        assertEquals(150, MathUtils.lcm(-a, b));\n        assertEquals(150, MathUtils.lcm(a, -b));\n        assertEquals(150, MathUtils.lcm(-a, -b));\n        assertEquals(2310, MathUtils.lcm(a, c));\n\n        // Assert that no intermediate value overflows:\n        // The naive implementation of lcm(a,b) would be (a*b)/gcd(a,b)\n        assertEquals((1<<20)*15, MathUtils.lcm((1<<20)*3, (1<<20)*5));\n\n        // Special case\n        assertEquals(0, MathUtils.lcm(0, 0));\n\n        try {\n            // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n            MathUtils.lcm(Integer.MIN_VALUE, 1);\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            // expected\n        }\n        \n        try {\n            // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n            MathUtils.lcm(Integer.MIN_VALUE, 1<<20);\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            // expected\n        }\n\n        try {\n            MathUtils.lcm(Integer.MAX_VALUE, Integer.MAX_VALUE - 1);\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            // expected\n        }\n    }\n"], "Math_55": ["    @Test\n    public void testCrossProductCancellation() {\n        Vector3D v1 = new Vector3D(9070467121.0, 4535233560.0, 1);\n        Vector3D v2 = new Vector3D(9070467123.0, 4535233561.0, 1);\n        checkVector(Vector3D.crossProduct(v1, v2), -1, 2, 1);\n\n        double scale    = FastMath.scalb(1.0, 100);\n        Vector3D big1   = new Vector3D(scale, v1);\n        Vector3D small2 = new Vector3D(1 / scale, v2);\n        checkVector(Vector3D.crossProduct(big1, small2), -1, 2, 1);\n\n    }\n"], "Math_63": ["    public void testArrayEquals() {\n        assertFalse(MathUtils.equals(new double[] { 1d }, null));\n        assertFalse(MathUtils.equals(null, new double[] { 1d }));\n        assertTrue(MathUtils.equals((double[]) null, (double[]) null));\n\n        assertFalse(MathUtils.equals(new double[] { 1d }, new double[0]));\n        assertTrue(MathUtils.equals(new double[] { 1d }, new double[] { 1d }));\n        assertTrue(MathUtils.equals(new double[] {\n                                      Double.POSITIVE_INFINITY,\n                                      Double.NEGATIVE_INFINITY, 1d, 0d\n                                    }, new double[] {\n                                      Double.POSITIVE_INFINITY,\n                                      Double.NEGATIVE_INFINITY, 1d, 0d\n                                    }));\n        assertFalse(MathUtils.equals(new double[] { Double.NaN },\n                                     new double[] { Double.NaN }));\n        assertFalse(MathUtils.equals(new double[] { Double.POSITIVE_INFINITY },\n                                     new double[] { Double.NEGATIVE_INFINITY }));\n        assertFalse(MathUtils.equals(new double[] { 1d },\n                                     new double[] { FastMath.nextAfter(FastMath.nextAfter(1d, 2d), 2d) }));\n\n    }\n", "    public void testArrayEqualsIncludingNaN() {\n        assertFalse(MathUtils.equalsIncludingNaN(new double[] { 1d }, null));\n        assertFalse(MathUtils.equalsIncludingNaN(null, new double[] { 1d }));\n        assertTrue(MathUtils.equalsIncludingNaN((double[]) null, (double[]) null));\n\n        assertFalse(MathUtils.equalsIncludingNaN(new double[] { 1d }, new double[0]));\n        assertTrue(MathUtils.equalsIncludingNaN(new double[] { 1d }, new double[] { 1d }));\n        assertTrue(MathUtils.equalsIncludingNaN(new double[] {\n                    Double.NaN, Double.POSITIVE_INFINITY,\n                    Double.NEGATIVE_INFINITY, 1d, 0d\n                }, new double[] {\n                    Double.NaN, Double.POSITIVE_INFINITY,\n                    Double.NEGATIVE_INFINITY, 1d, 0d\n                }));\n        assertFalse(MathUtils.equalsIncludingNaN(new double[] { Double.POSITIVE_INFINITY },\n                                                 new double[] { Double.NEGATIVE_INFINITY }));\n        assertFalse(MathUtils.equalsIncludingNaN(new double[] { 1d },\n                                                 new double[] { FastMath.nextAfter(FastMath.nextAfter(1d, 2d), 2d) }));\n    }\n"], "Math_97": ["    public void testRootEndpoints() throws Exception {\n        UnivariateRealFunction f = new SinFunction();\n        UnivariateRealSolver solver = new BrentSolver(f);\n        \n        // endpoint is root\n        double result = solver.solve(Math.PI, 4);\n        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n\n        result = solver.solve(3, Math.PI);\n        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n    }\n"], "Closure_9": ["  public void testGuessModuleName() {\n    ProcessCommonJSModules pass = new ProcessCommonJSModules(null, \"foo\");\n    assertEquals(\"module$baz\",\n        pass.guessCJSModuleName(\"foo/baz.js\"));\n    assertEquals(\"module$baz\",\n        pass.guessCJSModuleName(\"foo\\\\baz.js\"));\n    assertEquals(\"module$bar$baz\",\n        pass.guessCJSModuleName(\"foo\\\\bar\\\\baz.js\"));\n  }\n"], "Chart_3": ["    public void testCreateCopy3() throws CloneNotSupportedException {\n        TimeSeries s1 = new TimeSeries(\"S1\");\n        s1.add(new Year(2009), 100.0);\n        s1.add(new Year(2010), 101.0);\n        s1.add(new Year(2011), 102.0);\n        assertEquals(100.0, s1.getMinY(), EPSILON);\n        assertEquals(102.0, s1.getMaxY(), EPSILON);\n\n        TimeSeries s2 = s1.createCopy(0, 1);\n        assertEquals(100.0, s2.getMinY(), EPSILON);\n        assertEquals(101.0, s2.getMaxY(), EPSILON);\n\n        TimeSeries s3 = s1.createCopy(1, 2);\n        assertEquals(101.0, s3.getMinY(), EPSILON);\n        assertEquals(102.0, s3.getMaxY(), EPSILON);\n    }\n"], "Math_90": ["    public void testAddNonComparable(){\n        try {\n            f.addValue(new Object()); // This was OK\n            fail(\"Expected ClassCastException\");\n        } catch (ClassCastException expected) {\n        }\n        f.clear();\n        f.addValue(1);\n        try {\n            f.addValue(new Object());\n            fail(\"Expected ClassCastException\"); // Previously would have been IllegalArgument\n        } catch (ClassCastException expected) {\n        }\n    }\n"], "Math_64": ["  public void testMinpackFreudensteinRoth() {\n    minpackTest(new FreudensteinRothFunction(new double[] { 0.5, -2.0 },\n                                             20.0124960961895, 6.99887517584575,\n                                             new double[] {\n                                               11.4124844654993,\n                                               -0.896827913731509\n                                             }), false);\n    minpackTest(new FreudensteinRothFunction(new double[] { 5.0, -20.0 },\n                                             12432.833948863, 6.9988751744895,\n                                             new double[] {\n                                                11.41300466147456,\n                                                -0.896796038685959\n                                             }), false);\n    minpackTest(new FreudensteinRothFunction(new double[] { 50.0, -200.0 },\n                                             11426454.595762, 6.99887517242903,\n                                             new double[] {\n                                                 11.412781785788564,\n                                                 -0.8968051074920405\n                                             }), false);\n  }\n", "  public void testMinpackJennrichSampson() {\n    minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 },\n                                            64.5856498144943, 11.1517793413499,\n                                            new double[] {\n //                                            0.2578330049, 0.257829976764542\n                                               0.2578199266368004, 0.25782997676455244\n                                            }), false);\n  }\n"], "Chart_4": ["    public void testXYAutoRange1() {\n        XYSeries series = new XYSeries(\"Series 1\");\n        series.add(1.0, 1.0);\n        series.add(2.0, 2.0);\n        series.add(3.0, 3.0);\n        XYSeriesCollection dataset = new XYSeriesCollection();\n        dataset.addSeries(series);\n        JFreeChart chart = ChartFactory.createScatterPlot(\n            \"Test\",\n            \"X\",\n            \"Y\",\n            dataset,\n            PlotOrientation.VERTICAL,\n            false,\n            false,\n            false\n        );\n        XYPlot plot = (XYPlot) chart.getPlot();\n        LogAxis axis = new LogAxis(\"Log(Y)\");\n        plot.setRangeAxis(axis);\n        assertEquals(0.9465508226401592, axis.getLowerBound(), EPSILON);\n        assertEquals(3.1694019256486126, axis.getUpperBound(), EPSILON);\n    }\n", "    public void testXYAutoRange2() {\n        XYSeries series = new XYSeries(\"Series 1\");\n        series.add(1.0, 1.0);\n        series.add(2.0, 2.0);\n        series.add(3.0, 3.0);\n        XYSeriesCollection dataset = new XYSeriesCollection();\n        dataset.addSeries(series);\n        JFreeChart chart = ChartFactory.createScatterPlot(\n            \"Test\",\n            \"X\",\n            \"Y\",\n            dataset,\n            PlotOrientation.VERTICAL,\n            false,\n            false,\n            false\n        );\n        XYPlot plot = (XYPlot) chart.getPlot();\n        LogAxis axis = new LogAxis(\"Log(Y)\");\n        plot.setRangeAxis(axis);\n        assertEquals(0.9465508226401592, axis.getLowerBound(), EPSILON);\n        assertEquals(3.1694019256486126, axis.getUpperBound(), EPSILON);\n    }\n", "    public void testXYAutoRange1() {\n        XYSeries series = new XYSeries(\"Series 1\");\n        series.add(1.0, 1.0);\n        series.add(2.0, 2.0);\n        series.add(3.0, 3.0);\n        XYSeriesCollection dataset = new XYSeriesCollection();\n        dataset.addSeries(series);\n        JFreeChart chart = ChartFactory.createScatterPlot(\n            \"Test\",\n            \"X\",\n            \"Y\",\n            dataset,\n            PlotOrientation.VERTICAL,\n            false,\n            false,\n            false\n        );\n        XYPlot plot = (XYPlot) chart.getPlot();\n        NumberAxis axis = (NumberAxis) plot.getDomainAxis();\n        axis.setAutoRangeIncludesZero(false);\n        assertEquals(0.9, axis.getLowerBound(), EPSILON);\n        assertEquals(3.1, axis.getUpperBound(), EPSILON);\n    }\n", "    public void testXYAutoRange2() {\n        XYSeries series = new XYSeries(\"Series 1\");\n        series.add(1.0, 1.0);\n        series.add(2.0, 2.0);\n        series.add(3.0, 3.0);\n        XYSeriesCollection dataset = new XYSeriesCollection();\n        dataset.addSeries(series);\n        JFreeChart chart = ChartFactory.createScatterPlot(\n            \"Test\",\n            \"X\",\n            \"Y\",\n            dataset,\n            PlotOrientation.VERTICAL,\n            false,\n            false,\n            false\n        );\n        XYPlot plot = (XYPlot) chart.getPlot();\n        NumberAxis axis = (NumberAxis) plot.getRangeAxis();\n        axis.setAutoRangeIncludesZero(false);\n        assertEquals(0.9, axis.getLowerBound(), EPSILON);\n        assertEquals(3.1, axis.getUpperBound(), EPSILON);\n    }\n", "    public void testAxisMargins() {\n        XYSeries series = new XYSeries(\"S1\");\n        series.add(100.0, 1.1);\n        series.add(200.0, 2.2);\n        XYSeriesCollection dataset = new XYSeriesCollection(series);\n        dataset.setIntervalWidth(0.0);\n        JFreeChart chart = ChartFactory.createScatterPlot(\n            \"Title\", \"X\", \"Y\", dataset, PlotOrientation.VERTICAL,\n            false, false, false\n        );\n        ValueAxis domainAxis = ((XYPlot) chart.getPlot()).getDomainAxis();\n        Range r = domainAxis.getRange();\n        assertEquals(110.0, r.getLength(), EPSILON);\n        domainAxis.setLowerMargin(0.10);\n        domainAxis.setUpperMargin(0.10);\n        r = domainAxis.getRange();\n        assertEquals(120.0, r.getLength(), EPSILON);\n    }\n", "    public void testSerialization4() {\n\n        RegularTimePeriod t = new Day();\n        TimeSeries series = new TimeSeries(\"Series 1\");\n        series.add(t, 36.4);\n        t = t.next();\n        series.add(t, 63.5);\n        TimeSeriesCollection dataset = new TimeSeriesCollection();\n        dataset.addSeries(series);\n\n        JFreeChart c1 = ChartFactory.createTimeSeriesChart(\"Test\", \"Date\",\n                \"Value\", dataset, true, true, true);\n        JFreeChart c2 = null;\n\n        try {\n            ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n            ObjectOutput out = new ObjectOutputStream(buffer);\n            out.writeObject(c1);\n            out.close();\n\n            ObjectInput in = new ObjectInputStream(new ByteArrayInputStream(\n                    buffer.toByteArray()));\n            c2 = (JFreeChart) in.readObject();\n            in.close();\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n        }\n        assertEquals(c1, c2);\n\n    }\n", "    public void testDrawWithNullInfo() {\n\n        boolean success = false;\n\n        try {\n            BufferedImage image = new BufferedImage(200 , 100,\n                    BufferedImage.TYPE_INT_RGB);\n            Graphics2D g2 = image.createGraphics();\n            this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null,\n                    null);\n            g2.dispose();\n            success = true;\n        }\n        catch (Exception e) {\n          success = false;\n          e.printStackTrace();\n        }\n\n        assertTrue(success);\n\n    }\n", "    public void testReplaceDataset() {\n\n        // create a dataset...\n        XYSeries series1 = new XYSeries(\"Series 1\");\n        series1.add(10.0, 10.0);\n        series1.add(20.0, 20.0);\n        series1.add(30.0, 30.0);\n        XYDataset dataset = new XYSeriesCollection(series1);\n\n        LocalListener l = new LocalListener();\n        this.chart.addChangeListener(l);\n        XYPlot plot = (XYPlot) this.chart.getPlot();\n        plot.setDataset(dataset);\n        assertEquals(true, l.flag);\n        ValueAxis axis = plot.getRangeAxis();\n        Range range = axis.getRange();\n        assertTrue(\"Expecting the lower bound of the range to be around 10: \"\n                   + range.getLowerBound(), range.getLowerBound() <= 10);\n        assertTrue(\"Expecting the upper bound of the range to be around 30: \"\n                   + range.getUpperBound(), range.getUpperBound() >= 30);\n\n    }\n", "    public void testSetSeriesToolTipGenerator() {\n        XYPlot plot = (XYPlot) this.chart.getPlot();\n        XYItemRenderer renderer = plot.getRenderer();\n        StandardXYToolTipGenerator tt = new StandardXYToolTipGenerator();\n        renderer.setSeriesToolTipGenerator(0, tt);\n        XYToolTipGenerator tt2 = renderer.getToolTipGenerator(0, 0, false);\n        assertTrue(tt2 == tt);\n    }\n", "    public void testDrawWithNullInfo() {\n\n        boolean success = false;\n        try {\n            BufferedImage image = new BufferedImage(200 , 100,\n                    BufferedImage.TYPE_INT_RGB);\n            Graphics2D g2 = image.createGraphics();\n            this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null,\n                    null);\n            g2.dispose();\n            success = true;\n        }\n        catch (Exception e) {\n          success = false;\n          e.printStackTrace();\n        }\n        assertTrue(success);\n\n    }\n", "    public void testReplaceDataset() {\n\n        // create a dataset...\n        XYSeries series1 = new XYSeries(\"Series 1\");\n        series1.add(10.0, 10.0);\n        series1.add(20.0, 20.0);\n        series1.add(30.0, 30.0);\n        XYDataset dataset = new XYSeriesCollection(series1);\n\n        LocalListener l = new LocalListener();\n        this.chart.addChangeListener(l);\n        XYPlot plot = (XYPlot) this.chart.getPlot();\n        plot.setDataset(dataset);\n        assertEquals(true, l.flag);\n        ValueAxis axis = plot.getRangeAxis();\n        Range range = axis.getRange();\n        assertTrue(\"Expecting the lower bound of the range to be around 10: \"\n                   + range.getLowerBound(), range.getLowerBound() <= 10);\n        assertTrue(\"Expecting the upper bound of the range to be around 30: \"\n                   + range.getUpperBound(), range.getUpperBound() >= 30);\n\n    }\n", "    public void testSetSeriesToolTipGenerator() {\n        XYPlot plot = (XYPlot) this.chart.getPlot();\n        XYItemRenderer renderer = plot.getRenderer();\n        StandardXYToolTipGenerator tt = new StandardXYToolTipGenerator();\n        renderer.setSeriesToolTipGenerator(0, tt);\n        XYToolTipGenerator tt2 = renderer.getToolTipGenerator(0, 0, false);\n        assertTrue(tt2 == tt);\n    }\n", "    public void testDrawWithNullInfo() {\n\n        boolean success = false;\n        try {\n            BufferedImage image = new BufferedImage(200 , 100,\n                    BufferedImage.TYPE_INT_RGB);\n            Graphics2D g2 = image.createGraphics();\n            this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null,\n                    null);\n            g2.dispose();\n            success = true;\n        }\n        catch (Exception e) {\n          success = false;\n          e.printStackTrace();\n        }\n        assertTrue(success);\n\n    }\n", "    public void testReplaceDataset() {\n\n        // create a dataset...\n        XYSeries series1 = new XYSeries(\"Series 1\");\n        series1.add(10.0, 10.0);\n        series1.add(20.0, 20.0);\n        series1.add(30.0, 30.0);\n        XYDataset dataset = new XYSeriesCollection(series1);\n\n        LocalListener l = new LocalListener();\n        this.chart.addChangeListener(l);\n        XYPlot plot = (XYPlot) this.chart.getPlot();\n        plot.setDataset(dataset);\n        assertEquals(true, l.flag);\n        ValueAxis axis = plot.getRangeAxis();\n        Range range = axis.getRange();\n        assertTrue(\"Expecting the lower bound of the range to be around 10: \"\n                   + range.getLowerBound(), range.getLowerBound() <= 10);\n        assertTrue(\"Expecting the upper bound of the range to be around 30: \"\n                   + range.getUpperBound(), range.getUpperBound() >= 30);\n\n    }\n", "    public void testSetSeriesToolTipGenerator() {\n        XYPlot plot = (XYPlot) this.chart.getPlot();\n        XYItemRenderer renderer = plot.getRenderer();\n        StandardXYToolTipGenerator tt = new StandardXYToolTipGenerator();\n        renderer.setSeriesToolTipGenerator(0, tt);\n        XYToolTipGenerator tt2 = renderer.getToolTipGenerator(0, 0,\n                false);\n        assertTrue(tt2 == tt);\n    }\n", "    public void testDrawWithNullInfo() {\n\n        boolean success = false;\n        try {\n            BufferedImage image = new BufferedImage(200 , 100,\n                    BufferedImage.TYPE_INT_RGB);\n            Graphics2D g2 = image.createGraphics();\n            this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null,\n                    null);\n            g2.dispose();\n            success = true;\n        }\n        catch (Exception e) {\n          success = false;\n          e.printStackTrace();\n        }\n        assertTrue(success);\n\n    }\n", "    public void testReplaceDataset() {\n\n        // create a dataset...\n        XYSeries series1 = new XYSeries(\"Series 1\");\n        series1.add(10.0, 10.0);\n        series1.add(20.0, 20.0);\n        series1.add(30.0, 30.0);\n        XYDataset dataset = new XYSeriesCollection(series1);\n\n        LocalListener l = new LocalListener();\n        this.chart.addChangeListener(l);\n        XYPlot plot = (XYPlot) this.chart.getPlot();\n        plot.setDataset(dataset);\n        assertEquals(true, l.flag);\n        ValueAxis axis = plot.getRangeAxis();\n        Range range = axis.getRange();\n        assertTrue(\"Expecting the lower bound of the range to be around 10: \"\n                   + range.getLowerBound(), range.getLowerBound() <= 10);\n        assertTrue(\"Expecting the upper bound of the range to be around 30: \"\n                   + range.getUpperBound(), range.getUpperBound() >= 30);\n\n    }\n", "    public void testSetSeriesToolTipGenerator() {\n        XYPlot plot = (XYPlot) this.chart.getPlot();\n        XYItemRenderer renderer = plot.getRenderer();\n        StandardXYToolTipGenerator tt = new StandardXYToolTipGenerator();\n        renderer.setSeriesToolTipGenerator(0, tt);\n        XYToolTipGenerator tt2 = renderer.getToolTipGenerator(0, 0, false);\n        assertTrue(tt2 == tt);\n    }\n", "    public void testDrawWithNullInfo() {\n\n        boolean success = false;\n        try {\n            BufferedImage image = new BufferedImage(200 , 100,\n                    BufferedImage.TYPE_INT_RGB);\n            Graphics2D g2 = image.createGraphics();\n            this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null,\n                    null);\n            g2.dispose();\n            success = true;\n        }\n        catch (Exception e) {\n          success = false;\n          e.printStackTrace();\n        }\n        assertTrue(success);\n\n    }\n", "    public void testReplaceDataset() {\n\n        // create a dataset...\n        XYSeries series1 = new XYSeries(\"Series 1\");\n        series1.add(10.0, 10.0);\n        series1.add(20.0, 20.0);\n        series1.add(30.0, 30.0);\n        XYDataset dataset = new XYSeriesCollection(series1);\n\n        LocalListener l = new LocalListener();\n        this.chart.addChangeListener(l);\n        XYPlot plot = (XYPlot) this.chart.getPlot();\n        plot.setDataset(dataset);\n        assertEquals(true, l.flag);\n        ValueAxis axis = plot.getRangeAxis();\n        Range range = axis.getRange();\n        assertTrue(\"Expecting the lower bound of the range to be around 10: \"\n                   + range.getLowerBound(), range.getLowerBound() <= 10);\n        assertTrue(\"Expecting the upper bound of the range to be around 30: \"\n                   + range.getUpperBound(), range.getUpperBound() >= 30);\n\n    }\n", "    public void testSetSeriesToolTipGenerator() {\n        XYPlot plot = (XYPlot) this.chart.getPlot();\n        XYItemRenderer renderer = plot.getRenderer();\n        StandardXYToolTipGenerator tt = new StandardXYToolTipGenerator();\n        renderer.setSeriesToolTipGenerator(0, tt);\n        XYToolTipGenerator tt2 = renderer.getToolTipGenerator(0, 0, false);\n        assertTrue(tt2 == tt);\n    }\n", "    public void testSerialization4() {\n\n        XYSeriesCollection dataset = new XYSeriesCollection();\n        JFreeChart chart = ChartFactory.createXYLineChart(\n            \"Test Chart\",\n            \"Domain Axis\",\n            \"Range Axis\",\n            dataset,\n            PlotOrientation.VERTICAL,\n            true,\n            true,\n            false\n        );\n        XYPlot plot = (XYPlot) chart.getPlot();\n        plot.addDomainMarker(new ValueMarker(1.0), Layer.FOREGROUND);\n        plot.addDomainMarker(new IntervalMarker(2.0, 3.0), Layer.BACKGROUND);\n        plot.addRangeMarker(new ValueMarker(4.0), Layer.FOREGROUND);\n        plot.addRangeMarker(new IntervalMarker(5.0, 6.0), Layer.BACKGROUND);\n        JFreeChart chart2 = null;\n\n        // serialize and deserialize the chart....\n        try {\n            ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n            ObjectOutput out = new ObjectOutputStream(buffer);\n            out.writeObject(chart);\n            out.close();\n\n            ObjectInput in = new ObjectInputStream(\n                new ByteArrayInputStream(buffer.toByteArray())\n            );\n            chart2 = (JFreeChart) in.readObject();\n            in.close();\n        }\n        catch (Exception e) {\n            fail(e.toString());\n        }\n\n        assertEquals(chart, chart2);\n        boolean passed = true;\n        try {\n            chart2.createBufferedImage(300, 200);\n        }\n        catch (Exception e) {\n            passed = false;\n            e.printStackTrace();\n        }\n        assertTrue(passed);\n    }\n", "    public void testDrawRangeGridlines() {\n        DefaultXYDataset dataset = new DefaultXYDataset();\n        JFreeChart chart = ChartFactory.createXYLineChart(\"Title\", \"X\", \"Y\",\n                dataset, PlotOrientation.VERTICAL, true, false, false);\n        XYPlot plot = (XYPlot) chart.getPlot();\n        plot.setRenderer(null);\n        boolean success = false;\n        try {\n            BufferedImage image = new BufferedImage(200 , 100,\n                    BufferedImage.TYPE_INT_RGB);\n            Graphics2D g2 = image.createGraphics();\n            chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, null);\n            g2.dispose();\n            success = true;\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n            success = false;\n        }\n        assertTrue(success);\n    }\n"], "Math_30": ["    @Test\n    public void testBigDataSet() throws Exception {\n        double[] d1 = new double[1500];\n        double[] d2 = new double[1500];\n        for (int i = 0; i < 1500; i++) {\n            d1[i] = 2 * i;\n            d2[i] = 2 * i + 1;\n        }\n        double result = testStatistic.mannWhitneyUTest(d1, d2);\n        Assert.assertTrue(result > 0.1);\n    }\n"], "Math_37": ["    @Test\n    public void testTan() {\n        Complex z = new Complex(3, 4);\n        Complex expected = new Complex(-0.000187346, 0.999356);\n        TestUtils.assertEquals(expected, z.tan(), 1.0e-5);\n        /* Check that no overflow occurs (MATH-722) */\n        Complex actual = new Complex(3.0, 1E10).tan();\n        expected = new Complex(0, 1);\n        TestUtils.assertEquals(expected, actual, 1.0e-5);\n        actual = new Complex(3.0, -1E10).tan();\n        expected = new Complex(0, -1);\n        TestUtils.assertEquals(expected, actual, 1.0e-5);\n    }\n", "    @Test\n    public void testTanNaN() {\n        Assert.assertTrue(Complex.NaN.tan().isNaN());\n    }\n", "    @Test\n    public void testTanInf() {\n        TestUtils.assertSame(Complex.valueOf(0.0, 1.0), oneInf.tan());\n        TestUtils.assertSame(Complex.valueOf(0.0, -1.0), oneNegInf.tan());\n        TestUtils.assertSame(Complex.NaN, infOne.tan());\n        TestUtils.assertSame(Complex.NaN, negInfOne.tan());\n        TestUtils.assertSame(Complex.NaN, infInf.tan());\n        TestUtils.assertSame(Complex.NaN, infNegInf.tan());\n        TestUtils.assertSame(Complex.NaN, negInfInf.tan());\n        TestUtils.assertSame(Complex.NaN, negInfNegInf.tan());\n    }\n", "   @Test\n   public void testTanCritical() {\n        TestUtils.assertSame(infNaN, new Complex(pi/2, 0).tan());\n        TestUtils.assertSame(negInfNaN, new Complex(-pi/2, 0).tan());\n    }\n", "    @Test\n    public void testTanh() {\n        Complex z = new Complex(3, 4);\n        Complex expected = new Complex(1.00071, 0.00490826);\n        TestUtils.assertEquals(expected, z.tanh(), 1.0e-5);\n        /* Check that no overflow occurs (MATH-722) */\n        Complex actual = new Complex(1E10, 3.0).tanh();\n        expected = new Complex(1, 0);\n        TestUtils.assertEquals(expected, actual, 1.0e-5);\n        actual = new Complex(-1E10, 3.0).tanh();\n        expected = new Complex(-1, 0);\n        TestUtils.assertEquals(expected, actual, 1.0e-5);\n    }\n", "    @Test\n    public void testTanhNaN() {\n        Assert.assertTrue(Complex.NaN.tanh().isNaN());\n    }\n", "    @Test\n    public void testTanhInf() {\n        TestUtils.assertSame(Complex.NaN, oneInf.tanh());\n        TestUtils.assertSame(Complex.NaN, oneNegInf.tanh());\n        TestUtils.assertSame(Complex.valueOf(1.0, 0.0), infOne.tanh());\n        TestUtils.assertSame(Complex.valueOf(-1.0, 0.0), negInfOne.tanh());\n        TestUtils.assertSame(Complex.NaN, infInf.tanh());\n        TestUtils.assertSame(Complex.NaN, infNegInf.tanh());\n        TestUtils.assertSame(Complex.NaN, negInfInf.tanh());\n        TestUtils.assertSame(Complex.NaN, negInfNegInf.tanh());\n    }\n", "    @Test\n    public void testTanhCritical() {\n        TestUtils.assertSame(nanInf, new Complex(0, pi/2).tanh());\n    }\n"], "Math_39": ["  @Test\n  public void testTooLargeFirstStep() {\n\n      AdaptiveStepsizeIntegrator integ =\n              new DormandPrince853Integrator(0, Double.POSITIVE_INFINITY, Double.NaN, Double.NaN);\n      final double start = 0.0;\n      final double end   = 0.001;\n      FirstOrderDifferentialEquations equations = new FirstOrderDifferentialEquations() {\n\n          public int getDimension() {\n              return 1;\n          }\n\n          public void computeDerivatives(double t, double[] y, double[] yDot) {\n              Assert.assertTrue(t >= FastMath.nextAfter(start, Double.NEGATIVE_INFINITY));\n              Assert.assertTrue(t <= FastMath.nextAfter(end,   Double.POSITIVE_INFINITY));\n              yDot[0] = -100.0 * y[0];\n          }\n\n      };\n\n      integ.setStepSizeControl(0, 1.0, 1.0e-6, 1.0e-8);\n      integ.integrate(equations, start, new double[] { 1.0 }, end, new double[1]);\n\n  }\n"]}